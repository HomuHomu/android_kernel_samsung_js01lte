diff --cc sound/core/jack.c
index 9e2e085,6e2dbdb..0000000
--- a/sound/core/jack.c
+++ b/sound/core/jack.c
@@@ -35,6 -35,7 +35,10 @@@ static int jack_switch_types[] = 
  	SW_HPHL_OVERCURRENT,
  	SW_HPHR_OVERCURRENT,
  	SW_UNSUPPORT_INSERT,
++<<<<<<< HEAD
++=======
+ 	SW_MICROPHONE2_INSERT,
++>>>>>>> FETCH_HEAD
  };
  
  static int snd_jack_dev_free(struct snd_device *device)
diff --cc sound/soc/codecs/es325.c
index 4c24dfd,d02ce55..0000000
--- a/sound/soc/codecs/es325.c
+++ b/sound/soc/codecs/es325.c
@@@ -1471,9 -1471,6 +1471,12 @@@ static ssize_t es325_route_status_show(
  
  	u8 ack_msg[4];
  
++<<<<<<< HEAD
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
 +
++=======
++>>>>>>> FETCH_HEAD
  	/* Read route status */
  	if (es325_request_response(es325, route_st_req_msg, 4, 1, ack_msg, 4, 1, 0, 0) < 0) {
  		rc = rc + snprintf(buf+rc, PAGE_SIZE - rc,
@@@ -1658,9 -1655,6 +1661,12 @@@ static ssize_t es325_route_config_set(s
  {
  	long route_index;
  	int rc;
++<<<<<<< HEAD
 +	
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
++=======
++>>>>>>> FETCH_HEAD
  
  	dev_info(dev, "=[ES325]=%s():buf = %s\n", __func__, buf);
  	rc = kstrtol(buf, 10, &route_index);
@@@ -1693,9 -1687,6 +1699,12 @@@ static ssize_t es325_fw_version_show(st
  	char versionbuffer[SIZE_OF_VERBUF];
  	char *verbuf = versionbuffer;
  	char cmd[4];
++<<<<<<< HEAD
 +	
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
++=======
++>>>>>>> FETCH_HEAD
  
  	memset(verbuf,0,SIZE_OF_VERBUF);
  	memcpy(cmd, first_char_msg, 4);
@@@ -1738,9 -1729,6 +1747,12 @@@ static ssize_t es325_txhex_set(struct d
  	int offset = 0;
  	u8 resp[4];
  	int rc;
++<<<<<<< HEAD
 +	
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
++=======
++>>>>>>> FETCH_HEAD
  
  	dev_dbg(dev, "+[ES325]=%s()\n", __func__);
  	dev_dbg(dev, "=[ES325]=%s(): count=%i\n", __func__, count);
@@@ -1777,9 -1765,6 +1789,12 @@@ static DEVICE_ATTR(txhex, 0644, es325_t
  static ssize_t es325_clock_on_show(struct device *dev, struct device_attribute *attr, char *buf)
  {
  	char status[4];
++<<<<<<< HEAD
 +	
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
++=======
++>>>>>>> FETCH_HEAD
  
  	dev_dbg(dev, "=[ES325]=%s\n", __func__);
  	if(es325_priv.clock_on)
@@@ -1798,9 -1783,6 +1813,12 @@@ static ssize_t es325_slim_ch_show(struc
  	struct es325_slim_dai_data* dai = priv->dai;
  	int length = 0;
  	int i, j;
++<<<<<<< HEAD
 +	
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
++=======
++>>>>>>> FETCH_HEAD
  
  	for(i = 0; i < ES325_NUM_CODEC_SLIM_DAIS; i++) {
  		length += sprintf(buf+length,"=dai[%d]=rate[%d]=ch_num=",i, dai[i].rate);
@@@ -1820,9 -1802,6 +1838,12 @@@ static ssize_t es325_reg_show(struct de
  	int i;
  	int size = 0;
  
++<<<<<<< HEAD
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
 +
++=======
++>>>>>>> FETCH_HEAD
  	length += sprintf(buf+length,"es325_reg : algo\n");
  	size = sizeof(es325_algo_paramid)/sizeof(unsigned short); /* 127 items */
  	for(i = ES325_MIC_CONFIG; i < size; i++)
@@@ -1842,9 -1821,6 +1863,12 @@@ static ssize_t es325_reg_write(struct d
  	char tempbuf[32];
  	char *start = tempbuf;
  	unsigned long reg, value;
++<<<<<<< HEAD
 +	
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
++=======
++>>>>>>> FETCH_HEAD
  
  	memcpy(tempbuf, buf, size);
  	tempbuf[size] = 0;
@@@ -1870,9 -1846,6 +1894,12 @@@ static ssize_t es325_cmd_reg_show(struc
  	int i;
  	int size = 0;
  
++<<<<<<< HEAD
 +	if (es325_priv.wakeup_cnt == 0)
 +		return 0;
 +	
++=======
++>>>>>>> FETCH_HEAD
  	/* removed 0x2001(first), 0x20d4(end) register read, because of error */
  	size = sizeof(es325_cmd_access)/sizeof(struct es325_cmd_access); /* 213 items */
  	for(i = ES325_POWER_STATE + 1; i < (size + ES325_POWER_STATE -1); i++)
@@@ -2276,8 -2249,7 +2303,12 @@@ static int es325_wakeup(struct es325_pr
  		gpio_set_value(5, 1);
  		usleep_range(10000, 10000);
  	}
++<<<<<<< HEAD
 +#elif (defined(CONFIG_MACH_HLTESKT) || defined(CONFIG_MACH_HLTEKTT) || defined(CONFIG_MACH_FRESCOLTESKT) || defined(CONFIG_MACH_FRESCOLTEKTT)) \
 +&& defined(CONFIG_ES325_UART_WORKAROUND_ENG_ONLY)
++=======
+ #elif (defined(CONFIG_MACH_HLTESKT) || defined(CONFIG_MACH_HLTEKTT)) && defined(CONFIG_ES325_UART_WORKAROUND_ENG_ONLY)
++>>>>>>> FETCH_HEAD
  	if (system_rev == 5) {
  		pr_info("%s : [ES325] ES325_UART_WORKAROUND system rev = %d\n", __func__, system_rev);
  		gpio_tlmm_config(GPIO_CFG(4, 0, GPIO_CFG_INPUT,
@@@ -3881,7 -3853,7 +3912,11 @@@ EXPORT_SYMBOL_GPL(es325_wrapper_wakeup)
  	es325_BWE_enable = ES325_MAX_INVALID_BWE;
  	es325_Tx_NS = ES325_MAX_INVALID_TX_NS;
  
++<<<<<<< HEAD
 +#if !(defined(CONFIG_SEC_LOCALE_KOR) || defined(CONFIG_SEC_HLTE_HKTW))
++=======
+ #if !defined(CONFIG_SEC_LOCALE_KOR)
++>>>>>>> FETCH_HEAD
  	es325->new_internal_route_config = ES325_INTERNAL_ROUTE_MAX;
  #endif
  
diff --cc sound/soc/codecs/msm8x10-wcd.c
index f5925c8,26fbb5e..0000000
--- a/sound/soc/codecs/msm8x10-wcd.c
+++ b/sound/soc/codecs/msm8x10-wcd.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -50,6 -50,8 +54,11 @@@
  #define BITS_PER_REG		8
  #define MSM8X10_WCD_TX_PORT_NUMBER	4
  
++<<<<<<< HEAD
++=======
+ #define DAPM_MICBIAS_EXTERNAL_STANDALONE "MIC BIAS External Standalone"
+ 
++>>>>>>> FETCH_HEAD
  #define MSM8X10_WCD_I2S_MASTER_MODE_MASK	0x08
  #define MSM8X10_DINO_CODEC_BASE_ADDR		0xFE043000
  #define MSM8X10_DINO_CODEC_REG_SIZE		0x200
@@@ -165,6 -167,10 +174,13 @@@ static char on_demand_supply_name[][MAX
  	"cdc-vdda-cp",
  };
  
++<<<<<<< HEAD
++=======
+ static int on_demand_regulator_control(struct on_demand_supply *supply,
+ 				       bool enable,
+ 				       u8 shift);
+ 
++>>>>>>> FETCH_HEAD
  struct msm8x10_wcd_priv {
  	struct snd_soc_codec *codec;
  	u32 adc_count;
@@@ -176,7 -182,6 +192,10 @@@
  	/* mbhc module */
  	struct wcd9xxx_mbhc mbhc;
  
++<<<<<<< HEAD
 +	struct delayed_work hs_detect_work;
++=======
++>>>>>>> FETCH_HEAD
  	struct wcd9xxx_mbhc_config *mbhc_cfg;
  
  	/*
@@@ -296,7 -301,6 +315,10 @@@ static int msm8x10_wcd_i2c_write_device
  			return ret;
  		}
  	}
++<<<<<<< HEAD
 +	pr_debug("write sucess register = %x val = %x\n", reg, data[1]);
++=======
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -345,7 -349,6 +367,10 @@@ int msm8x10_wcd_i2c_read_device(u32 reg
  			}
  		}
  	}
++<<<<<<< HEAD
 +	pr_debug("%s: reg 0x%x = 0x%x\n", __func__, reg, *dest);
++=======
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -395,6 -398,32 +420,35 @@@ static int __msm8x10_wcd_reg_read(struc
  	return temp;
  }
  
++<<<<<<< HEAD
++=======
+ static int __msm8x10_wcd_bulk_write(struct msm8x10_wcd *msm8x10_wcd,
+ 		unsigned short reg, int count, u8 *buf)
+ {
+ 	int ret = -EINVAL;
+ 	mutex_lock(&msm8x10_wcd->io_lock);
+ 	if (MSM8X10_WCD_IS_HELICON_REG(reg))
+ 		ret = msm8x10_wcd_i2c_write(reg, count, buf);
+ 	else if (MSM8X10_WCD_IS_DINO_REG(reg))
+ 		ret = msm8x10_wcd_abh_write_device(msm8x10_wcd, reg,
+ 						buf, count);
+ 	if (ret < 0)
+ 		dev_err(msm8x10_wcd->dev,
+ 				"%s: codec bulk write failed\n", __func__);
+ 	mutex_unlock(&msm8x10_wcd->io_lock);
+ 	return ret;
+ }
+ 
+ int msm8x10_wcd_bulk_write(struct wcd9xxx_core_resource *core_res,
+ 			unsigned short reg, int count, u8 *buf)
+ {
+ 	struct msm8x10_wcd *msm8x10_wcd =
+ 				(struct msm8x10_wcd *) core_res->parent;
+ 	return __msm8x10_wcd_bulk_write(msm8x10_wcd, reg, count, buf);
+ }
+ EXPORT_SYMBOL(msm8x10_wcd_bulk_write);
+ 
++>>>>>>> FETCH_HEAD
  int msm8x10_wcd_reg_read(struct wcd9xxx_core_resource *core_res,
  				unsigned short reg)
  {
@@@ -451,8 -480,8 +505,13 @@@ static int __msm8x10_wcd_reg_write(stru
  				__func__, reg);
  	else
  		dev_dbg(msm8x10_wcd->dev,
++<<<<<<< HEAD
 +			"%s: Write %x to R%d(0x%x)\n",
 +			__func__, val, reg, reg);
++=======
+ 			"%s: Write 0x%x to 0x%x\n",
+ 			__func__, val, reg);
++>>>>>>> FETCH_HEAD
  
  	return ret;
  }
@@@ -488,8 -517,6 +547,11 @@@ static int msm8x10_wcd_volatile(struct 
  	 * Registers lower than 0x100 are top level registers which can be
  	 * written by the Taiko core driver.
  	 */
++<<<<<<< HEAD
 +	dev_dbg(codec->dev, "%s: reg 0x%x\n", __func__, reg);
 +
++=======
++>>>>>>> FETCH_HEAD
  	if ((reg >= MSM8X10_WCD_A_CDC_MBHC_EN_CTL) || (reg < 0x100))
  		return 1;
  
@@@ -525,7 -552,7 +587,11 @@@ static int msm8x10_wcd_write(struct snd
  			     unsigned int value)
  {
  	int ret;
++<<<<<<< HEAD
 +	dev_dbg(codec->dev, "%s: Write from reg 0x%x\n", __func__, reg);
++=======
+ 	dev_dbg(codec->dev, "%s: Write to reg 0x%x\n", __func__, reg);
++>>>>>>> FETCH_HEAD
  	if (reg == SND_SOC_NOPM)
  		return 0;
  
@@@ -756,6 -783,39 +822,42 @@@ err
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static int on_demand_regulator_control(struct on_demand_supply *supply,
+ 				       bool enable,
+ 				       u8 shift)
+ {
+ 	int ret = 0;
+ 
+ 	if (!supply || !supply->supply)
+ 		return 0;
+ 
+ 	if (enable) {
+ 		if (atomic_inc_return(&supply->ref) == 1)
+ 			ret = regulator_enable(supply->supply);
+ 		if (ret)
+ 			pr_err("%s: Failed to enable %s\n",
+ 					__func__,
+ 					on_demand_supply_name[shift]);
+ 	} else {
+ 		if (atomic_read(&supply->ref) == 0) {
+ 			pr_debug("%s: %s supply has been disabled.\n",
+ 					__func__, on_demand_supply_name[shift]);
+ 			return 0;
+ 		}
+ 		if (atomic_dec_return(&supply->ref) == 0)
+ 			ret = regulator_disable(supply->supply);
+ 		if (ret)
+ 			pr_err("%s: Failed to disable %s\n",
+ 					__func__,
+ 					on_demand_supply_name[shift]);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm8x10_wcd_codec_enable_on_demand_supply(
  		struct snd_soc_dapm_widget *w,
  		struct snd_kcontrol *kcontrol, int event)
@@@ -781,25 -841,14 +883,36 @@@
  
  	switch (event) {
  	case SND_SOC_DAPM_PRE_PMU:
++<<<<<<< HEAD
 +		if (atomic_inc_return(&supply->ref) == 1)
 +			ret = regulator_enable(supply->supply);
 +		if (ret)
 +			dev_err(codec->dev, "%s: Failed to enable %s\n",
 +				__func__,
 +				on_demand_supply_name[w->shift]);
 +		break;
 +	case SND_SOC_DAPM_POST_PMD:
 +		if (atomic_read(&supply->ref) == 0) {
 +			dev_dbg(codec->dev, "%s: %s supply has been disabled.\n",
 +				 __func__, on_demand_supply_name[w->shift]);
 +			goto out;
 +		}
 +		if (atomic_dec_return(&supply->ref) == 0)
 +			ret = regulator_disable(supply->supply);
 +			if (ret)
 +				dev_err(codec->dev, "%s: Failed to disable %s\n",
 +					__func__,
 +					on_demand_supply_name[w->shift]);
++=======
+ 		ret = on_demand_regulator_control(supply,
+ 						  true,
+ 						  w->shift);
+ 		break;
+ 	case SND_SOC_DAPM_POST_PMD:
+ 		ret = on_demand_regulator_control(supply,
+ 						  false,
+ 						  w->shift);
++>>>>>>> FETCH_HEAD
  		break;
  	default:
  		break;
@@@ -1271,6 -1320,10 +1384,13 @@@ static const char * const rx_rdac4_text
  	"ZERO", "RX3", "RX2"
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const rx_rdac3_text[] = {
+ 	"RX1", "RX2"
+ };
+ 
++>>>>>>> FETCH_HEAD
  static const struct soc_enum rx_mix1_inp1_chain_enum =
  	SOC_ENUM_SINGLE(MSM8X10_WCD_A_CDC_CONN_RX1_B1_CTL, 0, 6, rx_mix1_text);
  
@@@ -1312,6 -1365,10 +1432,13 @@@ static const struct soc_enum rx_rdac4_e
  	SOC_ENUM_SINGLE(MSM8X10_WCD_A_CDC_CONN_LO_DAC_CTL, 0, 3,
  	rx_rdac4_text);
  
++<<<<<<< HEAD
++=======
+ static const struct soc_enum rx_rdac3_enum  =
+ 	SOC_ENUM_SINGLE(MSM8X10_WCD_A_CDC_CONN_HPHR_DAC_CTL, 0, 2,
+ 	rx_rdac3_text);
+ 
++>>>>>>> FETCH_HEAD
  static const struct soc_enum adc2_enum =
  	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(adc2_mux_text), adc2_mux_text);
  
@@@ -1345,6 -1402,9 +1472,12 @@@ static const struct snd_kcontrol_new rx
  static const struct snd_kcontrol_new rx_dac4_mux =
  	SOC_DAPM_ENUM("RDAC4 MUX Mux", rx_rdac4_enum);
  
++<<<<<<< HEAD
++=======
+ static const struct snd_kcontrol_new rx_dac3_mux =
+ 	SOC_DAPM_ENUM("RDAC3 MUX Mux", rx_rdac3_enum);
+ 
++>>>>>>> FETCH_HEAD
  static const struct snd_kcontrol_new tx_adc2_mux =
  	SOC_DAPM_ENUM("ADC2 MUX Mux", adc2_enum);
  
@@@ -1396,7 -1456,10 +1529,14 @@@ static int msm8x10_wcd_put_dec_enum(str
  	switch (decimator) {
  	case 1:
  	case 2:
++<<<<<<< HEAD
 +			adc_dmic_sel = 0x0;
++=======
+ 			if ((dec_mux == 3) || (dec_mux == 4))
+ 				adc_dmic_sel = 0x1;
+ 			else
+ 				adc_dmic_sel = 0x0;
++>>>>>>> FETCH_HEAD
  		break;
  	default:
  		dev_err(codec->dev, "%s: Invalid Decimator = %u\n",
@@@ -1632,6 -1695,8 +1772,11 @@@ static int msm8x10_wcd_codec_enable_mic
  
  		/* Always pull up TxFe for TX2 to Micbias */
  		snd_soc_update_bits(codec, micb_int_reg, 0x04, 0x04);
++<<<<<<< HEAD
++=======
+ 		snd_soc_update_bits(codec, MSM8X10_WCD_A_MICB_1_CTL,
+ 					0x80, 0x80);
++>>>>>>> FETCH_HEAD
  		break;
  	case SND_SOC_DAPM_POST_PMU:
  		usleep_range(20000, 20100);
@@@ -1639,6 -1704,8 +1784,11 @@@
  		wcd9xxx_resmgr_notifier_call(&msm8x10_wcd->resmgr, e_post_on);
  		break;
  	case SND_SOC_DAPM_POST_PMD:
++<<<<<<< HEAD
++=======
+ 		snd_soc_update_bits(codec, MSM8X10_WCD_A_MICB_1_CTL,
+ 					0x80, 0x00);
++>>>>>>> FETCH_HEAD
  		/* Let MBHC module know so micbias switch to be off */
  		wcd9xxx_resmgr_notifier_call(&msm8x10_wcd->resmgr, e_post_off);
  
@@@ -1969,7 -2036,10 +2119,14 @@@ static const struct snd_soc_dapm_route 
  
  	{"DAC1", "Switch", "RX1 CHAIN"},
  	{"HPHL DAC", "Switch", "RX1 CHAIN"},
++<<<<<<< HEAD
 +	{"HPHR DAC", NULL, "RX2 CHAIN"},
++=======
+ 	{"HPHR DAC", NULL, "RDAC3 MUX"},
+ 
+ 	{"RDAC3 MUX", "RX1", "RX1 CHAIN"},
+ 	{"RDAC3 MUX", "RX2", "RX2 CHAIN"},
++>>>>>>> FETCH_HEAD
  
  	{"LINEOUT", NULL, "LINEOUT PA"},
  	{"SPK_OUT", NULL, "SPK PA"},
@@@ -2297,7 -2367,8 +2454,12 @@@ static const struct snd_soc_dapm_widge
  	SND_SOC_DAPM_OUTPUT("EAR"),
  
  	SND_SOC_DAPM_PGA_E("EAR PA", MSM8X10_WCD_A_RX_EAR_EN, 4, 0, NULL, 0,
++<<<<<<< HEAD
 +			msm8x10_wcd_codec_enable_ear_pa, SND_SOC_DAPM_POST_PMU),
++=======
+ 			msm8x10_wcd_codec_enable_ear_pa,
+ 			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
++>>>>>>> FETCH_HEAD
  
  	SND_SOC_DAPM_MIXER("DAC1", MSM8X10_WCD_A_RX_EAR_EN, 6, 0, dac1_switch,
  		ARRAY_SIZE(dac1_switch)),
@@@ -2411,6 -2482,8 +2573,11 @@@
  		&rx2_mix2_inp1_mux),
  	SND_SOC_DAPM_MUX("RDAC4 MUX", SND_SOC_NOPM, 0, 0,
  		&rx_dac4_mux),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_MUX("RDAC3 MUX", SND_SOC_NOPM, 0, 0,
+ 		&rx_dac3_mux),
++>>>>>>> FETCH_HEAD
  
  	SND_SOC_DAPM_SUPPLY("MICBIAS_REGULATOR", SND_SOC_NOPM,
  		ON_DEMAND_MICBIAS, 0,
@@@ -2462,6 -2535,11 +2629,14 @@@
  		MSM8X10_WCD_A_MICB_1_CTL, 7, 0,
  		msm8x10_wcd_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
  		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_MICBIAS_E(DAPM_MICBIAS_EXTERNAL_STANDALONE,
+ 		MSM8X10_WCD_A_MICB_1_CTL,
+ 		7, 0, msm8x10_wcd_codec_enable_micbias,
+ 		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+ 		SND_SOC_DAPM_POST_PMD),
++>>>>>>> FETCH_HEAD
  
  	SND_SOC_DAPM_ADC_E("ADC1", NULL, MSM8X10_WCD_A_TX_1_EN, 7, 0,
  		msm8x10_wcd_codec_enable_adc, SND_SOC_DAPM_PRE_PMU |
@@@ -2557,9 -2635,8 +2732,14 @@@ static const struct msm8x10_wcd_reg_mas
  	/* Enable pulldown to reduce leakage */
  #if defined(CONFIG_MACH_CS02VE)||defined(CONFIG_MACH_KYLEVE2_CTC) || defined(CONFIG_SEC_HEAT_PROJECT)
  	MSM8X10_WCD_REG_VAL(MSM8X10_WCD_A_MICB_1_CTL, 0x92),
++<<<<<<< HEAD
 +#else
 +	MSM8X10_WCD_REG_VAL(MSM8X10_WCD_A_MICB_1_CTL, 0x82),
 +#endif
++=======
+ #endif
+ 
++>>>>>>> FETCH_HEAD
  	MSM8X10_WCD_REG_VAL(MSM8X10_WCD_A_TX_COM_BIAS, 0xE0),
  	/* Keep the same default gain settings for TX paths */
  	MSM8X10_WCD_REG_VAL(MSM8X10_WCD_A_TX_1_EN, 0x32),
@@@ -2702,18 -2779,33 +2882,48 @@@ static void msm8x10_wcd_mbhc_txfe(struc
  }
  
  static int msm8x10_wcd_enable_ext_mb_source(struct snd_soc_codec *codec,
++<<<<<<< HEAD
 +	bool turn_on)
 +{
 +	int ret = 0;
 +
 +	if (turn_on)
 +		ret = snd_soc_dapm_force_enable_pin(&codec->dapm,
 +				"MICBIAS_REGULATOR");
 +	else
 +		ret = snd_soc_dapm_disable_pin(&codec->dapm,
 +				"MICBIAS_REGULATOR");
 +
 +	snd_soc_dapm_sync(&codec->dapm);
++=======
+ 					    bool turn_on,
+ 					    bool use_dapm)
+ {
+ 	int ret = 0;
+ 
+ 	if (use_dapm) {
+ 		if (turn_on)
+ 			ret = snd_soc_dapm_force_enable_pin(&codec->dapm,
+ 					"MICBIAS_REGULATOR");
+ 		else
+ 			ret = snd_soc_dapm_disable_pin(&codec->dapm,
+ 					"MICBIAS_REGULATOR");
+ 
+ 		snd_soc_dapm_sync(&codec->dapm);
+ 	} else {
+ 		struct on_demand_supply *supply;
+ 		struct msm8x10_wcd_priv *msm8x10_wcd =
+ 				snd_soc_codec_get_drvdata(codec);
+ 
+ 		supply = &msm8x10_wcd->on_demand_list[ON_DEMAND_MICBIAS];
+ 		if (!supply || !supply->supply || !msm8x10_wcd)
+ 			return 0;
+ 
+ 		ret = on_demand_regulator_control(supply,
+ 						  turn_on,
+ 						  ON_DEMAND_MICBIAS);
+ 	}
++>>>>>>> FETCH_HEAD
  
  	if (ret)
  		dev_err(codec->dev, "%s: Failed to %s external micbias source\n",
@@@ -2725,6 -2817,37 +2935,40 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm8x10_wcd_enable_mbhc_micbias(struct snd_soc_codec *codec,
+ 					   bool enable,
+ 					   enum wcd9xxx_micbias_num micb_num)
+ {
+ 	int rc;
+ 
+ 	if (micb_num != MBHC_MICBIAS1) {
+ 		rc = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	if (enable)
+ 		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
+ 			DAPM_MICBIAS_EXTERNAL_STANDALONE);
+ 	else
+ 		rc = snd_soc_dapm_disable_pin(&codec->dapm,
+ 			DAPM_MICBIAS_EXTERNAL_STANDALONE);
+ 	snd_soc_dapm_sync(&codec->dapm);
+ 
+ 	snd_soc_update_bits(codec, WCD9XXX_A_MICB_1_CTL,
+ 		0x80, enable ? 0x80 : 0x00);
+ err:
+ 	if (rc)
+ 		pr_debug("%s: Failed to force %s micbias", __func__,
+ 			enable ? "enable" : "disable");
+ 	else
+ 		pr_debug("%s: Trying force %s micbias", __func__,
+ 			enable ? "enable" : "disable");
+ 	return rc;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static void msm8x10_wcd_micb_internal(struct snd_soc_codec *codec, bool on)
  {
  	snd_soc_update_bits(codec, MSM8X10_WCD_A_MICB_1_INT_RBIAS,
@@@ -2975,35 -3098,22 +3219,50 @@@ static const struct wcd9xxx_mbhc_cb mbh
  	.compute_impedance = msm8x10_wcd_compute_impedance,
  };
  
++<<<<<<< HEAD
 +static void delayed_hs_detect_fn(struct work_struct *work)
 +{
 +	struct delayed_work *delayed_work;
 +	struct msm8x10_wcd_priv *wcd_priv;
 +
 +	delayed_work = to_delayed_work(work);
 +	wcd_priv = container_of(delayed_work, struct msm8x10_wcd_priv,
 +				hs_detect_work);
 +
 +	if (!wcd_priv) {
 +		pr_err("%s: Invalid private data for codec\n", __func__);
 +		return;
 +	}
 +
 +	wcd9xxx_mbhc_start(&wcd_priv->mbhc, wcd_priv->mbhc_cfg);
 +}
 +
 +
++=======
++>>>>>>> FETCH_HEAD
  int msm8x10_wcd_hs_detect(struct snd_soc_codec *codec,
  		    struct wcd9xxx_mbhc_config *mbhc_cfg)
  {
      #ifndef CONFIG_SAMSUNG_JACK
  	struct msm8x10_wcd_priv *wcd = snd_soc_codec_get_drvdata(codec);
  
++<<<<<<< HEAD
++=======
+ 	if (!wcd) {
+ 		dev_err(codec->dev, "%s: Invalid private data for codec\n",
+ 			__func__);
+ 		return -EINVAL;
+ 	}
++>>>>>>> FETCH_HEAD
  	wcd->mbhc_cfg = mbhc_cfg;
  	schedule_delayed_work(&wcd->hs_detect_work,
  			msecs_to_jiffies(5000));
  	#endif
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	return wcd9xxx_mbhc_start(&wcd->mbhc, wcd->mbhc_cfg);
++>>>>>>> FETCH_HEAD
  }
  EXPORT_SYMBOL_GPL(msm8x10_wcd_hs_detect);
  
@@@ -3170,8 -3280,6 +3429,11 @@@ static int msm8x10_wcd_codec_probe(stru
  	msm8x10_wcd = codec->control_data;
  	msm8x10_wcd->pdino_base = ioremap(MSM8X10_DINO_CODEC_BASE_ADDR,
  					  MSM8X10_DINO_CODEC_REG_SIZE);
++<<<<<<< HEAD
 +	INIT_DELAYED_WORK(&msm8x10_wcd_priv->hs_detect_work,
 +			delayed_hs_detect_fn);
++=======
++>>>>>>> FETCH_HEAD
  
  	pdata = dev_get_platdata(msm8x10_wcd->dev);
  	if (!pdata) {
@@@ -3210,7 -3318,8 +3472,12 @@@
      #ifndef CONFIG_SAMSUNG_JACK
  	ret = wcd9xxx_mbhc_init(&msm8x10_wcd_priv->mbhc,
  				&msm8x10_wcd_priv->resmgr,
++<<<<<<< HEAD
 +				codec, NULL, &mbhc_cb, &cdc_intr_ids,
++=======
+ 				codec, msm8x10_wcd_enable_mbhc_micbias,
+ 				&mbhc_cb, &cdc_intr_ids,
++>>>>>>> FETCH_HEAD
  				HELICON_MCLK_CLK_9P6MHZ, true);
  	if (ret) {
  		dev_err(msm8x10_wcd->dev, "%s: Failed to initialize mbhc\n",
@@@ -3585,7 -3694,8 +3852,12 @@@ static int __devinit msm8x10_wcd_i2c_pr
  					MSM8X10_WCD_NUM_IRQ_REGS,
  					msm8x10_wcd_reg_read,
  					msm8x10_wcd_reg_write,
++<<<<<<< HEAD
 +					msm8x10_wcd_bulk_read);
++=======
+ 					msm8x10_wcd_bulk_read,
+ 					msm8x10_wcd_bulk_write);
++>>>>>>> FETCH_HEAD
  	if (wcd9xxx_core_irq_init(core_res)) {
  		dev_err(msm8x10->dev,
  				"%s: irq initialization failed\n", __func__);
diff --cc sound/soc/codecs/msm_hdmi_codec_rx.c
index 396d3a6,9cf37b4..0000000
--- a/sound/soc/codecs/msm_hdmi_codec_rx.c
+++ b/sound/soc/codecs/msm_hdmi_codec_rx.c
@@@ -37,8 -37,8 +37,13 @@@ static int msm_hdmi_edid_ctl_info(struc
  	codec_data = snd_soc_codec_get_drvdata(codec);
  	rc = codec_data->hdmi_ops.get_audio_edid_blk(codec_data->hdmi_core_pdev,
  						     &edid_blk);
++<<<<<<< HEAD
 +	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
 +	if (!IS_ERR_VALUE(rc)) {
++=======
+ 	if (!IS_ERR_VALUE(rc)) {
+ 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
++>>>>>>> FETCH_HEAD
  		uinfo->count = edid_blk.audio_data_blk_size +
  			       edid_blk.spk_alloc_data_blk_size;
  	}
@@@ -54,8 -54,8 +59,13 @@@ static int msm_hdmi_edid_get(struct snd
  	int rc;
  
  	codec_data = snd_soc_codec_get_drvdata(codec);
++<<<<<<< HEAD
 +	rc = codec_data->hdmi_ops.get_audio_edid_blk(codec_data->hdmi_core_pdev,
 +						     &edid_blk);
++=======
+ 	rc = codec_data->hdmi_ops.get_audio_edid_blk(
+ 			codec_data->hdmi_core_pdev, &edid_blk);
++>>>>>>> FETCH_HEAD
  
  	if (!IS_ERR_VALUE(rc)) {
  		memcpy(ucontrol->value.bytes.data, edid_blk.audio_data_blk,
@@@ -80,6 -80,24 +90,27 @@@ static const struct snd_kcontrol_new ms
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static int msm_hdmi_audio_codec_rx_dai_startup(
+ 		struct snd_pcm_substream *substream,
+ 		struct snd_soc_dai *dai)
+ {
+ 	int rv;
+ 	struct msm_hdmi_audio_codec_rx_data *codec_data =
+ 			dev_get_drvdata(dai->codec->dev);
+ 
+ 	rv = codec_data->hdmi_ops.hdmi_cable_status(
+ 		codec_data->hdmi_core_pdev, 1);
+ 	if (IS_ERR_VALUE(rv)) {
+ 		dev_err(dai->dev,
+ 			"%s() HDMI core is not ready\n", __func__);
+ 	}
+ 
+ 	return rv;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_hdmi_audio_codec_rx_dai_hw_params(
  		struct snd_pcm_substream *substream,
  		struct snd_pcm_hw_params *params,
@@@ -89,11 -107,19 +120,26 @@@
  	u32 level_shift  = 0; /* 0dB */
  	bool down_mix = 0;
  	u32 num_channels = params_channels(params);
++<<<<<<< HEAD
++=======
+ 	int rv = 0;
++>>>>>>> FETCH_HEAD
  
  	struct msm_hdmi_audio_codec_rx_data *codec_data =
  			dev_get_drvdata(dai->codec->dev);
  
++<<<<<<< HEAD
 +	/*refer to HDMI spec CEA-861-E: Table 28 Audio InfoFrame Data Byte 4*/
++=======
+ 	rv = codec_data->hdmi_ops.hdmi_cable_status(
+ 		codec_data->hdmi_core_pdev, 1);
+ 	if (IS_ERR_VALUE(rv)) {
+ 		dev_err(dai->dev,
+ 			"%s() HDMI core is not ready\n", __func__);
+ 		return rv;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	switch (num_channels) {
  	case 2:
  		channel_allocation  = 0;
@@@ -121,19 -147,47 +167,63 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	dev_dbg(dai->dev, "%s() num_ch %u  samplerate %u channel_allocation = %u\n",
 +		__func__, num_channels, params_rate(params),
 +		channel_allocation);
 +
 +	codec_data->hdmi_ops.audio_info_setup(codec_data->hdmi_core_pdev,
 +			params_rate(params), num_channels, channel_allocation,
 +			level_shift, down_mix);
 +
 +	return 0;
 +}
 +
 +static struct snd_soc_dai_ops msm_hdmi_audio_codec_rx_dai_ops = {
 +	.hw_params	= msm_hdmi_audio_codec_rx_dai_hw_params,
++=======
+ 	dev_dbg(dai->dev,
+ 		"%s() num_ch %u  samplerate %u channel_allocation = %u\n",
+ 		__func__, num_channels, params_rate(params),
+ 		channel_allocation);
+ 
+ 	rv = codec_data->hdmi_ops.audio_info_setup(
+ 			codec_data->hdmi_core_pdev,
+ 			params_rate(params), num_channels,
+ 			channel_allocation, level_shift, down_mix);
+ 	if (IS_ERR_VALUE(rv)) {
+ 		dev_err(dai->dev,
+ 			"%s() HDMI core is not ready\n", __func__);
+ 	}
+ 
+ 	return rv;
+ }
+ 
+ static void msm_hdmi_audio_codec_rx_dai_shutdown(
+ 		struct snd_pcm_substream *substream,
+ 		struct snd_soc_dai *dai)
+ {
+ 	int rc;
+ 
+ 	struct msm_hdmi_audio_codec_rx_data *codec_data =
+ 			dev_get_drvdata(dai->codec->dev);
+ 
+ 	rc = codec_data->hdmi_ops.hdmi_cable_status(
+ 			codec_data->hdmi_core_pdev, 0);
+ 	if (IS_ERR_VALUE(rc)) {
+ 		dev_err(dai->dev,
+ 			"%s() HDMI core had problems releasing HDMI audio flag\n",
+ 			__func__);
+ 	}
+ 
+ 	return;
+ }
+ 
+ static struct snd_soc_dai_ops msm_hdmi_audio_codec_rx_dai_ops = {
+ 	.startup	= msm_hdmi_audio_codec_rx_dai_startup,
+ 	.hw_params	= msm_hdmi_audio_codec_rx_dai_hw_params,
+ 	.shutdown	= msm_hdmi_audio_codec_rx_dai_shutdown
++>>>>>>> FETCH_HEAD
  };
  
  static int msm_hdmi_audio_codec_rx_probe(struct snd_soc_codec *codec)
diff --cc sound/soc/codecs/wcd9306.c
index d01487b,dd0eed1..0000000
--- a/sound/soc/codecs/wcd9306.c
+++ b/sound/soc/codecs/wcd9306.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -509,8 -509,8 +513,13 @@@ static int tapan_put_anc_func(struct sn
  		snd_soc_dapm_enable_pin(dapm, "EAR PA");
  		snd_soc_dapm_enable_pin(dapm, "EAR");
  	}
++<<<<<<< HEAD
 +	snd_soc_dapm_sync(dapm);
 +	mutex_unlock(&dapm->codec->mutex);
++=======
+ 	mutex_unlock(&dapm->codec->mutex);
+ 	snd_soc_dapm_sync(dapm);
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -518,31 -518,41 +527,65 @@@ static int tapan_pa_gain_get(struct snd
  				struct snd_ctl_elem_value *ucontrol)
  {
  	u8 ear_pa_gain;
++<<<<<<< HEAD
 +	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 +
 +	ear_pa_gain = snd_soc_read(codec, TAPAN_A_RX_EAR_GAIN);
 +
 +	ear_pa_gain = ear_pa_gain >> 5;
 +
 +	if (ear_pa_gain == 0x00) {
 +		ucontrol->value.integer.value[0] = 0;
 +	} else if (ear_pa_gain == 0x04) {
 +		ucontrol->value.integer.value[0] = 1;
 +	} else  {
 +		pr_err("%s: ERROR: Unsupported Ear Gain = 0x%x\n",
 +				__func__, ear_pa_gain);
 +		return -EINVAL;
++=======
+ 	int rc = 0;
+ 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+ 
+ 	ear_pa_gain = snd_soc_read(codec, TAPAN_A_RX_EAR_GAIN);
+ 	ear_pa_gain = ear_pa_gain >> 5;
+ 
+ 	switch (ear_pa_gain) {
+ 	case 0:
+ 	case 1:
+ 	case 2:
+ 	case 3:
+ 	case 4:
+ 	case 5:
+ 		ucontrol->value.integer.value[0] = ear_pa_gain;
+ 		break;
+ 	case 7:
+ 		ucontrol->value.integer.value[0] = (ear_pa_gain - 1);
+ 		break;
+ 	default:
+ 		rc = -EINVAL;
+ 		pr_err("%s: ERROR: Unsupported Ear Gain = 0x%x\n",
+ 		       __func__, ear_pa_gain);
+ 		break;
++>>>>>>> FETCH_HEAD
  	}
  
  	dev_dbg(codec->dev, "%s: ear_pa_gain = 0x%x\n", __func__, ear_pa_gain);
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	return rc;
++>>>>>>> FETCH_HEAD
  }
  
  static int tapan_pa_gain_put(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_value *ucontrol)
  {
  	u8 ear_pa_gain;
++<<<<<<< HEAD
++=======
+ 	int rc = 0;
++>>>>>>> FETCH_HEAD
  	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
  
  	dev_dbg(codec->dev, "%s: ucontrol->value.integer.value[0]  = %ld\n",
@@@ -550,17 -560,24 +593,38 @@@
  
  	switch (ucontrol->value.integer.value[0]) {
  	case 0:
++<<<<<<< HEAD
 +		ear_pa_gain = 0x00;
 +		break;
 +	case 1:
 +		ear_pa_gain = 0x80;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	snd_soc_update_bits(codec, TAPAN_A_RX_EAR_GAIN, 0xE0, ear_pa_gain);
 +	return 0;
++=======
+ 	case 1:
+ 	case 2:
+ 	case 3:
+ 	case 4:
+ 	case 5:
+ 		ear_pa_gain = ucontrol->value.integer.value[0];
+ 		break;
+ 	case 6:
+ 		ear_pa_gain = 0x07;
+ 		break;
+ 	default:
+ 		rc = -EINVAL;
+ 		break;
+ 	}
+ 	if (!rc)
+ 		snd_soc_update_bits(codec, TAPAN_A_RX_EAR_GAIN,
+ 				    0xE0, ear_pa_gain << 5);
+ 	return rc;
++>>>>>>> FETCH_HEAD
  }
  
  static int tapan_get_iir_enable_audio_mixer(
@@@ -1021,9 -1038,13 +1085,19 @@@ static int tapan_config_compander(struc
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const char * const tapan_ear_pa_gain_text[] = {"POS_6_DB", "POS_2_DB"};
 +static const struct soc_enum tapan_ear_pa_gain_enum[] = {
 +		SOC_ENUM_SINGLE_EXT(2, tapan_ear_pa_gain_text),
++=======
+ static const char * const tapan_ear_pa_gain_text[] = {"POS_6_DB", "POS_4P5_DB",
+ 						      "POS_3_DB", "POS_1P5_DB",
+ 						      "POS_0_DB", "NEG_2P5_DB",
+ 						      "NEG_12_DB"};
+ static const struct soc_enum tapan_ear_pa_gain_enum[] = {
+ 		SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(tapan_ear_pa_gain_text),
+ 				    tapan_ear_pa_gain_text),
++>>>>>>> FETCH_HEAD
  };
  
  static const char *const tapan_anc_func_text[] = {"OFF", "ON"};
@@@ -1084,7 -1105,7 +1158,11 @@@ static const struct snd_kcontrol_new ta
  	SOC_SINGLE_TLV("LINEOUT2 Volume", TAPAN_A_RX_LINE_2_GAIN, 0, 14, 1,
  		line_gain),
  
++<<<<<<< HEAD
 +	SOC_SINGLE_TLV("SPK DRV Volume", TAPAN_A_SPKR_DRV_GAIN, 3, 7, 1,
++=======
+ 	SOC_SINGLE_TLV("SPK DRV Volume", TAPAN_A_SPKR_DRV_GAIN, 3, 8, 1,
++>>>>>>> FETCH_HEAD
  		line_gain),
  
  	SOC_SINGLE_TLV("ADC1 Volume", TAPAN_A_TX_1_EN, 2, 19, 0, analog_gain),
@@@ -1307,6 -1328,9 +1385,12 @@@ static const struct soc_enum rx4_mix1_i
  static const struct soc_enum rx4_mix1_inp2_chain_enum =
  	SOC_ENUM_SINGLE(TAPAN_A_CDC_CONN_RX4_B1_CTL, 4, 13, rx_3_4_mix1_text);
  
++<<<<<<< HEAD
++=======
+ static const struct soc_enum rx4_mix1_inp3_chain_enum =
+ 	SOC_ENUM_SINGLE(TAPAN_A_CDC_CONN_RX4_B2_CTL, 0, 13, rx_3_4_mix1_text);
+ 
++>>>>>>> FETCH_HEAD
  static const struct soc_enum rx1_mix2_inp1_chain_enum =
  	SOC_ENUM_SINGLE(TAPAN_A_CDC_CONN_RX1_B3_CTL, 0, 5, rx_mix2_text);
  
@@@ -1402,6 -1426,9 +1486,12 @@@ static const struct snd_kcontrol_new rx
  static const struct snd_kcontrol_new rx4_mix1_inp2_mux =
  	SOC_DAPM_ENUM("RX4 MIX1 INP2 Mux", rx4_mix1_inp2_chain_enum);
  
++<<<<<<< HEAD
++=======
+ static const struct snd_kcontrol_new rx4_mix1_inp3_mux =
+ 	SOC_DAPM_ENUM("RX4 MIX1 INP3 Mux", rx4_mix1_inp3_chain_enum);
+ 
++>>>>>>> FETCH_HEAD
  static const struct snd_kcontrol_new rx1_mix2_inp1_mux =
  	SOC_DAPM_ENUM("RX1 MIX2 INP1 Mux", rx1_mix2_inp1_chain_enum);
  
@@@ -1841,9 -1868,10 +1931,16 @@@ static int tapan_codec_enable_adc(struc
  
  	switch (event) {
  	case SND_SOC_DAPM_PRE_PMU:
++<<<<<<< HEAD
 +		if (w->reg == TAPAN_A_TX_3_EN)
 +			wcd9xxx_resmgr_notifier_call(&tapan->resmgr,
 +						WCD9XXX_EVENT_PRE_TX_3_ON);
++=======
+ 		if (w->reg == TAPAN_A_TX_3_EN ||
+ 		    w->reg == TAPAN_A_TX_1_EN)
+ 			wcd9xxx_resmgr_notifier_call(&tapan->resmgr,
+ 						WCD9XXX_EVENT_PRE_TX_1_3_ON);
++>>>>>>> FETCH_HEAD
  		snd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift,
  				1 << init_bit_shift);
  		break;
@@@ -1853,9 -1881,10 +1950,16 @@@
  
  		break;
  	case SND_SOC_DAPM_POST_PMD:
++<<<<<<< HEAD
 +		if (w->reg == TAPAN_A_TX_3_EN)
 +			wcd9xxx_resmgr_notifier_call(&tapan->resmgr,
 +						WCD9XXX_EVENT_POST_TX_3_OFF);
++=======
+ 		if (w->reg == TAPAN_A_TX_3_EN ||
+ 		    w->reg == TAPAN_A_TX_1_EN)
+ 			wcd9xxx_resmgr_notifier_call(&tapan->resmgr,
+ 						WCD9XXX_EVENT_POST_TX_1_3_OFF);
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	return 0;
@@@ -2246,16 -2275,23 +2350,36 @@@ static int tapan_codec_enable_micbias(s
  
  #ifndef CONFIG_ARCH_MSM8226
  /* called under codec_resource_lock acquisition */
++<<<<<<< HEAD
 +static int tapan_enable_mbhc_micbias(struct snd_soc_codec *codec, bool enable)
 +{
 +	int rc;
 +
 +	if (enable)
 +		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
 +					     DAPM_MICBIAS2_EXTERNAL_STANDALONE);
 +	else
 +		rc = snd_soc_dapm_disable_pin(&codec->dapm,
 +					     DAPM_MICBIAS2_EXTERNAL_STANDALONE);
++=======
+ static int tapan_enable_mbhc_micbias(struct snd_soc_codec *codec, bool enable,
+ 				     enum wcd9xxx_micbias_num micb_num)
+ {
+ 	int rc;
+ 	const char *micbias;
+ 
+ 	if (micb_num == MBHC_MICBIAS2)
+ 		micbias = DAPM_MICBIAS2_EXTERNAL_STANDALONE;
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (enable)
+ 		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
+ 						   micbias);
+ 	else
+ 		rc = snd_soc_dapm_disable_pin(&codec->dapm,
+ 					      micbias);
++>>>>>>> FETCH_HEAD
  	if (!rc)
  		snd_soc_dapm_sync(&codec->dapm);
  	pr_debug("%s: leave ret %d\n", __func__, rc);
@@@ -4041,6 -4077,7 +4165,10 @@@ static int tapan_codec_enable_slimrx(st
  
  	switch (event) {
  	case SND_SOC_DAPM_POST_PMU:
++<<<<<<< HEAD
++=======
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		(void) tapan_codec_enable_slim_chmask(dai, true);
  		ret = wcd9xxx_cfg_slim_sch_rx(core, &dai->wcd9xxx_ch_list,
  					      dai->rate, dai->bit_width,
@@@ -4049,7 -4086,8 +4177,12 @@@
  	case SND_SOC_DAPM_POST_PMD:
  		ret = wcd9xxx_close_slim_sch_rx(core, &dai->wcd9xxx_ch_list,
  						dai->grph);
++<<<<<<< HEAD
 +		ret = tapan_codec_enable_slim_chmask(dai, false);
++=======
+ 		if (!dai->bus_down_in_recovery)
+ 			ret = tapan_codec_enable_slim_chmask(dai, false);
++>>>>>>> FETCH_HEAD
  		if (ret < 0) {
  			ret = wcd9xxx_disconnect_port(core,
  						      &dai->wcd9xxx_ch_list,
@@@ -4064,6 -4102,7 +4197,10 @@@
  			pm_runtime_put(core->dev->parent);
  			dev_dbg(codec->dev, "%s: unvote requested", __func__);
  		}
++<<<<<<< HEAD
++=======
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	return ret;
@@@ -4095,6 -4134,7 +4232,10 @@@ static int tapan_codec_enable_slimtx(st
  	dai = &tapan_p->dai[w->shift];
  	switch (event) {
  	case SND_SOC_DAPM_POST_PMU:
++<<<<<<< HEAD
++=======
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		(void) tapan_codec_enable_slim_chmask(dai, true);
  		ret = wcd9xxx_cfg_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
  					      dai->rate, dai->bit_width,
@@@ -4103,7 -4143,8 +4244,12 @@@
  	case SND_SOC_DAPM_POST_PMD:
  		ret = wcd9xxx_close_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
  						dai->grph);
++<<<<<<< HEAD
 +		ret = tapan_codec_enable_slim_chmask(dai, false);
++=======
+ 		if (!dai->bus_down_in_recovery)
+ 			ret = tapan_codec_enable_slim_chmask(dai, false);
++>>>>>>> FETCH_HEAD
  		if (ret < 0) {
  			ret = wcd9xxx_disconnect_port(core,
  						      &dai->wcd9xxx_ch_list,
@@@ -4118,6 -4159,7 +4264,10 @@@
  			pm_runtime_put(core->dev->parent);
  			dev_dbg(codec->dev, "%s: unvote requested", __func__);
  		}
++<<<<<<< HEAD
++=======
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	return ret;
@@@ -4290,7 -4332,7 +4440,11 @@@ static const struct snd_soc_dapm_widge
  	SND_SOC_DAPM_MUX("RX4 MIX1 INP2", SND_SOC_NOPM, 0, 0,
  		&rx4_mix1_inp2_mux),
  	SND_SOC_DAPM_MUX("RX4 MIX1 INP3", SND_SOC_NOPM, 0, 0,
++<<<<<<< HEAD
 +		&rx4_mix1_inp2_mux),
++=======
+ 		&rx4_mix1_inp3_mux),
++>>>>>>> FETCH_HEAD
  
  	/* RX4 MIX2 mux inputs */
  	SND_SOC_DAPM_MUX("RX4 MIX2 INP1", SND_SOC_NOPM, 0, 0,
@@@ -5590,6 -5632,7 +5744,10 @@@ static int tapan_post_reset_cb(struct w
  	int rco_clk_rate;
  	struct snd_soc_codec *codec;
  	struct tapan_priv *tapan;
++<<<<<<< HEAD
++=======
+ 	int count;
++>>>>>>> FETCH_HEAD
  
  	codec = (struct snd_soc_codec *)(wcd9xxx->ssr_priv);
  	tapan = snd_soc_codec_get_drvdata(codec);
@@@ -5651,6 -5694,9 +5809,12 @@@
  
  	tapan->machine_codec_event_cb(codec, WCD9XXX_CODEC_EVENT_CODEC_UP);
  
++<<<<<<< HEAD
++=======
+ 	for (count = 0; count < NUM_CODEC_DAIS; count++)
+ 		tapan->dai[count].bus_down_in_recovery = true;
+ 
++>>>>>>> FETCH_HEAD
  	mutex_unlock(&codec->mutex);
  	return ret;
  }
@@@ -5674,7 -5720,17 +5838,21 @@@ static struct regulator *tapan_codec_fi
  	const char *name)
  {
  	int i;
++<<<<<<< HEAD
 +	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
++=======
+ 	struct wcd9xxx *core = NULL;
+ 
+ 	if (codec == NULL) {
+ 		dev_err(codec->dev, "%s: codec not initialized\n", __func__);
+ 		return NULL;
+ 	}
+ 	core = dev_get_drvdata(codec->dev->parent);
+ 	if (core == NULL) {
+ 		dev_err(codec->dev, "%s: core not initialized\n", __func__);
+ 		return NULL;
+ 	}
++>>>>>>> FETCH_HEAD
  
  	for (i = 0; i < core->num_of_supplies; i++) {
  		if (core->supplies[i].supply &&
@@@ -5949,8 -6005,8 +6127,13 @@@ static int tapan_codec_probe(struct snd
  		snd_soc_dapm_disable_pin(dapm, "ANC EAR PA");
  		snd_soc_dapm_disable_pin(dapm, "ANC EAR");
  	}
++<<<<<<< HEAD
 +	snd_soc_dapm_sync(dapm);
 +	mutex_unlock(&dapm->codec->mutex);
++=======
+ 	mutex_unlock(&dapm->codec->mutex);
+ 	snd_soc_dapm_sync(dapm);
++>>>>>>> FETCH_HEAD
  
  	codec->ignore_pmdown_time = 1;
  
diff --cc sound/soc/codecs/wcd9320.c
index 19d4523,bf40bd1..0000000
--- a/sound/soc/codecs/wcd9320.c
+++ b/sound/soc/codecs/wcd9320.c
@@@ -68,6 -68,7 +68,10 @@@
  #define TAIKO_HPH_PA_SETTLE_COMP_OFF 13000
  
  #define DAPM_MICBIAS2_EXTERNAL_STANDALONE "MIC BIAS2 External Standalone"
++<<<<<<< HEAD
++=======
+ #define DAPM_MICBIAS3_EXTERNAL_STANDALONE "MIC BIAS3 External Standalone"
++>>>>>>> FETCH_HEAD
  
  /* RX_HPH_CNP_WG_TIME increases by 0.24ms */
  #define TAIKO_WG_TIME_FACTOR_US	240
@@@ -76,6 -77,10 +80,13 @@@ static atomic_t kp_taiko_priv
  static int spkr_drv_wrnd_param_set(const char *val,
  				   const struct kernel_param *kp);
  static int spkr_drv_wrnd = 1;
++<<<<<<< HEAD
++=======
+ static int high_perf_mode;
+ module_param(high_perf_mode, int,
+ 			S_IRUGO | S_IWUSR | S_IWGRP);
+ MODULE_PARM_DESC(high_perf_mode, "enable/disable class AB config for hph");
++>>>>>>> FETCH_HEAD
  
  static struct kernel_param_ops spkr_drv_wrnd_param_ops = {
  	.set = spkr_drv_wrnd_param_set,
@@@ -280,6 -285,8 +291,11 @@@ MODULE_PARM_DESC(spkr_drv_wrnd
  
  #define TAIKO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE)
  
++<<<<<<< HEAD
++=======
+ #define TAIKO_SLIM_PGD_PORT_INT_TX_EN0 (TAIKO_SLIM_PGD_PORT_INT_EN0 + 2)
+ 
++>>>>>>> FETCH_HEAD
  enum {
  	AIF1_PB = 0,
  	AIF1_CAP,
@@@ -520,7 -527,7 +536,11 @@@ static const struct comp_sample_depende
  		/* 192 Khz */
  		.peak_det_timeout = 0x0B,
  		.rms_meter_div_fact = 0xC,
++<<<<<<< HEAD
 +		.rms_meter_resamp_fact = 0x50,
++=======
+ 		.rms_meter_resamp_fact = 0xA0,
++>>>>>>> FETCH_HEAD
  	},
  };
  
@@@ -654,8 -661,8 +674,13 @@@ static int taiko_put_anc_func(struct sn
  		snd_soc_dapm_enable_pin(dapm, "EAR PA");
  		snd_soc_dapm_enable_pin(dapm, "EAR");
  	}
++<<<<<<< HEAD
 +	snd_soc_dapm_sync(dapm);
 +	mutex_unlock(&dapm->codec->mutex);
++=======
+ 	mutex_unlock(&dapm->codec->mutex);
+ 	snd_soc_dapm_sync(dapm);
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -1005,16 -1012,17 +1030,30 @@@ static int taiko_config_compander(struc
  		snd_soc_update_bits(codec,
  				    TAIKO_A_CDC_COMP0_FS_CFG + (comp * 8),
  				    0x07, rate);
++<<<<<<< HEAD
 +		/* Set the static gain offset */
 +		if (comp == COMPANDER_1
 +			&& buck_mv == WCD9XXX_CDC_BUCK_MV_1P8) {
 +			snd_soc_update_bits(codec,
 +					TAIKO_A_CDC_COMP0_B4_CTL + (comp * 8),
 +					0x80, 0x80);
 +		} else {
 +			snd_soc_update_bits(codec,
 +					TAIKO_A_CDC_COMP0_B4_CTL + (comp * 8),
 +					0x80, 0x00);
++=======
+ 		/* Set the static gain offset for HPH Path */
+ 		if (comp == COMPANDER_1) {
+ 			if (buck_mv == WCD9XXX_CDC_BUCK_MV_2P15) {
+ 				snd_soc_update_bits(codec,
+ 					TAIKO_A_CDC_COMP0_B4_CTL + (comp * 8),
+ 					0x80, 0x00);
+ 			} else {
+ 				snd_soc_update_bits(codec,
+ 					TAIKO_A_CDC_COMP0_B4_CTL + (comp * 8),
+ 					0x80, 0x80);
+ 			}
++>>>>>>> FETCH_HEAD
  		}
  		/* Enable RX interpolation path compander clocks */
  		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RX_B2_CTL,
@@@ -1147,6 -1155,24 +1186,27 @@@ static const struct soc_enum class_h_ds
  static const struct snd_kcontrol_new class_h_dsm_mux =
  	SOC_DAPM_ENUM("CLASS_H_DSM MUX Mux", class_h_dsm_enum);
  
++<<<<<<< HEAD
++=======
+ static const char * const rx1_interpolator_text[] = {
+ 	"ZERO", "RX1 MIX2"
+ };
+ static const struct soc_enum rx1_interpolator_enum =
+ 	SOC_ENUM_SINGLE(TAIKO_A_CDC_CLK_RX_B1_CTL, 0, 2, rx1_interpolator_text);
+ 
+ static const struct snd_kcontrol_new rx1_interpolator =
+ 	SOC_DAPM_ENUM("RX1 INTERP Mux", rx1_interpolator_enum);
+ 
+ static const char * const rx2_interpolator_text[] = {
+ 	"ZERO", "RX2 MIX2"
+ };
+ static const struct soc_enum rx2_interpolator_enum =
+ 	SOC_ENUM_SINGLE(TAIKO_A_CDC_CLK_RX_B1_CTL, 1, 2, rx2_interpolator_text);
+ 
+ static const struct snd_kcontrol_new rx2_interpolator =
+ 	SOC_DAPM_ENUM("RX2 INTERP Mux", rx2_interpolator_enum);
+ 
++>>>>>>> FETCH_HEAD
  static const char *const taiko_conn_mad_text[] = {
  	"ADC_MB", "ADC1", "ADC2", "ADC3", "ADC4", "ADC5", "ADC6", "NOTUSED1",
  	"DMIC1", "DMIC2", "DMIC3", "DMIC4", "DMIC5", "DMIC6", "NOTUSED2",
@@@ -1187,6 -1213,7 +1247,10 @@@ static int taiko_mad_input_put(struct s
  	u32  mic_bias_found = 0;
  	u32 i;
  	int ret = 0;
++<<<<<<< HEAD
++=======
+ 	char *mad_input;
++>>>>>>> FETCH_HEAD
  
  	taiko_mad_input = ucontrol->value.integer.value[0];
  
@@@ -1204,8 -1231,14 +1268,19 @@@
  
  	if (strnstr(taiko_conn_mad_text[taiko_mad_input],
  				"ADC", sizeof("ADC"))) {
++<<<<<<< HEAD
 +		ret = kstrtouint(strpbrk(taiko_conn_mad_text[taiko_mad_input]
 +					, "123456"), 10, &adc);
++=======
+ 		mad_input = strpbrk(taiko_conn_mad_text[taiko_mad_input],
+ 				"123456");
+ 		if (!mad_input) {
+ 			dev_err(codec->dev, "%s: Invalid MAD input = %s\n",
+ 			__func__, taiko_conn_mad_text[taiko_mad_input]);
+ 			return -EINVAL;
+ 		}
+ 		ret = kstrtouint(mad_input, 10, &adc);
++>>>>>>> FETCH_HEAD
  		if ((ret < 0) || (adc > 6)) {
  			pr_err("%s: Invalid ADC = %s\n", __func__,
  				taiko_conn_mad_text[taiko_mad_input]);
@@@ -1933,6 -1966,7 +2008,10 @@@ static int wcd9320_put_dec_enum(struct 
  	u16 tx_mux_ctl_reg;
  	u8 adc_dmic_sel = 0x0;
  	int ret = 0;
++<<<<<<< HEAD
++=======
+ 	char *dec;
++>>>>>>> FETCH_HEAD
  
  	if (ucontrol->value.enumerated.item[0] > e->max - 1)
  		return -EINVAL;
@@@ -1951,8 -1985,14 +2030,19 @@@
  		ret =  -EINVAL;
  		goto out;
  	}
++<<<<<<< HEAD
 +
 +	ret = kstrtouint(strpbrk(dec_name, "123456789"), 10, &decimator);
++=======
+ 	dec = strpbrk(dec_name, "123456789");
+ 	if (!dec) {
+ 		dev_err(w->dapm->dev, "%s: decimator index not found\n",
+ 			__func__);
+ 		ret =  -EINVAL;
+ 		goto out;
+ 	}
+ 	ret = kstrtouint(dec, 10, &decimator);
++>>>>>>> FETCH_HEAD
  	if (ret < 0) {
  		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
  		ret =  -EINVAL;
@@@ -2197,9 -2237,9 +2287,15 @@@ static int slim_tx_mixer_put(struct snd
  	pr_debug("%s: name %s sname %s updated value %u shift %d\n", __func__,
  		widget->name, widget->sname, widget->value, widget->shift);
  
++<<<<<<< HEAD
 +	snd_soc_dapm_mixer_update_power(widget, kcontrol, enable);
 +
 +	mutex_unlock(&codec->mutex);
++=======
+ 	mutex_unlock(&codec->mutex);
+ 	snd_soc_dapm_mixer_update_power(widget, kcontrol, enable);
+ 
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -2287,9 -2327,10 +2383,16 @@@ static int slim_rx_mux_put(struct snd_k
  		goto err;
  	}
  rtn:
++<<<<<<< HEAD
 +	snd_soc_dapm_mux_update_power(widget, kcontrol, 1, widget->value, e);
 +
 +	mutex_unlock(&codec->mutex);
++=======
+ 
+ 	mutex_unlock(&codec->mutex);
+ 	snd_soc_dapm_mux_update_power(widget, kcontrol, 1, widget->value, e);
+ 
++>>>>>>> FETCH_HEAD
  	return 0;
  err:
  	mutex_unlock(&codec->mutex);
@@@ -2505,9 -2546,10 +2608,16 @@@ static int taiko_codec_enable_lineout(s
  						 WCD9XXX_CLSH_STATE_LO,
  						 WCD9XXX_CLSH_REQ_ENABLE,
  						 WCD9XXX_CLSH_EVENT_POST_PA);
++<<<<<<< HEAD
 +		pr_debug("%s: sleeping 3 ms after %s PA turn on\n",
 +				__func__, w->name);
 +		usleep_range(3000, 3000);
++=======
+ 		pr_debug("%s: sleeping 5 ms after %s PA turn on\n",
+ 				__func__, w->name);
+ 		/* Wait for CnP time after PA enable */
+ 		usleep_range(5000, 5100);
++>>>>>>> FETCH_HEAD
  		break;
  	case SND_SOC_DAPM_POST_PMD:
  		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
@@@ -2515,6 -2557,10 +2625,13 @@@
  						 WCD9XXX_CLSH_REQ_DISABLE,
  						 WCD9XXX_CLSH_EVENT_POST_PA);
  		snd_soc_update_bits(codec, lineout_gain_reg, 0x40, 0x00);
++<<<<<<< HEAD
++=======
+ 		pr_debug("%s: sleeping 5 ms after %s PA turn off\n",
+ 				__func__, w->name);
+ 		/* Wait for CnP time after PA disable */
+ 		usleep_range(5000, 5100);
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	return 0;
@@@ -2550,8 -2596,14 +2667,19 @@@ static int taiko_codec_enable_dmic(stru
  	s32 *dmic_clk_cnt;
  	unsigned int dmic;
  	int ret;
++<<<<<<< HEAD
 +
 +	ret = kstrtouint(strpbrk(w->name, "123456"), 10, &dmic);
++=======
+ 	char *wname;
+ 
+ 	wname = strpbrk(w->name, "123456");
+ 	if (!wname) {
+ 		dev_err(codec->dev, "%s: widget not found\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 	ret = kstrtouint(wname, 10, &dmic);
++>>>>>>> FETCH_HEAD
  	if (ret < 0) {
  		pr_err("%s: Invalid DMIC line on the codec\n", __func__);
  		return -EINVAL;
@@@ -2843,16 -2895,26 +2971,39 @@@ static int taiko_codec_enable_micbias(s
  }
  
  /* called under codec_resource_lock acquisition */
++<<<<<<< HEAD
 +static int taiko_enable_mbhc_micbias(struct snd_soc_codec *codec, bool enable)
 +{
 +	int rc;
 +
 +	if (enable)
 +		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
 +					     DAPM_MICBIAS2_EXTERNAL_STANDALONE);
 +	else
 +		rc = snd_soc_dapm_disable_pin(&codec->dapm,
 +					     DAPM_MICBIAS2_EXTERNAL_STANDALONE);
++=======
+ static int taiko_enable_mbhc_micbias(struct snd_soc_codec *codec, bool enable,
+ 				     enum wcd9xxx_micbias_num micb_num)
+ {
+ 	int rc;
+ 	const char *micbias;
+ 
+ 	if (micb_num != MBHC_MICBIAS3 &&
+ 	    micb_num != MBHC_MICBIAS2)
+ 		return -EINVAL;
+ 
+ 	micbias = (micb_num == MBHC_MICBIAS3) ?
+ 			DAPM_MICBIAS3_EXTERNAL_STANDALONE :
+ 			DAPM_MICBIAS2_EXTERNAL_STANDALONE;
+ 
+ 	if (enable)
+ 		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
+ 					     micbias);
+ 	else
+ 		rc = snd_soc_dapm_disable_pin(&codec->dapm,
+ 					     micbias);
++>>>>>>> FETCH_HEAD
  	if (!rc)
  		snd_soc_dapm_sync(&codec->dapm);
  	pr_debug("%s: leave ret %d\n", __func__, rc);
@@@ -2900,7 -2962,7 +3051,11 @@@ static int taiko_codec_enable_dec(struc
  	u16 dec_reset_reg, tx_vol_ctl_reg, tx_mux_ctl_reg;
  	u8 dec_hpf_cut_of_freq;
  	int offset;
++<<<<<<< HEAD
 +
++=======
+ 	char *dec;
++>>>>>>> FETCH_HEAD
  
  	pr_debug("%s %d\n", __func__, event);
  
@@@ -2917,7 -2979,15 +3072,19 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = kstrtouint(strpbrk(dec_name, "123456789"), 10, &decimator);
++=======
+ 	dec = strpbrk(dec_name, "123456789");
+ 	if (!dec) {
+ 		dev_err(codec->dev, "%s: decimator index not found\n",
+ 			__func__);
+ 		ret =  -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	ret = kstrtouint(dec, 10, &decimator);
++>>>>>>> FETCH_HEAD
  	if (ret < 0) {
  		pr_err("%s: Invalid decimator = %s\n", __func__, dec_name);
  		ret =  -EINVAL;
@@@ -3184,10 -3254,16 +3351,23 @@@ static int taiko_hphl_dac_event(struct 
  	case SND_SOC_DAPM_PRE_PMU:
  		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
  							0x02, 0x02);
++<<<<<<< HEAD
 +		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
 +						 WCD9XXX_CLSH_STATE_HPHL,
 +						 WCD9XXX_CLSH_REQ_ENABLE,
 +						 WCD9XXX_CLSH_EVENT_PRE_DAC);
++=======
+ 		if (!high_perf_mode) {
+ 			wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
+ 						 WCD9XXX_CLSH_STATE_HPHL,
+ 						 WCD9XXX_CLSH_REQ_ENABLE,
+ 						 WCD9XXX_CLSH_EVENT_PRE_DAC);
+ 		} else {
+ 			wcd9xxx_enable_high_perf_mode(codec, &taiko_p->clsh_d,
+ 						WCD9XXX_CLSAB_STATE_HPHL,
+ 						WCD9XXX_CLSAB_REQ_ENABLE);
+ 		}
++>>>>>>> FETCH_HEAD
  
  		/*ret = wcd9xxx_mbhc_get_impedance(&taiko_p->mbhc,
  					&impedl, &impedr);
@@@ -3200,6 -3276,7 +3380,10 @@@
  	case SND_SOC_DAPM_POST_PMD:
  		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
  							0x02, 0x00);
++<<<<<<< HEAD
++=======
+ 		break;
++>>>>>>> FETCH_HEAD
  	}
  	return 0;
  }
@@@ -3217,10 -3294,17 +3401,24 @@@ static int taiko_hphr_dac_event(struct 
  		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
  							0x04, 0x04);
  		snd_soc_update_bits(codec, w->reg, 0x40, 0x40);
++<<<<<<< HEAD
 +		wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
 +						 WCD9XXX_CLSH_STATE_HPHR,
 +						 WCD9XXX_CLSH_REQ_ENABLE,
 +						 WCD9XXX_CLSH_EVENT_PRE_DAC);
++=======
+ 
+ 		if (!high_perf_mode) {
+ 			wcd9xxx_clsh_fsm(codec, &taiko_p->clsh_d,
+ 						 WCD9XXX_CLSH_STATE_HPHR,
+ 						 WCD9XXX_CLSH_REQ_ENABLE,
+ 						 WCD9XXX_CLSH_EVENT_PRE_DAC);
+ 		} else {
+ 			wcd9xxx_enable_high_perf_mode(codec, &taiko_p->clsh_d,
+ 						WCD9XXX_CLSAB_STATE_HPHR,
+ 						WCD9XXX_CLSAB_REQ_ENABLE);
+ 		}
++>>>>>>> FETCH_HEAD
  		break;
  	case SND_SOC_DAPM_POST_PMD:
  		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_RDAC_CLK_EN_CTL,
@@@ -3340,6 -3424,7 +3538,10 @@@ static int taiko_hph_pa_event(struct sn
  	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
  	enum wcd9xxx_notify_event e_pre_on, e_post_off;
  	u8 req_clsh_state;
++<<<<<<< HEAD
++=======
+ 	u8 req_clsab_state;
++>>>>>>> FETCH_HEAD
  	u32 pa_settle_time = TAIKO_HPH_PA_SETTLE_COMP_OFF;
  
  	pr_debug("%s: %s event = %d\n", __func__, w->name, event);
@@@ -3347,10 -3432,12 +3549,18 @@@
  		e_pre_on = WCD9XXX_EVENT_PRE_HPHL_PA_ON;
  		e_post_off = WCD9XXX_EVENT_POST_HPHL_PA_OFF;
  		req_clsh_state = WCD9XXX_CLSH_STATE_HPHL;
++<<<<<<< HEAD
++=======
+ 		req_clsab_state = WCD9XXX_CLSAB_STATE_HPHL;
++>>>>>>> FETCH_HEAD
  	} else if (w->shift == 4) {
  		e_pre_on = WCD9XXX_EVENT_PRE_HPHR_PA_ON;
  		e_post_off = WCD9XXX_EVENT_POST_HPHR_PA_OFF;
  		req_clsh_state = WCD9XXX_CLSH_STATE_HPHR;
++<<<<<<< HEAD
++=======
+ 		req_clsab_state = WCD9XXX_CLSAB_STATE_HPHR;
++>>>>>>> FETCH_HEAD
  	} else {
  		pr_err("%s: Invalid w->shift %d\n", __func__, w->shift);
  		return -EINVAL;
@@@ -3369,11 -3456,13 +3579,21 @@@
  		usleep_range(pa_settle_time, pa_settle_time + 1000);
  		pr_debug("%s: sleep %d us after %s PA enable\n", __func__,
  				pa_settle_time, w->name);
++<<<<<<< HEAD
 +		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
 +						 req_clsh_state,
 +						 WCD9XXX_CLSH_REQ_ENABLE,
 +						 WCD9XXX_CLSH_EVENT_POST_PA);
 +
++=======
+ 
+ 		if (!high_perf_mode) {
+ 			wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
+ 						 req_clsh_state,
+ 						 WCD9XXX_CLSH_REQ_ENABLE,
+ 						 WCD9XXX_CLSH_EVENT_POST_PA);
+ 		}
++>>>>>>> FETCH_HEAD
  		break;
  
  	case SND_SOC_DAPM_POST_PMD:
@@@ -3384,10 -3473,16 +3604,23 @@@
  		/* Let MBHC module know PA turned off */
  		wcd9xxx_resmgr_notifier_call(&taiko->resmgr, e_post_off);
  
++<<<<<<< HEAD
 +		wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
 +						 req_clsh_state,
 +						 WCD9XXX_CLSH_REQ_DISABLE,
 +						 WCD9XXX_CLSH_EVENT_POST_PA);
++=======
+ 		if (!high_perf_mode) {
+ 			wcd9xxx_clsh_fsm(codec, &taiko->clsh_d,
+ 						 req_clsh_state,
+ 						 WCD9XXX_CLSH_REQ_DISABLE,
+ 						 WCD9XXX_CLSH_EVENT_POST_PA);
+ 		} else {
+ 			wcd9xxx_enable_high_perf_mode(codec, &taiko->clsh_d,
+ 						req_clsab_state,
+ 						WCD9XXX_CLSAB_REQ_DISABLE);
+ 		}
++>>>>>>> FETCH_HEAD
  
  		break;
  	}
@@@ -3425,6 -3520,7 +3658,10 @@@ static int taiko_codec_enable_anc_hph(s
  					TAIKO_A_TX_7_MBHC_EN, 0x80, 00);
  			ret |= taiko_codec_enable_anc(w, kcontrol, event);
  		}
++<<<<<<< HEAD
++=======
+ 		break;
++>>>>>>> FETCH_HEAD
  	case SND_SOC_DAPM_POST_PMD:
  		ret = taiko_hph_pa_event(w, kcontrol, event);
  		break;
@@@ -3701,8 -3797,11 +3938,16 @@@ static const struct snd_soc_dapm_route 
  
  	{"CLASS_H_DSM MUX", "DSM_HPHL_RX1", "RX1 CHAIN"},
  
++<<<<<<< HEAD
 +	{"RX1 CHAIN", NULL, "RX1 MIX2"},
 +	{"RX2 CHAIN", NULL, "RX2 MIX2"},
++=======
+ 	{"RX1 INTERP", NULL, "RX1 MIX2"},
+ 	{"RX1 CHAIN", NULL, "RX1 INTERP"},
+ 	{"RX2 INTERP", NULL, "RX2 MIX2"},
+ 	{"RX2 CHAIN", NULL, "RX2 INTERP"},
+ 
++>>>>>>> FETCH_HEAD
  	{"RX1 MIX2", NULL, "ANC1 MUX"},
  	{"RX2 MIX2", NULL, "ANC2 MUX"},
  
@@@ -4034,6 -4133,7 +4279,10 @@@
  	{"MIC BIAS4 External", NULL, "LDO_H"},
  	{"Main Mic Bias", NULL, "LDO_H"},
  	{DAPM_MICBIAS2_EXTERNAL_STANDALONE, NULL, "LDO_H Standalone"},
++<<<<<<< HEAD
++=======
+ 	{DAPM_MICBIAS3_EXTERNAL_STANDALONE, NULL, "LDO_H Standalone"},
++>>>>>>> FETCH_HEAD
  };
  
  static int taiko_readable(struct snd_soc_codec *ssc, unsigned int reg)
@@@ -4300,8 -4400,9 +4549,14 @@@ static int taiko_set_channel_map(struc
  	struct wcd9xxx_codec_dai_data *dai_data = NULL;
  	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(dai->codec);
  	struct wcd9xxx *core = dev_get_drvdata(dai->codec->dev->parent);
++<<<<<<< HEAD
 +	if (!tx_slot && !rx_slot) {
 +		pr_err("%s: Invalid\n", __func__);
++=======
+ 	if (!tx_slot || !rx_slot) {
+ 		pr_err("%s: Invalid tx_slot=%p, rx_slot=%p\n", __func__,
+ 			tx_slot, rx_slot);
++>>>>>>> FETCH_HEAD
  		return -EINVAL;
  	}
  	pr_debug("%s(): dai_name = %s DAI-ID %x tx_ch %d rx_ch %d\n"
@@@ -5178,6 -5279,46 +5433,49 @@@ static int taiko_codec_enable_slim_chma
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void taiko_codec_enable_int_port(struct wcd9xxx_codec_dai_data *dai,
+ 					  struct snd_soc_codec *codec)
+ {
+ 	struct wcd9xxx_ch *ch;
+ 	int port_num = 0;
+ 	unsigned short reg = 0;
+ 	u8 val = 0;
+ 	if (!dai || !codec) {
+ 		pr_err("%s: Invalid params\n", __func__);
+ 		return;
+ 	}
+ 	list_for_each_entry(ch, &dai->wcd9xxx_ch_list, list) {
+ 		if (ch->port >= TAIKO_RX_PORT_START_NUMBER) {
+ 			port_num = ch->port - TAIKO_RX_PORT_START_NUMBER;
+ 			reg = TAIKO_SLIM_PGD_PORT_INT_EN0 + (port_num / 8);
+ 			val = wcd9xxx_interface_reg_read(codec->control_data,
+ 				reg);
+ 			if (!(val & (1 << (port_num % 8)))) {
+ 				val |= (1 << (port_num % 8));
+ 				wcd9xxx_interface_reg_write(
+ 					codec->control_data, reg, val);
+ 				val = wcd9xxx_interface_reg_read(
+ 					codec->control_data, reg);
+ 			}
+ 		} else {
+ 			port_num = ch->port;
+ 			reg = TAIKO_SLIM_PGD_PORT_INT_TX_EN0 + (port_num / 8);
+ 			val = wcd9xxx_interface_reg_read(codec->control_data,
+ 				reg);
+ 			if (!(val & (1 << (port_num % 8)))) {
+ 				val |= (1 << (port_num % 8));
+ 				wcd9xxx_interface_reg_write(codec->control_data,
+ 					reg, val);
+ 				val = wcd9xxx_interface_reg_read(
+ 					codec->control_data, reg);
+ 			}
+ 		}
+ 	}
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int taiko_codec_enable_slimrx(struct snd_soc_dapm_widget *w,
  				     struct snd_kcontrol *kcontrol,
  				     int event)
@@@ -5204,6 -5345,8 +5502,11 @@@
  
  	switch (event) {
  	case SND_SOC_DAPM_POST_PMU:
++<<<<<<< HEAD
++=======
+ 		dai->bus_down_in_recovery = false;
+ 		taiko_codec_enable_int_port(dai, codec);
++>>>>>>> FETCH_HEAD
  		(void) taiko_codec_enable_slim_chmask(dai, true);
  #if defined(CONFIG_SND_SOC_ESXXX)
  		ret = remote_cfg_slim_rx(w->shift);
@@@ -5222,7 -5365,9 +5525,13 @@@
  #endif
  		ret = wcd9xxx_close_slim_sch_rx(core, &dai->wcd9xxx_ch_list,
  						dai->grph);
++<<<<<<< HEAD
 +		ret = taiko_codec_enable_slim_chmask(dai, false);
++=======
+ 		if (!dai->bus_down_in_recovery)
+ 			ret = taiko_codec_enable_slim_chmask(dai, false);
+ 
++>>>>>>> FETCH_HEAD
  		if (ret < 0) {
  			ret = wcd9xxx_disconnect_port(core,
  						      &dai->wcd9xxx_ch_list,
@@@ -5230,6 -5375,7 +5539,10 @@@
  			pr_debug("%s: Disconnect RX port, ret = %d\n",
  				 __func__, ret);
  		}
++<<<<<<< HEAD
++=======
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	return ret;
@@@ -5278,6 -5424,8 +5591,11 @@@ static int taiko_codec_enable_slimvi_fe
  		/*Enable spkr VI clocks*/
  		snd_soc_update_bits(codec,
  		TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL, 0xC, 0xC);
++<<<<<<< HEAD
++=======
+ 		taiko_codec_enable_int_port(dai, codec);
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		(void) taiko_codec_enable_slim_chmask(dai, true);
  		ret = wcd9xxx_cfg_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
  					dai->rate, dai->bit_width,
@@@ -5294,6 -5442,8 +5612,11 @@@
  		/*Disable V&I sensing*/
  		snd_soc_update_bits(codec, TAIKO_A_SPKR_PROT_EN,
  				0x88, 0x00);
++<<<<<<< HEAD
++=======
+ 
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  out_vi:
@@@ -5323,8 -5473,11 +5646,16 @@@ static int taiko_codec_enable_slimtx(st
  		__func__, w->name, event, w->shift);
  
  	dai = &taiko_p->dai[w->shift];
++<<<<<<< HEAD
++	switch (event) {
++	case SND_SOC_DAPM_POST_PMU:
++=======
+ 
  	switch (event) {
  	case SND_SOC_DAPM_POST_PMU:
+ 		taiko_codec_enable_int_port(dai, codec);
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		(void) taiko_codec_enable_slim_chmask(dai, true);
  		ret = wcd9xxx_cfg_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
  					      dai->rate, dai->bit_width,
@@@ -5343,7 -5496,9 +5674,13 @@@
  #endif
  		ret = wcd9xxx_close_slim_sch_tx(core, &dai->wcd9xxx_ch_list,
  						dai->grph);
++<<<<<<< HEAD
 +		ret = taiko_codec_enable_slim_chmask(dai, false);
++=======
+ 		if (!dai->bus_down_in_recovery)
+ 			ret = taiko_codec_enable_slim_chmask(dai, false);
+ 
++>>>>>>> FETCH_HEAD
  		if (ret < 0) {
  			ret = wcd9xxx_disconnect_port(core,
  						      &dai->wcd9xxx_ch_list,
@@@ -5351,6 -5506,8 +5688,11 @@@
  			pr_debug("%s: Disconnect RX port, ret = %d\n",
  				 __func__, ret);
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		dai->bus_down_in_recovery = false;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	return ret;
@@@ -5578,12 -5735,9 +5920,18 @@@ static const struct snd_soc_dapm_widge
  	SND_SOC_DAPM_MIXER("RX2 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
  	SND_SOC_DAPM_MIXER("RX7 MIX1", SND_SOC_NOPM, 0, 0, NULL, 0),
  
++<<<<<<< HEAD
 +	SND_SOC_DAPM_MIXER_E("RX1 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 0, 0, NULL,
 +		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
 +		SND_SOC_DAPM_POST_PMU),
 +	SND_SOC_DAPM_MIXER_E("RX2 MIX2", TAIKO_A_CDC_CLK_RX_B1_CTL, 1, 0, NULL,
 +		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
 +		SND_SOC_DAPM_POST_PMU),
++=======
+ 	SND_SOC_DAPM_MIXER("RX1 MIX2", SND_SOC_NOPM, 0, 0, NULL, 0),
+ 	SND_SOC_DAPM_MIXER("RX2 MIX2", SND_SOC_NOPM, 0, 0, NULL, 0),
+ 
++>>>>>>> FETCH_HEAD
  	SND_SOC_DAPM_MIXER_E("RX3 MIX1", TAIKO_A_CDC_CLK_RX_B1_CTL, 2, 0, NULL,
  		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
  		SND_SOC_DAPM_POST_PMU),
@@@ -5600,6 -5754,12 +5948,15 @@@
  		0, taiko_codec_enable_interpolator, SND_SOC_DAPM_PRE_PMU |
  		SND_SOC_DAPM_POST_PMU),
  
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_MUX_E("RX1 INTERP", TAIKO_A_CDC_CLK_RX_B1_CTL, 0, 0,
+ 		&rx1_interpolator, taiko_codec_enable_interpolator,
+ 		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
+ 	SND_SOC_DAPM_MUX_E("RX2 INTERP", TAIKO_A_CDC_CLK_RX_B1_CTL, 1, 0,
+ 		&rx2_interpolator, taiko_codec_enable_interpolator,
+ 		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),
++>>>>>>> FETCH_HEAD
  
  	SND_SOC_DAPM_MIXER("RX1 CHAIN", TAIKO_A_CDC_RX1_B6_CTL, 5, 0, NULL, 0),
  	SND_SOC_DAPM_MIXER("RX2 CHAIN", TAIKO_A_CDC_RX2_B6_CTL, 5, 0, NULL, 0),
@@@ -5806,6 -5966,10 +6163,13 @@@
  			       taiko_codec_enable_micbias,
  			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
  			       SND_SOC_DAPM_POST_PMD),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_MICBIAS_E(DAPM_MICBIAS3_EXTERNAL_STANDALONE, SND_SOC_NOPM,
+ 			       7, 0, taiko_codec_enable_micbias,
+ 			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+ 			       SND_SOC_DAPM_POST_PMD),
++>>>>>>> FETCH_HEAD
  	SND_SOC_DAPM_MICBIAS_E("MIC BIAS3 External", SND_SOC_NOPM, 7, 0,
  			       taiko_codec_enable_micbias,
  			       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
@@@ -5946,8 -6110,9 +6310,14 @@@ static irqreturn_t taiko_slimbus_irq(in
  	unsigned long status = 0;
  	int i, j, port_id, k;
  	u32 bit;
++<<<<<<< HEAD
 +	u8 val;
 +	bool tx, cleared;
++=======
+ 	u8 val, int_val = 0;
+ 	bool tx, cleared;
+ 	unsigned short reg = 0;
++>>>>>>> FETCH_HEAD
  
  	for (i = TAIKO_SLIM_PGD_PORT_INT_STATUS_RX_0, j = 0;
  	     i <= TAIKO_SLIM_PGD_PORT_INT_STATUS_TX_1; i++, j++) {
@@@ -5962,12 -6127,28 +6332,37 @@@
  					TAIKO_SLIM_PGD_PORT_INT_RX_SOURCE0 + j);
  		if (val & TAIKO_SLIM_IRQ_OVERFLOW)
  			pr_err_ratelimited(
++<<<<<<< HEAD
 +			    "%s: overflow error on %s port %d, value %x\n",
 +			    __func__, (tx ? "TX" : "RX"), port_id, val);
 +		if (val & TAIKO_SLIM_IRQ_UNDERFLOW)
 +			pr_err_ratelimited(
 +			    "%s: underflow error on %s port %d, value %x\n",
 +			    __func__, (tx ? "TX" : "RX"), port_id, val);
++=======
+ 			   "%s: overflow error on %s port %d, value %x\n",
+ 			   __func__, (tx ? "TX" : "RX"), port_id, val);
+ 		if (val & TAIKO_SLIM_IRQ_UNDERFLOW)
+ 			pr_err_ratelimited(
+ 			   "%s: underflow error on %s port %d, value %x\n",
+ 			   __func__, (tx ? "TX" : "RX"), port_id, val);
+ 		if ((val & TAIKO_SLIM_IRQ_OVERFLOW) ||
+ 			(val & TAIKO_SLIM_IRQ_UNDERFLOW)) {
+ 			if (!tx)
+ 				reg = TAIKO_SLIM_PGD_PORT_INT_EN0 +
+ 					(port_id / 8);
+ 			else
+ 				reg = TAIKO_SLIM_PGD_PORT_INT_TX_EN0 +
+ 					(port_id / 8);
+ 			int_val = wcd9xxx_interface_reg_read(
+ 				codec->control_data, reg);
+ 			if (int_val & (1 << (port_id % 8))) {
+ 				int_val = int_val ^ (1 << (port_id % 8));
+ 				wcd9xxx_interface_reg_write(codec->control_data,
+ 					reg, int_val);
+ 			}
+ 		}
++>>>>>>> FETCH_HEAD
  		if (val & TAIKO_SLIM_IRQ_PORT_CLOSED) {
  			/*
  			 * INT SOURCE register starts from RX to TX
@@@ -6735,7 -6916,7 +7130,11 @@@ static int taiko_setup_zdet(struct wcd9
  		__wr(WCD9XXX_A_CDC_MBHC_TIMER_B5_CTL, 0xFF, 0x10);
  		/* Reset MBHC and set it up for STA */
  		__wr(WCD9XXX_A_CDC_MBHC_CLK_CTL, 0xFF, 0x0A);
++<<<<<<< HEAD
 +		__wr(WCD9XXX_A_CDC_MBHC_EN_CTL, 0xFF, 0x02);
++=======
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_EN_CTL, 0x2);
++>>>>>>> FETCH_HEAD
  		__wr(WCD9XXX_A_CDC_MBHC_CLK_CTL, 0xFF, 0x02);
  
  		/* Set HPH_MBHC for zdet */
@@@ -6829,6 -7010,7 +7228,10 @@@ static int taiko_post_reset_cb(struct w
  	struct snd_soc_codec *codec;
  	struct taiko_priv *taiko;
  	int rco_clk_rate;
++<<<<<<< HEAD
++=======
+ 	int count;
++>>>>>>> FETCH_HEAD
  
  	codec = (struct snd_soc_codec *)(wcd9xxx->ssr_priv);
  	taiko = snd_soc_codec_get_drvdata(codec);
@@@ -6882,6 -7064,9 +7285,12 @@@
  	if (ret)
  		pr_err("%s: Failed to setup irq: %d\n", __func__, ret);
  
++<<<<<<< HEAD
++=======
+ 	for (count = 0; count < NUM_CODEC_DAIS; count++)
+ 		taiko->dai[count].bus_down_in_recovery = true;
+ 
++>>>>>>> FETCH_HEAD
  	mutex_unlock(&codec->mutex);
  	return ret;
  }
@@@ -7183,8 -7368,8 +7592,13 @@@ static int taiko_codec_probe(struct snd
  	snd_soc_dapm_disable_pin(dapm, "ANC HEADPHONE");
  	snd_soc_dapm_disable_pin(dapm, "ANC EAR PA");
  	snd_soc_dapm_disable_pin(dapm, "ANC EAR");
++<<<<<<< HEAD
 +	snd_soc_dapm_sync(dapm);
 +	mutex_unlock(&dapm->codec->mutex);
++=======
+ 	mutex_unlock(&dapm->codec->mutex);
+ 	snd_soc_dapm_sync(dapm);
++>>>>>>> FETCH_HEAD
  
  	codec->ignore_pmdown_time = 1;
  	return ret;
diff --cc sound/soc/codecs/wcd9xxx-common.c
index b104a6b,636a23e..0000000
--- a/sound/soc/codecs/wcd9xxx-common.c
+++ b/sound/soc/codecs/wcd9xxx-common.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -544,6 -544,46 +548,49 @@@ static void wcd9xxx_chargepump_request(
  	}
  }
  
++<<<<<<< HEAD
++=======
+ void wcd9xxx_enable_high_perf_mode(struct snd_soc_codec *codec,
+ 				struct wcd9xxx_clsh_cdc_data *clsh_d,
+ 				u8 req_state, bool req_type)
+ {
+ 	dev_dbg(codec->dev, "%s: users fclk8 %d, fclk5 %d", __func__,
+ 			clsh_d->ncp_users[NCP_FCLK_LEVEL_8],
+ 			clsh_d->ncp_users[NCP_FCLK_LEVEL_5]);
+ 
+ 	if (req_type == WCD9XXX_CLSAB_REQ_ENABLE) {
+ 		clsh_d->ncp_users[NCP_FCLK_LEVEL_8]++;
+ 		snd_soc_update_bits(codec, WCD9XXX_A_RX_HPH_CHOP_CTL,
+ 					0x20, 0x00);
+ 		wcd9xxx_chargepump_request(codec, true);
+ 		wcd9xxx_enable_anc_delay(codec, true);
+ 		if (clsh_d->ncp_users[NCP_FCLK_LEVEL_8] > 0)
+ 			snd_soc_update_bits(codec, WCD9XXX_A_NCP_STATIC,
+ 						0x0F, 0x08);
+ 		snd_soc_update_bits(codec, WCD9XXX_A_NCP_STATIC, 0x30, 0x30);
+ 
+ 		/* Enable NCP and wait until settles down */
+ 		if (snd_soc_update_bits(codec, WCD9XXX_A_NCP_EN, 0x01, 0x01))
+ 			usleep_range(NCP_SETTLE_TIME_US, NCP_SETTLE_TIME_US+10);
+ 	} else {
+ 		snd_soc_update_bits(codec, WCD9XXX_A_RX_HPH_CHOP_CTL,
+ 					0x20, 0x20);
+ 		wcd9xxx_chargepump_request(codec, false);
+ 		wcd9xxx_enable_anc_delay(codec, false);
+ 		clsh_d->ncp_users[NCP_FCLK_LEVEL_8]--;
+ 		if (clsh_d->ncp_users[NCP_FCLK_LEVEL_8] == 0 &&
+ 		    clsh_d->ncp_users[NCP_FCLK_LEVEL_5] == 0)
+ 			snd_soc_update_bits(codec, WCD9XXX_A_NCP_EN,
+ 						0x01, 0x00);
+ 		else if (clsh_d->ncp_users[NCP_FCLK_LEVEL_8] == 0)
+ 			snd_soc_update_bits(codec, WCD9XXX_A_NCP_STATIC,
+ 						0x0F, 0x05);
+ 	}
+ 	dev_dbg(codec->dev, "%s: leave\n", __func__);
+ }
+ EXPORT_SYMBOL(wcd9xxx_enable_high_perf_mode);
+ 
++>>>>>>> FETCH_HEAD
  static int get_impedance_index(u32 imped)
  {
  	int i = 0;
@@@ -651,6 -691,29 +698,32 @@@ void wcd9xxx_restore_registers(struct s
  }
  EXPORT_SYMBOL(wcd9xxx_restore_registers);
  
++<<<<<<< HEAD
++=======
+ static void wcd9xxx_dynamic_bypass_buck_ctrl(struct snd_soc_codec *cdc,
+ 						bool enable)
+ {
+ 	int i;
+ 	const struct wcd9xxx_reg_mask_val reg_set[] = {
+ 		{WCD9XXX_A_BUCK_MODE_3, (0x1 << 3), (enable << 3)},
+ 		{WCD9XXX_A_BUCK_MODE_5, (0x1 << 1), (enable << 1)},
+ 		{WCD9XXX_A_BUCK_MODE_5, 0x1, enable}
+ 	};
+ 	if (!enable) {
+ 		snd_soc_update_bits(cdc, WCD9XXX_A_BUCK_MODE_1,
+ 					(0x1 << 3), 0x00);
+ 		snd_soc_update_bits(cdc, WCD9XXX_A_BUCK_MODE_4,
+ 					0xFF, BUCK_VREF_2V);
+ 	}
+ 	for (i = 0; i < ARRAY_SIZE(reg_set); i++)
+ 		snd_soc_update_bits(cdc, reg_set[i].reg, reg_set[i].mask,
+ 							reg_set[i].val);
+ 
+ 	/* 50us sleep is reqd. as per the class H HW design sequence */
+ 	usleep_range(BUCK_SETTLE_TIME_US, BUCK_SETTLE_TIME_US+10);
+ }
+ 
++>>>>>>> FETCH_HEAD
  static void wcd9xxx_set_buck_mode(struct snd_soc_codec *codec, u8 buck_vref)
  {
  	int i;
@@@ -807,6 -870,239 +880,242 @@@ static void wcd9xxx_cfg_clsh_param_hph(
  			 __func__);
  }
  
++<<<<<<< HEAD
++=======
+ static void wcd9xxx_ncp_bypass_enable(struct snd_soc_codec *cdc, bool enable)
+ {
+ 	snd_soc_update_bits(cdc, WCD9XXX_A_NCP_STATIC, 0x10, (enable << 4));
+ 	/* 50us sleep is reqd. as per the class H HW design sequence */
+ 	usleep_range(BUCK_SETTLE_TIME_US, BUCK_SETTLE_TIME_US+10);
+ }
+ 
+ static void wcd9xxx_clsh_set_Iest(struct snd_soc_codec *codec,
+ 		u8 value)
+ {
+ 	snd_soc_update_bits(codec, WCD9XXX_A_BUCK_MODE_5,
+ 				    0x01, (0x01 & 0x03));
+ 	snd_soc_update_bits(codec, WCD9XXX_A_BUCK_MODE_5,
+ 				    0xFC, (value << 2));
+ }
+ 
+ static void wcd9xxx_clsh_state_hph_ear(struct snd_soc_codec *codec,
+ 			struct wcd9xxx_clsh_cdc_data *clsh_d,
+ 			u8 req_state, bool is_enable)
+ {
+ 	int compute_pa = 0;
+ 
+ 	dev_dbg(codec->dev, "%s: enter %s\n", __func__,
+ 			is_enable ? "enable" : "disable");
+ 
+ 	if (is_enable) {
+ 		/*
+ 		 * The below check condition is required to make sure
+ 		 * functions inside if condition will execute only once.
+ 		 */
+ 		if ((clsh_d->state == WCD9XXX_CLSH_STATE_EAR) ||
+ 			(req_state == WCD9XXX_CLSH_STATE_EAR)) {
+ 			wcd9xxx_dynamic_bypass_buck_ctrl(codec, false);
+ 			wcd9xxx_ncp_bypass_enable(codec, true);
+ 		}
+ 		switch (req_state) {
+ 		case WCD9XXX_CLSH_STATE_HPHL:
+ 			compute_pa = CLSH_COMPUTE_HPH_L;
+ 			break;
+ 		case WCD9XXX_CLSH_STATE_HPHR:
+ 			compute_pa = CLSH_COMPUTE_HPH_R;
+ 			break;
+ 		case WCD9XXX_CLSH_STATE_EAR:
+ 			compute_pa = CLSH_COMPUTE_EAR;
+ 			break;
+ 		default:
+ 			dev_dbg(codec->dev,
+ 				"%s:Invalid state:0x%x,enable:0x%x\n",
+ 				__func__, req_state, is_enable);
+ 			break;
+ 		}
+ 		wcd9xxx_clsh_comp_req(codec, clsh_d, compute_pa, true);
+ 
+ 		dev_dbg(codec->dev, "%s: Enabled hph+ear mode clsh\n",
+ 				__func__);
+ 	} else {
+ 		switch (req_state) {
+ 		case WCD9XXX_CLSH_STATE_HPHL:
+ 			compute_pa = CLSH_COMPUTE_HPH_L;
+ 			break;
+ 		case WCD9XXX_CLSH_STATE_HPHR:
+ 			compute_pa = CLSH_COMPUTE_HPH_R;
+ 			break;
+ 		case WCD9XXX_CLSH_STATE_EAR:
+ 			compute_pa = CLSH_COMPUTE_EAR;
+ 			break;
+ 		default:
+ 			dev_dbg(codec->dev,
+ 				"%s:Invalid state:0x%x,enable:0x%x\n",
+ 				__func__, req_state, is_enable);
+ 			break;
+ 		}
+ 		wcd9xxx_clsh_comp_req(codec, clsh_d, compute_pa, false);
+ 
+ 		if (((clsh_d->state & (~req_state)) ==
+ 				WCD9XXX_CLSH_STATE_EAR) ||
+ 			(req_state == WCD9XXX_CLSH_STATE_EAR)) {
+ 			wcd9xxx_ncp_bypass_enable(codec, false);
+ 			wcd9xxx_dynamic_bypass_buck_ctrl(codec, true);
+ 		}
+ 	}
+ }
+ 
+ static void wcd9xxx_clsh_state_hph_lo(struct snd_soc_codec *codec,
+ 			struct wcd9xxx_clsh_cdc_data *clsh_d,
+ 			u8 req_state, bool is_enable)
+ {
+ 
+ 	dev_dbg(codec->dev, "%s: enter %s\n", __func__,
+ 			is_enable ? "enable" : "disable");
+ 	if (is_enable) {
+ 		if ((clsh_d->state == WCD9XXX_CLSH_STATE_LO) ||
+ 			(req_state == WCD9XXX_CLSH_STATE_LO)) {
+ 			wcd9xxx_dynamic_bypass_buck_ctrl(codec, false);
+ 			wcd9xxx_enable_buck(codec, clsh_d, true);
+ 			wcd9xxx_set_fclk_get_ncp(codec, clsh_d,
+ 						NCP_FCLK_LEVEL_8);
+ 			if (req_state & WCD9XXX_CLSH_STATE_HPH_ST) {
+ 				wcd9xxx_ncp_bypass_enable(codec, true);
+ 				wcd9xxx_enable_clsh_block(codec, clsh_d, true);
+ 				wcd9xxx_chargepump_request(codec, true);
+ 				wcd9xxx_enable_anc_delay(codec, true);
+ 			}
+ 		}
+ 		if (req_state == WCD9XXX_CLSH_STATE_HPHL)
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_L, true);
+ 		if (req_state == WCD9XXX_CLSH_STATE_HPHR)
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_R, true);
+ 	} else {
+ 		switch (req_state) {
+ 		case WCD9XXX_CLSH_STATE_LO:
+ 			snd_soc_update_bits(codec, WCD9XXX_A_NCP_STATIC,
+ 						0x20, 0x00);
+ 			wcd9xxx_dynamic_bypass_buck_ctrl(codec, true);
+ 			break;
+ 		case WCD9XXX_CLSH_STATE_HPHL:
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_L, false);
+ 			break;
+ 		case WCD9XXX_CLSH_STATE_HPHR:
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_R, false);
+ 			break;
+ 		default:
+ 			dev_dbg(codec->dev,
+ 				 "%s:Invalid state:0x%x,enable:0x%x\n",
+ 				__func__, req_state, is_enable);
+ 			break;
+ 		}
+ 		if ((req_state == WCD9XXX_CLSH_STATE_LO) ||
+ 		((clsh_d->state & (~req_state)) == WCD9XXX_CLSH_STATE_LO)) {
+ 			wcd9xxx_set_fclk_put_ncp(codec, clsh_d,
+ 						NCP_FCLK_LEVEL_8);
+ 			wcd9xxx_ncp_bypass_enable(codec, false);
+ 
+ 			if (req_state & WCD9XXX_CLSH_STATE_HPH_ST) {
+ 				usleep_range(BUCK_SETTLE_TIME_US,
+ 						BUCK_SETTLE_TIME_US + 10);
+ 				if (clsh_d->buck_mv ==
+ 						WCD9XXX_CDC_BUCK_MV_1P8) {
+ 					wcd9xxx_enable_buck(codec, clsh_d,
+ 								false);
+ 					wcd9xxx_ncp_bypass_enable(codec, true);
+ 				} else {
+ 					/*
+ 					 *NCP settle time recommended by codec
+ 					 *specification
+ 					 */
+ 					usleep_range(NCP_SETTLE_TIME_US,
+ 						NCP_SETTLE_TIME_US + 10);
+ 					wcd9xxx_clsh_set_Iest(codec, 0x02);
+ 				}
+ 				snd_soc_update_bits(codec,
+ 						WCD9XXX_A_BUCK_MODE_1,
+ 						0x04, 0x00);
+ 				snd_soc_update_bits(codec,
+ 						 WCD9XXX_A_BUCK_MODE_4,
+ 						0xFF, BUCK_VREF_1P8V);
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static void wcd9xxx_clsh_state_ear_lo(struct snd_soc_codec *codec,
+ 			struct wcd9xxx_clsh_cdc_data *clsh_d,
+ 			u8 req_state, bool is_enable)
+ {
+ 
+ 	dev_dbg(codec->dev, "%s: enter %s\n", __func__,
+ 			is_enable ? "enable" : "disable");
+ 	if (is_enable) {
+ 		wcd9xxx_dynamic_bypass_buck_ctrl(codec, false);
+ 		wcd9xxx_enable_buck(codec, clsh_d, true);
+ 		if (req_state & WCD9XXX_CLSH_STATE_EAR) {
+ 			wcd9xxx_set_fclk_get_ncp(codec, clsh_d,
+ 						NCP_FCLK_LEVEL_8);
+ 			wcd9xxx_ncp_bypass_enable(codec, true);
+ 			wcd9xxx_enable_clsh_block(codec, clsh_d, true);
+ 			wcd9xxx_chargepump_request(codec, true);
+ 			wcd9xxx_enable_anc_delay(codec, true);
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_EAR, true);
+ 		}
+ 	} else {
+ 		wcd9xxx_set_fclk_put_ncp(codec, clsh_d, NCP_FCLK_LEVEL_8);
+ 		wcd9xxx_ncp_bypass_enable(codec, false);
+ 		if (req_state & WCD9XXX_CLSH_STATE_LO) {
+ 			snd_soc_update_bits(codec, WCD9XXX_A_NCP_STATIC,
+ 						0x20, 0x00);
+ 			wcd9xxx_dynamic_bypass_buck_ctrl(codec, true);
+ 		} else if (req_state & WCD9XXX_CLSH_STATE_EAR) {
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_EAR,
+ 						false);
+ 			/*sleep 5ms*/
+ 			if (clsh_d->buck_mv == WCD9XXX_CDC_BUCK_MV_1P8) {
+ 				wcd9xxx_enable_buck(codec, clsh_d, false);
+ 				wcd9xxx_ncp_bypass_enable(codec, true);
+ 			} else {
+ 				/* NCP settle time recommended by codec	spec */
+ 				usleep_range(NCP_SETTLE_TIME_US,
+ 					     NCP_SETTLE_TIME_US + 10);
+ 				wcd9xxx_clsh_set_Iest(codec, 0x02);
+ 			}
+ 			snd_soc_update_bits(codec, WCD9XXX_A_BUCK_MODE_1,
+ 						0x04, 0x00);
+ 			snd_soc_update_bits(codec, WCD9XXX_A_BUCK_MODE_4,
+ 						0xFF, BUCK_VREF_1P8V);
+ 		}
+ 	}
+ }
+ 
+ static void wcd9xxx_clsh_state_hph_ear_lo(struct snd_soc_codec *codec,
+ 			struct wcd9xxx_clsh_cdc_data *clsh_d,
+ 			u8 req_state, bool is_enable)
+ {
+ 	dev_dbg(codec->dev, "%s: enter %s\n", __func__,
+ 			is_enable ? "enable" : "disable");
+ 
+ 	if (req_state & WCD9XXX_CLSH_STATE_HPHL)
+ 		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_HPH_L,
+ 					is_enable);
+ 
+ 	if (req_state & WCD9XXX_CLSH_STATE_HPHR)
+ 		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_HPH_R,
+ 					is_enable);
+ 
+ 	if (req_state & WCD9XXX_CLSH_STATE_EAR)
+ 		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_EAR,
+ 					is_enable);
+ }
+ 
++>>>>>>> FETCH_HEAD
  static void wcd9xxx_clsh_state_ear(struct snd_soc_codec *codec,
  			struct wcd9xxx_clsh_cdc_data *clsh_d,
  			u8 req_state, bool is_enable)
@@@ -828,7 -1124,7 +1137,11 @@@
  		dev_dbg(codec->dev, "%s: stub fallback to ear\n", __func__);
  		wcd9xxx_set_fclk_put_ncp(codec, clsh_d, NCP_FCLK_LEVEL_8);
  		wcd9xxx_enable_buck(codec, clsh_d, false);
++<<<<<<< HEAD
 +		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_EAR, true);
++=======
+ 		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_EAR, false);
++>>>>>>> FETCH_HEAD
  		wcd9xxx_chargepump_request(codec, false);
  		wcd9xxx_enable_clsh_block(codec, clsh_d, false);
  	}
@@@ -895,10 -1191,20 +1208,27 @@@ static void wcd9xxx_clsh_state_hph_st(s
  	pr_debug("%s: enter %s\n", __func__, is_enable ? "enable" : "disable");
  
  	if (is_enable) {
++<<<<<<< HEAD
 +		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_HPH_L, true);
 +		wcd9xxx_clsh_comp_req(codec, clsh_d, CLSH_COMPUTE_HPH_R, true);
 +	} else {
 +		dev_dbg(codec->dev, "%s: stub fallback to hph_st\n", __func__);
++=======
+ 		if (req_state == WCD9XXX_CLSH_STATE_HPHL)
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_L, true);
+ 		if (req_state == WCD9XXX_CLSH_STATE_HPHR)
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_R, true);
+ 	} else {
+ 		dev_dbg(codec->dev, "%s: stub fallback to hph_st\n", __func__);
+ 		if (req_state == WCD9XXX_CLSH_STATE_HPHL)
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_L, false);
+ 		if (req_state == WCD9XXX_CLSH_STATE_HPHR)
+ 			wcd9xxx_clsh_comp_req(codec, clsh_d,
+ 						CLSH_COMPUTE_HPH_R, false);
++>>>>>>> FETCH_HEAD
  	}
  }
  
@@@ -952,6 -1258,47 +1282,50 @@@ static void wcd9xxx_clsh_state_err(stru
  	WARN_ON(1);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Function: wcd9xxx_clsh_is_state_valid
+  * Params: state
+  * Description:
+  * Provides information on valid states of Class H configuration
+  */
+ static int wcd9xxx_clsh_is_state_valid(u8 state)
+ {
+ 	switch (state) {
+ 	case WCD9XXX_CLSH_STATE_IDLE:
+ 	case WCD9XXX_CLSH_STATE_EAR:
+ 	case WCD9XXX_CLSH_STATE_HPHL:
+ 	case WCD9XXX_CLSH_STATE_HPHR:
+ 	case WCD9XXX_CLSH_STATE_HPH_ST:
+ 	case WCD9XXX_CLSH_STATE_LO:
+ 	case WCD9XXX_CLSH_STATE_HPHL_EAR:
+ 	case WCD9XXX_CLSH_STATE_HPHR_EAR:
+ 	case WCD9XXX_CLSH_STATE_HPH_ST_EAR:
+ 	case WCD9XXX_CLSH_STATE_HPHL_LO:
+ 	case WCD9XXX_CLSH_STATE_HPHR_LO:
+ 	case WCD9XXX_CLSH_STATE_HPH_ST_LO:
+ 	case WCD9XXX_CLSH_STATE_EAR_LO:
+ 	case WCD9XXX_CLSH_STATE_HPHL_EAR_LO:
+ 	case WCD9XXX_CLSH_STATE_HPHR_EAR_LO:
+ 	case WCD9XXX_CLSH_STATE_HPH_ST_EAR_LO:
+ 		return 1;
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Function: wcd9xxx_clsh_fsm
+  * Params: codec, cdc_clsh_d, req_state, req_type, clsh_event
+  * Description:
+  * This function handles PRE DAC and POST DAC conditions of different devices
+  * and updates class H configuration of different combination of devices
+  * based on validity of their states. cdc_clsh_d will contain current
+  * class h state information
+  */
++>>>>>>> FETCH_HEAD
  void wcd9xxx_clsh_fsm(struct snd_soc_codec *codec,
  		struct wcd9xxx_clsh_cdc_data *cdc_clsh_d,
  		u8 req_state, bool req_type, u8 clsh_event)
@@@ -967,10 -1314,25 +1341,32 @@@
  		old_state = cdc_clsh_d->state;
  		new_state = old_state | req_state;
  
++<<<<<<< HEAD
 +		(*clsh_state_fp[req_state]) (codec, cdc_clsh_d, req_state,
 +					     req_type);
 +		cdc_clsh_d->state = new_state;
 +		dev_dbg(codec->dev, "%s: ClassH state transition from %s to %s\n",
++=======
+ 		if (!wcd9xxx_clsh_is_state_valid(new_state)) {
+ 			dev_dbg(codec->dev,
+ 				"%s: classH not a valid new state: %s\n",
+ 				__func__,
+ 				state_to_str(new_state, msg0, sizeof(msg0)));
+ 			return;
+ 		}
+ 		if (new_state == old_state) {
+ 			dev_dbg(codec->dev,
+ 				"%s: classH already in requested state: %s\n",
+ 				__func__,
+ 				state_to_str(new_state, msg0, sizeof(msg0)));
+ 			return;
+ 		}
+ 		(*clsh_state_fp[new_state]) (codec, cdc_clsh_d, req_state,
+ 					     req_type);
+ 		cdc_clsh_d->state = new_state;
+ 		dev_dbg(codec->dev,
+ 			"%s: ClassH state transition from %s to %s\n",
++>>>>>>> FETCH_HEAD
  			__func__, state_to_str(old_state, msg0, sizeof(msg0)),
  			state_to_str(cdc_clsh_d->state, msg1, sizeof(msg1)));
  
@@@ -981,7 -1343,23 +1377,27 @@@
  			new_state = old_state & (~req_state);
  
  			if (new_state < NUM_CLSH_STATES) {
++<<<<<<< HEAD
 +				(*clsh_state_fp[req_state]) (codec, cdc_clsh_d,
++=======
+ 				if (!wcd9xxx_clsh_is_state_valid(old_state)) {
+ 					dev_dbg(codec->dev,
+ 						"%s:Invalid old state:%s\n",
+ 						__func__,
+ 						state_to_str(old_state, msg0,
+ 						sizeof(msg0)));
+ 					return;
+ 				}
+ 				if (new_state == old_state) {
+ 					dev_dbg(codec->dev,
+ 					"%s: clsH already in old state: %s\n",
+ 					__func__,
+ 					state_to_str(new_state, msg0,
+ 					sizeof(msg0)));
+ 					return;
+ 				}
+ 				(*clsh_state_fp[old_state]) (codec, cdc_clsh_d,
++>>>>>>> FETCH_HEAD
  							     req_state,
  							     req_type);
  				cdc_clsh_d->state = new_state;
@@@ -992,7 -1370,7 +1408,11 @@@
  						     sizeof(msg1)));
  
  			} else {
++<<<<<<< HEAD
 +				dev_dbg(codec->dev, "%s: wrong new state = %x\n",
++=======
+ 				dev_dbg(codec->dev, "%s:wrong new state=0x%x\n",
++>>>>>>> FETCH_HEAD
  						__func__, new_state);
  			}
  		} else if (!(cdc_clsh_d->state & WCD9XXX_CLSH_STATE_LO)) {
@@@ -1023,6 -1401,23 +1443,26 @@@ void wcd9xxx_clsh_init(struct wcd9xxx_c
  	clsh_state_fp[WCD9XXX_CLSH_STATE_HPH_ST] =
  						wcd9xxx_clsh_state_hph_st;
  	clsh_state_fp[WCD9XXX_CLSH_STATE_LO] = wcd9xxx_clsh_state_lo;
++<<<<<<< HEAD
++=======
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPHL_EAR] =
+ 						wcd9xxx_clsh_state_hph_ear;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPHR_EAR] =
+ 						wcd9xxx_clsh_state_hph_ear;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPH_ST_EAR] =
+ 						wcd9xxx_clsh_state_hph_ear;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPHL_LO] = wcd9xxx_clsh_state_hph_lo;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPHR_LO] = wcd9xxx_clsh_state_hph_lo;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPH_ST_LO] =
+ 						wcd9xxx_clsh_state_hph_lo;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_EAR_LO] = wcd9xxx_clsh_state_ear_lo;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPHL_EAR_LO] =
+ 						wcd9xxx_clsh_state_hph_ear_lo;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPHR_EAR_LO] =
+ 						wcd9xxx_clsh_state_hph_ear_lo;
+ 	clsh_state_fp[WCD9XXX_CLSH_STATE_HPH_ST_EAR_LO] =
+ 						wcd9xxx_clsh_state_hph_ear_lo;
++>>>>>>> FETCH_HEAD
  
  }
  EXPORT_SYMBOL_GPL(wcd9xxx_clsh_init);
diff --cc sound/soc/codecs/wcd9xxx-common.h
index 324f6e9,4b3ad10..0000000
--- a/sound/soc/codecs/wcd9xxx-common.h
+++ b/sound/soc/codecs/wcd9xxx-common.h
@@@ -35,7 -35,14 +35,18 @@@
  #define	WCD9XXX_CLSH_STATE_HPHL (0x01 << 1)
  #define	WCD9XXX_CLSH_STATE_HPHR (0x01 << 2)
  #define	WCD9XXX_CLSH_STATE_LO (0x01 << 3)
++<<<<<<< HEAD
 +#define NUM_CLSH_STATES ((0x01 << 4) - 1)
++=======
+ #define NUM_CLSH_STATES (0x01 << 4)
+ 
+ #define	WCD9XXX_CLSAB_STATE_IDLE  0x00
+ #define WCD9XXX_CLSAB_STATE_HPHL (0x01 << 1)
+ #define WCD9XXX_CLSAB_STATE_HPHR (0x01 << 2)
+ 
+ #define WCD9XXX_CLSAB_REQ_ENABLE  true
+ #define WCD9XXX_CLSAB_REQ_DISABLE false
++>>>>>>> FETCH_HEAD
  
  #define WCD9XXX_DMIC_SAMPLE_RATE_DIV_2    0x0
  #define WCD9XXX_DMIC_SAMPLE_RATE_DIV_3    0x1
@@@ -56,6 -63,34 +67,37 @@@
  #define WCD9XXX_CLSH_STATE_HPH_ST (WCD9XXX_CLSH_STATE_HPHL | \
  						WCD9XXX_CLSH_STATE_HPHR)
  
++<<<<<<< HEAD
++=======
+ #define WCD9XXX_CLSH_STATE_HPHL_EAR (WCD9XXX_CLSH_STATE_HPHL | \
+ 						WCD9XXX_CLSH_STATE_EAR)
+ #define WCD9XXX_CLSH_STATE_HPHR_EAR (WCD9XXX_CLSH_STATE_HPHR | \
+ 						WCD9XXX_CLSH_STATE_EAR)
+ 
+ #define WCD9XXX_CLSH_STATE_HPH_ST_EAR (WCD9XXX_CLSH_STATE_HPH_ST | \
+ 						WCD9XXX_CLSH_STATE_EAR)
+ 
+ #define WCD9XXX_CLSH_STATE_HPHL_LO (WCD9XXX_CLSH_STATE_HPHL | \
+ 						WCD9XXX_CLSH_STATE_LO)
+ #define WCD9XXX_CLSH_STATE_HPHR_LO (WCD9XXX_CLSH_STATE_HPHR | \
+ 						WCD9XXX_CLSH_STATE_LO)
+ 
+ #define WCD9XXX_CLSH_STATE_HPH_ST_LO (WCD9XXX_CLSH_STATE_HPH_ST | \
+ 						WCD9XXX_CLSH_STATE_LO)
+ 
+ #define WCD9XXX_CLSH_STATE_EAR_LO (WCD9XXX_CLSH_STATE_EAR | \
+ 						WCD9XXX_CLSH_STATE_LO)
+ 
+ #define WCD9XXX_CLSH_STATE_HPHL_EAR_LO (WCD9XXX_CLSH_STATE_HPHL | \
+ 						WCD9XXX_CLSH_STATE_EAR | \
+ 						WCD9XXX_CLSH_STATE_LO)
+ #define WCD9XXX_CLSH_STATE_HPHR_EAR_LO (WCD9XXX_CLSH_STATE_HPHR | \
+ 						WCD9XXX_CLSH_STATE_EAR | \
+ 						WCD9XXX_CLSH_STATE_LO)
+ #define WCD9XXX_CLSH_STATE_HPH_ST_EAR_LO (WCD9XXX_CLSH_STATE_HPH_ST | \
+ 						WCD9XXX_CLSH_STATE_EAR | \
+ 						WCD9XXX_CLSH_STATE_LO)
++>>>>>>> FETCH_HEAD
  
  struct wcd9xxx_reg_mask_val {
  	u16	reg;
@@@ -95,6 -130,10 +137,13 @@@ extern void wcd9xxx_clsh_fsm(struct snd
  		struct wcd9xxx_clsh_cdc_data *cdc_clsh_d,
  		u8 req_state, bool req_type, u8 clsh_event);
  
++<<<<<<< HEAD
++=======
+ extern void wcd9xxx_enable_high_perf_mode(struct snd_soc_codec *codec,
+ 				struct wcd9xxx_clsh_cdc_data *clsh_d,
+ 				u8 req_state, bool req_type);
+ 
++>>>>>>> FETCH_HEAD
  extern void wcd9xxx_clsh_init(struct wcd9xxx_clsh_cdc_data *clsh,
  			      struct wcd9xxx_resmgr *resmgr);
  
diff --cc sound/soc/codecs/wcd9xxx-mbhc.c
index 0200b6d,70907d0..0000000
--- a/sound/soc/codecs/wcd9xxx-mbhc.c
+++ b/sound/soc/codecs/wcd9xxx-mbhc.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -44,7 -44,7 +48,11 @@@
  
  #define WCD9XXX_JACK_MASK (SND_JACK_HEADSET | SND_JACK_OC_HPHL | \
  			   SND_JACK_OC_HPHR | SND_JACK_LINEOUT | \
++<<<<<<< HEAD
 +			   SND_JACK_UNSUPPORTED)
++=======
+ 			   SND_JACK_UNSUPPORTED | SND_JACK_MICROPHONE2)
++>>>>>>> FETCH_HEAD
  #define WCD9XXX_JACK_BUTTON_MASK (SND_JACK_BTN_0 | SND_JACK_BTN_1 | \
  				  SND_JACK_BTN_2 | SND_JACK_BTN_3 | \
  				  SND_JACK_BTN_4 | SND_JACK_BTN_5 | \
@@@ -65,6 -65,7 +73,10 @@@
  #define STATUS_REL_DETECTION 0x0C
  
  #define HS_DETECT_PLUG_TIME_MS (5 * 1000)
++<<<<<<< HEAD
++=======
+ #define ANC_HPH_DETECT_PLUG_TIME_MS (5 * 1000)
++>>>>>>> FETCH_HEAD
  #define HS_DETECT_PLUG_INERVAL_MS 100
  #define SWCH_REL_DEBOUNCE_TIME_MS 50
  #define SWCH_IRQ_DEBOUNCE_TIME_US 5000
@@@ -99,7 -100,7 +111,11 @@@
   * Invalid voltage range for the detection
   * of plug type with current source
   */
++<<<<<<< HEAD
 +#define WCD9XXX_CS_MEAS_INVALD_RANGE_LOW_MV 110
++=======
+ #define WCD9XXX_CS_MEAS_INVALD_RANGE_LOW_MV 160
++>>>>>>> FETCH_HEAD
  #define WCD9XXX_CS_MEAS_INVALD_RANGE_HIGH_MV 265
  
  /*
@@@ -122,7 -123,7 +138,11 @@@
  #define WCD9XXX_V_CS_HS_MAX 500
  #define WCD9XXX_V_CS_NO_MIC 5
  #define WCD9XXX_MB_MEAS_DELTA_MAX_MV 80
++<<<<<<< HEAD
 +#define WCD9XXX_CS_MEAS_DELTA_MAX_MV 10
++=======
+ #define WCD9XXX_CS_MEAS_DELTA_MAX_MV 12
++>>>>>>> FETCH_HEAD
  
  static int impedance_detect_en;
  module_param(impedance_detect_en, int,
@@@ -182,7 -183,10 +202,14 @@@ static int wcd9xxx_detect_impedance(str
  				    uint32_t *zr);
  static s16 wcd9xxx_get_current_v(struct wcd9xxx_mbhc *mbhc,
  				 const enum wcd9xxx_current_v_idx idx);
++<<<<<<< HEAD
 +static void wcd9xxx_get_z(struct wcd9xxx_mbhc *mbhc, s16 *dce_z, s16 *sta_z);
++=======
+ static void wcd9xxx_get_z(struct wcd9xxx_mbhc *mbhc, s16 *dce_z, s16 *sta_z,
+ 			  struct mbhc_micbias_regs *micb_regs,
+ 			  bool norel);
+ 
++>>>>>>> FETCH_HEAD
  static void wcd9xxx_mbhc_calc_thres(struct wcd9xxx_mbhc *mbhc);
  
  static bool wcd9xxx_mbhc_polling(struct wcd9xxx_mbhc *mbhc)
@@@ -216,7 -220,6 +243,10 @@@ static void wcd9xxx_pause_hs_polling(st
  /* called under codec_resource_lock acquisition */
  static void wcd9xxx_start_hs_polling(struct wcd9xxx_mbhc *mbhc)
  {
++<<<<<<< HEAD
 +	s16 v_brh, v_b1_hu;
++=======
++>>>>>>> FETCH_HEAD
  	struct snd_soc_codec *codec = mbhc->codec;
  	int mbhc_state = mbhc->mbhc_state;
  
@@@ -257,17 -260,6 +287,20 @@@
  		/* set to max */
  		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL, 0x7F);
  		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL, 0xFF);
++<<<<<<< HEAD
 +
 +		v_brh = wcd9xxx_get_current_v(mbhc, WCD9XXX_CURRENT_V_BR_H);
 +		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
 +			      (v_brh >> 8) & 0xFF);
 +		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL,
 +			      v_brh & 0xFF);
 +		v_b1_hu = wcd9xxx_get_current_v(mbhc, WCD9XXX_CURRENT_V_B1_HU);
 +		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL,
 +			      v_b1_hu & 0xFF);
 +		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
 +			      (v_b1_hu >> 8) & 0xFF);
++=======
++>>>>>>> FETCH_HEAD
  	}
  
  	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_EN_CTL, 0x1);
@@@ -328,22 -320,32 +361,51 @@@ static bool __wcd9xxx_switch_micbias(st
  			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B2_CTL,
  				      (d->v_ins_hu[MBHC_V_IDX_VDDIO] >> 8) &
  				      0xFF);
++<<<<<<< HEAD
 +			/* Threshods for button press */
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL,
 +				      d->v_b1_hu[MBHC_V_IDX_VDDIO] & 0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
 +				      (d->v_b1_hu[MBHC_V_IDX_VDDIO] >> 8) &
 +				      0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL,
 +				      d->v_b1_h[MBHC_V_IDX_VDDIO] & 0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL,
 +				      (d->v_b1_h[MBHC_V_IDX_VDDIO] >> 8) &
 +				      0xFF);
 +			/* Threshods for button release */
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL,
 +				      d->v_brh[MBHC_V_IDX_VDDIO] & 0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
 +				      (d->v_brh[MBHC_V_IDX_VDDIO] >> 8) & 0xFF);
++=======
+ 
+ 			if (mbhc->mbhc_state != MBHC_STATE_POTENTIAL_RECOVERY) {
+ 				/* Threshods for button press */
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL,
+ 					d->v_b1_hu[MBHC_V_IDX_VDDIO] & 0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
+ 					(d->v_b1_hu[MBHC_V_IDX_VDDIO] >> 8) &
+ 					0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL,
+ 					d->v_b1_h[MBHC_V_IDX_VDDIO] & 0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL,
+ 					(d->v_b1_h[MBHC_V_IDX_VDDIO] >> 8) &
+ 					0xFF);
+ 				/* Threshods for button release */
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL,
+ 					d->v_brh[MBHC_V_IDX_VDDIO] & 0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
+ 					(d->v_brh[MBHC_V_IDX_VDDIO] >> 8) &
+ 					0xFF);
+ 			}
++>>>>>>> FETCH_HEAD
  			pr_debug("%s: Programmed MBHC thresholds to VDDIO\n",
  				 __func__);
  		}
@@@ -379,22 -381,31 +441,50 @@@
  			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B2_CTL,
  					(d->v_ins_hu[MBHC_V_IDX_CFILT] >> 8) &
  					0xFF);
++<<<<<<< HEAD
 +			/* Revert threshods for button press */
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL,
 +				      d->v_b1_hu[MBHC_V_IDX_CFILT] & 0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
 +				      (d->v_b1_hu[MBHC_V_IDX_CFILT] >> 8) &
 +				      0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL,
 +				      d->v_b1_h[MBHC_V_IDX_CFILT] & 0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL,
 +				      (d->v_b1_h[MBHC_V_IDX_CFILT] >> 8) &
 +				      0xFF);
 +			/* Revert threshods for button release */
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL,
 +				      d->v_brh[MBHC_V_IDX_CFILT] & 0xFF);
 +			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
 +				      (d->v_brh[MBHC_V_IDX_CFILT] >> 8) & 0xFF);
++=======
+ 			if (mbhc->mbhc_state != MBHC_STATE_POTENTIAL_RECOVERY) {
+ 				/* Revert threshods for button press */
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL,
+ 					d->v_b1_hu[MBHC_V_IDX_CFILT] & 0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
+ 					(d->v_b1_hu[MBHC_V_IDX_CFILT] >> 8) &
+ 					0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL,
+ 					d->v_b1_h[MBHC_V_IDX_CFILT] & 0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL,
+ 					(d->v_b1_h[MBHC_V_IDX_CFILT] >> 8) &
+ 					0xFF);
+ 				/* Revert threshods for button release */
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL,
+ 					d->v_brh[MBHC_V_IDX_CFILT] & 0xFF);
+ 				snd_soc_write(codec,
+ 					WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
+ 					(d->v_brh[MBHC_V_IDX_CFILT] >> 8) &
+ 					0xFF);
+ 			}
++>>>>>>> FETCH_HEAD
  			pr_debug("%s: Programmed MBHC thresholds to MICBIAS\n",
  					__func__);
  		}
@@@ -492,19 -503,25 +582,41 @@@ static void wcd9xxx_calibrate_hs_pollin
  	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B1_CTL, v_ins_hu & 0xFF);
  	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B2_CTL,
  		      (v_ins_hu >> 8) & 0xFF);
++<<<<<<< HEAD
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL, v_b1_hu & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
 +		      (v_b1_hu >> 8) & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL, v_b1_h & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL,
 +		      (v_b1_h >> 8) & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL, v_brh & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
 +		      (v_brh >> 8) & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B11_CTL,
 +		      mbhc->mbhc_data.v_brl & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B12_CTL,
 +		      (mbhc->mbhc_data.v_brl >> 8) & 0xFF);
++=======
+ 
+ 	if (mbhc->mbhc_state != MBHC_STATE_POTENTIAL_RECOVERY) {
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL, v_b1_hu &
+ 				0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
+ 				(v_b1_hu >> 8) & 0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B5_CTL, v_b1_h &
+ 				0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B6_CTL,
+ 				(v_b1_h >> 8) & 0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL, v_brh &
+ 				0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
+ 				(v_brh >> 8) & 0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B11_CTL,
+ 				mbhc->mbhc_data.v_brl & 0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B12_CTL,
+ 				(mbhc->mbhc_data.v_brl >> 8) & 0xFF);
+ 	}
++>>>>>>> FETCH_HEAD
  }
  
  static void wcd9xxx_codec_switch_cfilt_mode(struct wcd9xxx_mbhc *mbhc,
@@@ -600,13 -617,23 +712,32 @@@ static void hphlocp_off_report(struct w
  }
  
  static void wcd9xxx_get_mbhc_micbias_regs(struct wcd9xxx_mbhc *mbhc,
++<<<<<<< HEAD
 +					struct mbhc_micbias_regs *micbias_regs)
++=======
+ 				enum wcd9xxx_mbhc_micbias_type mb_type)
++>>>>>>> FETCH_HEAD
  {
  	unsigned int cfilt;
  	struct wcd9xxx_micbias_setting *micbias_pdata =
  		mbhc->resmgr->micbias_pdata;
++<<<<<<< HEAD
 +
 +	switch (mbhc->mbhc_cfg->micbias) {
++=======
+ 	struct mbhc_micbias_regs *micbias_regs;
+ 	enum wcd9xxx_micbias_num mb_num;
+ 
+ 	if (mb_type == MBHC_ANC_MIC_MB) {
+ 		micbias_regs = &mbhc->mbhc_anc_bias_regs;
+ 		mb_num = mbhc->mbhc_cfg->anc_micbias;
+ 	} else {
+ 		micbias_regs = &mbhc->mbhc_bias_regs;
+ 		mb_num = mbhc->mbhc_cfg->micbias;
+ 	}
+ 
+ 	switch (mb_num) {
++>>>>>>> FETCH_HEAD
  	case MBHC_MICBIAS1:
  		cfilt = micbias_pdata->bias1_cfilt_sel;
  		micbias_regs->mbhc_reg = WCD9XXX_A_MICB_1_MBHC;
@@@ -644,19 -671,31 +775,45 @@@
  	case WCD9XXX_CFILT1_SEL:
  		micbias_regs->cfilt_val = WCD9XXX_A_MICB_CFILT_1_VAL;
  		micbias_regs->cfilt_ctl = WCD9XXX_A_MICB_CFILT_1_CTL;
++<<<<<<< HEAD
 +		mbhc->mbhc_data.micb_mv = micbias_pdata->cfilt1_mv;
++=======
++>>>>>>> FETCH_HEAD
  		break;
  	case WCD9XXX_CFILT2_SEL:
  		micbias_regs->cfilt_val = WCD9XXX_A_MICB_CFILT_2_VAL;
  		micbias_regs->cfilt_ctl = WCD9XXX_A_MICB_CFILT_2_CTL;
++<<<<<<< HEAD
 +		mbhc->mbhc_data.micb_mv = micbias_pdata->cfilt2_mv;
++=======
++>>>>>>> FETCH_HEAD
  		break;
  	case WCD9XXX_CFILT3_SEL:
  		micbias_regs->cfilt_val = WCD9XXX_A_MICB_CFILT_3_VAL;
  		micbias_regs->cfilt_ctl = WCD9XXX_A_MICB_CFILT_3_CTL;
++<<<<<<< HEAD
 +		mbhc->mbhc_data.micb_mv = micbias_pdata->cfilt3_mv;
 +		break;
 +	}
++=======
+ 		break;
+ 	}
+ 
+ 	if (mb_type == MBHC_PRIMARY_MIC_MB) {
+ 		switch (cfilt) {
+ 		case WCD9XXX_CFILT1_SEL:
+ 			mbhc->mbhc_data.micb_mv = micbias_pdata->cfilt1_mv;
+ 			break;
+ 		case WCD9XXX_CFILT2_SEL:
+ 			mbhc->mbhc_data.micb_mv = micbias_pdata->cfilt2_mv;
+ 			break;
+ 		case WCD9XXX_CFILT3_SEL:
+ 			mbhc->mbhc_data.micb_mv = micbias_pdata->cfilt3_mv;
+ 			break;
+ 		}
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  }
  
  static void wcd9xxx_clr_and_turnon_hph_padac(struct wcd9xxx_mbhc *mbhc)
@@@ -812,7 -851,8 +969,12 @@@ static void wcd9xxx_report_plug(struct 
  
  		if (mbhc->micbias_enable && mbhc->micbias_enable_cb) {
  			pr_debug("%s: Disabling micbias\n", __func__);
++<<<<<<< HEAD
 +			mbhc->micbias_enable_cb(mbhc->codec, false);
++=======
+ 			mbhc->micbias_enable_cb(mbhc->codec, false,
+ 						mbhc->mbhc_cfg->micbias);
++>>>>>>> FETCH_HEAD
  			mbhc->micbias_enable = false;
  		}
  		mbhc->zl = mbhc->zr = 0;
@@@ -838,7 -878,8 +1000,12 @@@
  			if (mbhc->micbias_enable && mbhc->micbias_enable_cb &&
  			    mbhc->hph_status == SND_JACK_HEADSET) {
  				pr_debug("%s: Disabling micbias\n", __func__);
++<<<<<<< HEAD
 +				mbhc->micbias_enable_cb(mbhc->codec, false);
++=======
+ 				mbhc->micbias_enable_cb(mbhc->codec, false,
+ 						mbhc->mbhc_cfg->micbias);
++>>>>>>> FETCH_HEAD
  				mbhc->micbias_enable = false;
  			}
  
@@@ -848,8 -889,10 +1015,15 @@@
  			wcd9xxx_jack_report(mbhc, &mbhc->headset_jack,
  					    0, WCD9XXX_JACK_MASK);
  			mbhc->hph_status &= ~(SND_JACK_HEADSET |
++<<<<<<< HEAD
 +						SND_JACK_LINEOUT);
 +		}
++=======
+ 						SND_JACK_LINEOUT |
+ 						SND_JACK_ANC_HEADPHONE);
+ 		}
+ 
++>>>>>>> FETCH_HEAD
  		/* Report insertion */
  		mbhc->hph_status |= jack_type;
  
@@@ -863,11 -906,15 +1037,22 @@@
  			mbhc->update_z = true;
  		} else if (jack_type == SND_JACK_LINEOUT) {
  			mbhc->current_plug = PLUG_TYPE_HIGH_HPH;
++<<<<<<< HEAD
++=======
+ 		} else if (jack_type == SND_JACK_ANC_HEADPHONE) {
+ 			mbhc->polling_active = BUTTON_POLLING_SUPPORTED;
+ 			mbhc->current_plug = PLUG_TYPE_ANC_HEADPHONE;
++>>>>>>> FETCH_HEAD
  		}
  
  		if (mbhc->micbias_enable && mbhc->micbias_enable_cb) {
  			pr_debug("%s: Enabling micbias\n", __func__);
++<<<<<<< HEAD
 +			mbhc->micbias_enable_cb(mbhc->codec, true);
++=======
+ 			mbhc->micbias_enable_cb(mbhc->codec, true,
+ 						mbhc->mbhc_cfg->micbias);
++>>>>>>> FETCH_HEAD
  		}
  
  		if (mbhc->impedance_detect && impedance_detect_en)
@@@ -1034,7 -1081,14 +1219,18 @@@ static short __wcd9xxx_codec_sta_dce(st
  static short wcd9xxx_codec_sta_dce(struct wcd9xxx_mbhc *mbhc, int dce,
  				   bool norel)
  {
++<<<<<<< HEAD
 +	return __wcd9xxx_codec_sta_dce(mbhc, dce, false, norel);
++=======
+ 	bool override_bypass;
+ 
+ 	/* Bypass override if it is already enabled */
+ 	override_bypass = (snd_soc_read(mbhc->codec,
+ 					WCD9XXX_A_CDC_MBHC_B1_CTL) &
+ 			   0x04) ? true : false;
+ 
+ 	return __wcd9xxx_codec_sta_dce(mbhc, dce, override_bypass, norel);
++>>>>>>> FETCH_HEAD
  }
  
  static s32 __wcd9xxx_codec_sta_dce_v(struct wcd9xxx_mbhc *mbhc, s8 dce,
@@@ -1087,7 -1141,8 +1283,12 @@@ static void wcd9xxx_mbhc_ctrl_clk_bandg
  
  /* called only from interrupt which is under codec_resource_lock acquisition */
  static short wcd9xxx_mbhc_setup_hs_polling(struct wcd9xxx_mbhc *mbhc,
++<<<<<<< HEAD
 +					   bool is_cs_enable)
++=======
+ 				struct mbhc_micbias_regs *mbhc_micb_regs,
+ 				bool is_cs_enable)
++>>>>>>> FETCH_HEAD
  {
  	struct snd_soc_codec *codec = mbhc->codec;
  	short bias_value;
@@@ -1108,7 -1163,7 +1309,11 @@@
  	btn_det = WCD9XXX_MBHC_CAL_BTN_DET_PTR(mbhc->mbhc_cfg->calibration);
  	/* Enable external voltage source to micbias if present */
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->enable_mb_source)
++<<<<<<< HEAD
 +		mbhc->mbhc_cb->enable_mb_source(codec, true);
++=======
+ 		mbhc->mbhc_cb->enable_mb_source(codec, true, true);
++>>>>>>> FETCH_HEAD
  
  	/*
  	 * setup internal micbias if codec uses internal micbias for
@@@ -1125,15 -1180,19 +1330,31 @@@
  	snd_soc_update_bits(codec, WCD9XXX_A_CLK_BUFF_EN1, 0x05, 0x01);
  
  	/* Make sure CFILT is in fast mode, save current mode */
++<<<<<<< HEAD
 +	cfilt_mode = snd_soc_read(codec, mbhc->mbhc_bias_regs.cfilt_ctl);
 +	if (mbhc->mbhc_cb && mbhc->mbhc_cb->cfilt_fast_mode)
 +		mbhc->mbhc_cb->cfilt_fast_mode(codec, mbhc);
 +	else
 +		snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.cfilt_ctl,
 +				    0x70, 0x00);
 +
 +	snd_soc_update_bits(codec, WCD9XXX_A_CDC_MBHC_CLK_CTL, 0x2, 0x2);
 +	snd_soc_write(codec, WCD9XXX_A_MBHC_SCALING_MUX_1, 0x04);
++=======
+ 	cfilt_mode = snd_soc_read(codec, mbhc_micb_regs->cfilt_ctl);
+ 	if (mbhc->mbhc_cb && mbhc->mbhc_cb->cfilt_fast_mode)
+ 		mbhc->mbhc_cb->cfilt_fast_mode(codec, mbhc);
+ 	else
+ 		snd_soc_update_bits(codec, mbhc_micb_regs->cfilt_ctl,
+ 				    0x70, 0x00);
+ 
+ 	snd_soc_update_bits(codec, WCD9XXX_A_CDC_MBHC_CLK_CTL, 0x2, 0x2);
+ 	snd_soc_write(codec, WCD9XXX_A_MBHC_SCALING_MUX_1,
+ 		      mbhc->scaling_mux_in);
+ 	pr_debug("%s:  scaling_mux_input: %d\n", __func__,
+ 						 mbhc->scaling_mux_in);
+ 
++>>>>>>> FETCH_HEAD
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->enable_mux_bias_block)
  		mbhc->mbhc_cb->enable_mux_bias_block(codec);
  	else
@@@ -1158,7 -1217,7 +1379,11 @@@
  
  	/* don't flip override */
  	bias_value = __wcd9xxx_codec_sta_dce(mbhc, 1, true, true);
++<<<<<<< HEAD
 +	snd_soc_write(codec, mbhc->mbhc_bias_regs.cfilt_ctl, cfilt_mode);
++=======
+ 	snd_soc_write(codec, mbhc_micb_regs->cfilt_ctl, cfilt_mode);
++>>>>>>> FETCH_HEAD
  	snd_soc_update_bits(codec, WCD9XXX_A_MBHC_HPH, 0x13, 0x00);
  
  	if (mbhc->mbhc_cfg->do_recalibration) {
@@@ -1166,7 -1225,7 +1391,11 @@@
  		reg = snd_soc_read(codec, WCD9XXX_A_CDC_MBHC_B1_CTL);
  		change = snd_soc_update_bits(codec, WCD9XXX_A_CDC_MBHC_B1_CTL,
  					     0x78, btn_det->mbhc_nsc << 3);
++<<<<<<< HEAD
 +		wcd9xxx_get_z(mbhc, &dce_z, &sta_z);
++=======
+ 		wcd9xxx_get_z(mbhc, &dce_z, &sta_z, mbhc_micb_regs, true);
++>>>>>>> FETCH_HEAD
  		if (change)
  			snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_B1_CTL, reg);
  		if (dce_z && sta_z) {
@@@ -1190,7 -1249,8 +1419,12 @@@
  			snd_soc_update_bits(mbhc->codec,
  					    WCD9XXX_A_CDC_MBHC_B1_CTL,
  					    0x78, WCD9XXX_MBHC_NSC_CS << 3);
++<<<<<<< HEAD
 +			wcd9xxx_get_z(mbhc, &dce_z, NULL);
++=======
+ 			wcd9xxx_get_z(mbhc, &dce_z, NULL, mbhc_micb_regs,
+ 				      true);
++>>>>>>> FETCH_HEAD
  			snd_soc_write(mbhc->codec, WCD9XXX_A_CDC_MBHC_B1_CTL,
  				      reg);
  			if (dce_z) {
@@@ -1246,7 -1306,7 +1480,11 @@@ static void wcd9xxx_cleanup_hs_polling(
  
  	/* Disable external voltage source to micbias if present */
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->enable_mb_source)
++<<<<<<< HEAD
 +		mbhc->mbhc_cb->enable_mb_source(mbhc->codec, false);
++=======
+ 		mbhc->mbhc_cb->enable_mb_source(mbhc->codec, false, true);
++>>>>>>> FETCH_HEAD
  
  	mbhc->polling_active = false;
  	mbhc->mbhc_state = MBHC_STATE_NONE;
@@@ -1345,7 -1405,6 +1583,10 @@@ wcd9xxx_cs_find_plug_type(struct wcd9xx
  
  		vdce = __wcd9xxx_codec_sta_dce_v(mbhc, true, d->dce,
  						 dce_z, (u32)mb_mv);
++<<<<<<< HEAD
 +
++=======
++>>>>>>> FETCH_HEAD
  		d->_vdces = vdce;
  		if (d->_vdces < no_mic)
  			d->_type = PLUG_TYPE_HEADPHONE;
@@@ -1379,14 -1438,6 +1620,17 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (event_state & (1 << MBHC_EVENT_PA_HPHL)) {
 +		pr_debug("%s: HPHL PA was ON\n", __func__);
 +	} else if (ch != sz && ch > 0) {
 +		pr_debug("%s: Invalid, inconsistent HPHL\n", __func__);
 +		type = PLUG_TYPE_INVALID;
 +		goto exit;
 +	}
 +
++=======
++>>>>>>> FETCH_HEAD
  	delta_thr = ((highhph_cnt == sz) || highhph) ?
  			      WCD9XXX_MB_MEAS_DELTA_MAX_MV :
  			      WCD9XXX_CS_MEAS_DELTA_MAX_MV;
@@@ -1438,6 -1489,30 +1682,33 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (type == PLUG_TYPE_HEADSET && dgnd && !dgnd->mic_bias) {
+ 		/* if plug type is Headphone report as GND_MIC_SWAP */
+ 		if (dgnd->_type == PLUG_TYPE_HEADPHONE) {
+ 			pr_debug("%s: GND_MIC_SWAP\n", __func__);
+ 			type = PLUG_TYPE_GND_MIC_SWAP;
+ 			/*
+ 			 * if type is GND_MIC_SWAP we should not check
+ 			 * HPHL status hence goto exit
+ 			 */
+ 			goto exit;
+ 		} else if (dgnd->_type != PLUG_TYPE_HEADSET && !dmicbias) {
+ 			pr_debug("%s: Invalid, inconsistent types\n", __func__);
+ 			type = PLUG_TYPE_INVALID;
+ 		}
+ 	}
+ 
+ 	if (event_state & (1 << MBHC_EVENT_PA_HPHL)) {
+ 		pr_debug("%s: HPHL PA was ON\n", __func__);
+ 	} else if (ch != sz && ch > 0) {
+ 		pr_debug("%s: Invalid, inconsistent HPHL..\n", __func__);
+ 		type = PLUG_TYPE_INVALID;
+ 		goto exit;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	if (!(event_state & (1UL << MBHC_EVENT_PA_HPHL))) {
  		if (((type == PLUG_TYPE_HEADSET ||
  		      type == PLUG_TYPE_HEADPHONE) && ch != sz)) {
@@@ -1446,17 -1521,12 +1717,26 @@@
  			type = PLUG_TYPE_INVALID;
  		}
  	}
++<<<<<<< HEAD
 +	if (type == PLUG_TYPE_HEADSET && dgnd && !dgnd->mic_bias) {
 +		if ((dgnd->_vdces + WCD9XXX_CS_GM_SWAP_THRES_MIN_MV <
 +		     minv) &&
 +		    (dgnd->_vdces + WCD9XXX_CS_GM_SWAP_THRES_MAX_MV >
 +		     maxv))
 +			type = PLUG_TYPE_GND_MIC_SWAP;
 +		else if (dgnd->_type != PLUG_TYPE_HEADSET && !dmicbias) {
 +			pr_debug("%s: Invalid, inconsistent types\n", __func__);
 +			type = PLUG_TYPE_INVALID;
 +		}
 +	}
++=======
+ 
+ 	if (type == PLUG_TYPE_HEADSET &&
+ 	    (mbhc->mbhc_cfg->micbias_enable_flags &
+ 	    (1 << MBHC_MICBIAS_ENABLE_REGULAR_HEADSET)))
+ 		mbhc->micbias_enable = true;
+ 
++>>>>>>> FETCH_HEAD
  exit:
  	pr_debug("%s: Plug type %d detected\n", __func__, type);
  	return type;
@@@ -1647,10 -1717,10 +1927,17 @@@ static int wcd9xxx_pull_down_micbias(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +void wcd9xxx_turn_onoff_current_source(struct wcd9xxx_mbhc *mbhc, bool on,
 +				       bool highhph)
 +{
 +
++=======
+ void wcd9xxx_turn_onoff_current_source(struct wcd9xxx_mbhc *mbhc,
+ 				       struct mbhc_micbias_regs *mbhc_micb_regs,
+ 				       bool on, bool highhph)
+ {
++>>>>>>> FETCH_HEAD
  	struct snd_soc_codec *codec;
  	struct wcd9xxx_mbhc_btn_detect_cfg *btn_det;
  	const struct wcd9xxx_mbhc_plug_detect_cfg *plug_det =
@@@ -1665,7 -1735,7 +1952,11 @@@
  		snd_soc_update_bits(codec, WCD9XXX_A_CDC_MBHC_B1_CTL,
  				    0x78, 0x48);
  		/* pull down diode bit to 0 */
++<<<<<<< HEAD
 +		snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.mbhc_reg,
++=======
+ 		snd_soc_update_bits(codec, mbhc_micb_regs->mbhc_reg,
++>>>>>>> FETCH_HEAD
  				    0x01, 0x00);
  		/*
  		 * Keep the low power insertion/removal
@@@ -1680,7 -1750,7 +1971,11 @@@
  		 * (INS_DET_ISRC_EN__ENABLE)
  		 * MICB_2_MBHC__SCHT_TRIG_EN to 1
  		 */
++<<<<<<< HEAD
 +		snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.mbhc_reg,
++=======
+ 		snd_soc_update_bits(codec, mbhc_micb_regs->mbhc_reg,
++>>>>>>> FETCH_HEAD
  				    0xF0, 0xF0);
  		/* Disconnect MBHC Override from MicBias and LDOH */
  		snd_soc_update_bits(codec, WCD9XXX_A_MAD_ANA_CTRL, 0x10, 0x00);
@@@ -1689,16 -1759,16 +1984,28 @@@
  		/* Connect MBHC Override from MicBias and LDOH */
  		snd_soc_update_bits(codec, WCD9XXX_A_MAD_ANA_CTRL, 0x10, 0x10);
  		/* INS_DET_ISRC_CTL to acdb value */
++<<<<<<< HEAD
 +		snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.mbhc_reg,
++=======
+ 		snd_soc_update_bits(codec, mbhc_micb_regs->mbhc_reg,
++>>>>>>> FETCH_HEAD
  				    0x60, plug_det->mic_current << 5);
  		if (!highhph) {
  			/* INS_DET_ISRC_EN__ENABLE to 0 */
  			snd_soc_update_bits(codec,
++<<<<<<< HEAD
 +					    mbhc->mbhc_bias_regs.mbhc_reg,
 +					    0x80, 0x00);
 +			/* MICB_2_MBHC__SCHT_TRIG_EN  to 0 */
 +			snd_soc_update_bits(codec,
 +					    mbhc->mbhc_bias_regs.mbhc_reg,
++=======
+ 					    mbhc_micb_regs->mbhc_reg,
+ 					    0x80, 0x00);
+ 			/* MICB_2_MBHC__SCHT_TRIG_EN  to 0 */
+ 			snd_soc_update_bits(codec,
+ 					    mbhc_micb_regs->mbhc_reg,
++>>>>>>> FETCH_HEAD
  					    0x10, 0x00);
  		}
  		/* Nsc to acdb value */
@@@ -1725,7 -1795,8 +2032,12 @@@ wcd9xxx_codec_cs_get_plug_type(struct w
  	rt[0].vddio = false;
  	rt[0].hwvalue = true;
  	rt[0].hphl_status = wcd9xxx_hphl_status(mbhc);
++<<<<<<< HEAD
 +	rt[0].dce = wcd9xxx_mbhc_setup_hs_polling(mbhc, true);
++=======
+ 	rt[0].dce = wcd9xxx_mbhc_setup_hs_polling(mbhc, &mbhc->mbhc_bias_regs,
+ 						  true);
++>>>>>>> FETCH_HEAD
  	rt[0].mic_bias = false;
  
  	for (i = 1; i < NUM_DCE_PLUG_INS_DETECT - 1; i++) {
@@@ -1737,11 -1808,15 +2049,23 @@@
  			wcd9xxx_codec_hphr_gnd_switch(codec, true);
  
  		if (rt[i].mic_bias)
++<<<<<<< HEAD
 +			wcd9xxx_turn_onoff_current_source(mbhc, false, false);
 +
 +		rt[i].dce = __wcd9xxx_codec_sta_dce(mbhc, 1, !highhph, true);
 +		if (rt[i].mic_bias)
 +			wcd9xxx_turn_onoff_current_source(mbhc, true, false);
++=======
+ 			wcd9xxx_turn_onoff_current_source(mbhc,
+ 							  &mbhc->mbhc_bias_regs,
+ 							  false, false);
+ 
+ 		rt[i].dce = __wcd9xxx_codec_sta_dce(mbhc, 1, !highhph, true);
+ 		if (rt[i].mic_bias)
+ 			wcd9xxx_turn_onoff_current_source(mbhc,
+ 							  &mbhc->mbhc_bias_regs,
+ 							  true, false);
++>>>>>>> FETCH_HEAD
  		if (rt[i].swap_gnd)
  			wcd9xxx_codec_hphr_gnd_switch(codec, false);
  	}
@@@ -1794,7 -1869,8 +2118,12 @@@ wcd9xxx_codec_get_plug_type(struct wcd9
  
  	wcd9xxx_mbhc_ctrl_clk_bandgap(mbhc, true);
  	rt[0].hphl_status = wcd9xxx_hphl_status(mbhc);
++<<<<<<< HEAD
 +	rt[0].dce = wcd9xxx_mbhc_setup_hs_polling(mbhc, false);
++=======
+ 	rt[0].dce = wcd9xxx_mbhc_setup_hs_polling(mbhc, &mbhc->mbhc_bias_regs,
+ 						  false);
++>>>>>>> FETCH_HEAD
  	rt[0].swap_gnd = false;
  	rt[0].vddio = false;
  	rt[0].hwvalue = true;
@@@ -1987,10 -2063,178 +2316,184 @@@ static int wcd9xxx_enable_hs_detect(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Function to determine whether anc microphone is preset or not.
+  * Return true if anc microphone is detected or false if not detected.
+  */
+ static bool wcd9xxx_detect_anc_plug_type(struct wcd9xxx_mbhc *mbhc)
+ {
+ 	struct wcd9xxx_mbhc_detect rt[NUM_DCE_PLUG_INS_DETECT - 1];
+ 	bool anc_mic_found = true;
+ 	int i, mb_mv;
+ 	const struct wcd9xxx_mbhc_plug_type_cfg *plug_type =
+ 	    WCD9XXX_MBHC_CAL_PLUG_TYPE_PTR(mbhc->mbhc_cfg->calibration);
+ 	s16 hs_max, dce_z;
+ 	s16 no_mic;
+ 	bool override_en;
+ 	bool timedout;
+ 	unsigned long timeout, retry = 0;
+ 	enum wcd9xxx_mbhc_plug_type type;
+ 	bool cs_enable;
+ 
+ 	if (mbhc->mbhc_cfg->anc_micbias != MBHC_MICBIAS3 &&
+ 	    mbhc->mbhc_cfg->anc_micbias != MBHC_MICBIAS2)
+ 		return false;
+ 
+ 	pr_debug("%s: enter\n", __func__);
+ 
+ 	override_en = (snd_soc_read(mbhc->codec, WCD9XXX_A_CDC_MBHC_B1_CTL) &
+ 		       0x04) ? true : false;
+ 	cs_enable = ((mbhc->mbhc_cfg->cs_enable_flags &
+ 		    (1 << MBHC_CS_ENABLE_DET_ANC)) != 0) &&
+ 		    (!(snd_soc_read(mbhc->codec,
+ 		       mbhc->mbhc_anc_bias_regs.ctl_reg) & 0x80)) &&
+ 		     (mbhc->mbhc_cfg->micbias != mbhc->mbhc_cfg->anc_micbias);
+ 
+ 	if (cs_enable) {
+ 		wcd9xxx_turn_onoff_current_source(mbhc,
+ 						  &mbhc->mbhc_anc_bias_regs,
+ 						  true, false);
+ 	} else {
+ 		if (mbhc->mbhc_cfg->anc_micbias == MBHC_MICBIAS3) {
+ 			if (mbhc->micbias_enable_cb)
+ 				mbhc->micbias_enable_cb(mbhc->codec, true,
+ 						mbhc->mbhc_cfg->anc_micbias);
+ 			else
+ 				return false;
+ 		} else {
+ 			/* Enable override */
+ 			if (!override_en)
+ 				wcd9xxx_turn_onoff_override(mbhc, true);
+ 		}
+ 	}
+ 
+ 	if (!cs_enable) {
+ 		hs_max = plug_type->v_hs_max;
+ 		no_mic = plug_type->v_no_mic;
+ 		dce_z = mbhc->mbhc_data.dce_z;
+ 		mb_mv = mbhc->mbhc_data.micb_mv;
+ 	} else {
+ 		hs_max = WCD9XXX_V_CS_HS_MAX;
+ 		no_mic = WCD9XXX_V_CS_NO_MIC;
+ 		mb_mv = VDDIO_MICBIAS_MV;
+ 		dce_z = mbhc->mbhc_data.dce_nsc_cs_z;
+ 	}
+ 
+ 	wcd9xxx_mbhc_ctrl_clk_bandgap(mbhc, true);
+ 
+ 	timeout = jiffies + msecs_to_jiffies(ANC_HPH_DETECT_PLUG_TIME_MS);
+ 	anc_mic_found = true;
+ 
+ 	while (!(timedout = time_after(jiffies, timeout))) {
+ 		retry++;
+ 
+ 		if (wcd9xxx_swch_level_remove(mbhc)) {
+ 			pr_debug("%s: Switch level is low\n", __func__);
+ 			anc_mic_found = false;
+ 			break;
+ 		}
+ 
+ 		pr_debug("%s: Retry attempt %lu", __func__, retry - 1);
+ 
+ 		rt[0].hphl_status = wcd9xxx_hphl_status(mbhc);
+ 		rt[0].dce = wcd9xxx_mbhc_setup_hs_polling(mbhc,
+ 						  &mbhc->mbhc_anc_bias_regs,
+ 						  cs_enable);
+ 		rt[0]._vdces = __wcd9xxx_codec_sta_dce_v(mbhc, true, rt[0].dce,
+ 							 dce_z, (u32)mb_mv);
+ 
+ 		if (rt[0]._vdces >= no_mic && rt[0]._vdces < hs_max)
+ 			rt[0]._type = PLUG_TYPE_HEADSET;
+ 		else if (rt[0]._vdces < no_mic)
+ 			rt[0]._type = PLUG_TYPE_HEADPHONE;
+ 		else
+ 			rt[0]._type = PLUG_TYPE_HIGH_HPH;
+ 
+ 		pr_debug("%s: DCE #%d, V %04d, HPHL %d TYPE %d\n",
+ 				__func__, 0, rt[0]._vdces,
+ 				rt[0].hphl_status & 0x01,
+ 				rt[0]._type);
+ 
+ 		for (i = 1; i < NUM_DCE_PLUG_INS_DETECT - 1; i++) {
+ 			rt[i].dce = __wcd9xxx_codec_sta_dce(mbhc, 1,
+ 							    true, true);
+ 			rt[i]._vdces = __wcd9xxx_codec_sta_dce_v(mbhc, true,
+ 							 rt[i].dce, dce_z,
+ 							 (u32) mb_mv);
+ 
+ 			if (rt[i]._vdces >= no_mic && rt[i]._vdces < hs_max)
+ 				rt[i]._type = PLUG_TYPE_HEADSET;
+ 			else if (rt[i]._vdces < no_mic)
+ 				rt[i]._type = PLUG_TYPE_HEADPHONE;
+ 			else
+ 				rt[i]._type = PLUG_TYPE_HIGH_HPH;
+ 
+ 			rt[i].hphl_status = wcd9xxx_hphl_status(mbhc);
+ 
+ 			pr_debug("%s: DCE #%d, V %04d, HPHL %d TYPE %d\n",
+ 					__func__, i, rt[i]._vdces,
+ 					rt[i].hphl_status & 0x01,
+ 					rt[i]._type);
+ 		}
+ 
+ 		/*
+ 		 * Check for the "type" of all the 4 measurements
+ 		 * If all 4 measurements have the Type as PLUG_TYPE_HEADSET
+ 		 * then it is proper mic and declare that the plug has two mics
+ 		 */
+ 		for (i = 0; i < NUM_DCE_PLUG_INS_DETECT - 1; i++) {
+ 			if (i > 0 && (rt[i - 1]._type != rt[i]._type)) {
+ 				type = PLUG_TYPE_INVALID;
+ 				break;
+ 			} else {
+ 				type = rt[0]._type;
+ 			}
+ 		}
+ 
+ 		pr_debug("%s: Plug type found in ANC detection :%d",
+ 			__func__, type);
+ 
+ 		if (type != PLUG_TYPE_HEADSET)
+ 			anc_mic_found = false;
+ 		if (anc_mic_found || (type == PLUG_TYPE_HEADPHONE &&
+ 		    mbhc->mbhc_cfg->hw_jack_type == FIVE_POLE_JACK) ||
+ 		    (type == PLUG_TYPE_HIGH_HPH &&
+ 		    mbhc->mbhc_cfg->hw_jack_type == SIX_POLE_JACK))
+ 			break;
+ 	}
+ 
+ 	wcd9xxx_mbhc_ctrl_clk_bandgap(mbhc, false);
+ 	if (cs_enable) {
+ 		wcd9xxx_turn_onoff_current_source(mbhc,
+ 						  &mbhc->mbhc_anc_bias_regs,
+ 						  false, false);
+ 	} else {
+ 		if (mbhc->mbhc_cfg->anc_micbias == MBHC_MICBIAS3) {
+ 			if (mbhc->micbias_enable_cb)
+ 				mbhc->micbias_enable_cb(mbhc->codec, false,
+ 						mbhc->mbhc_cfg->anc_micbias);
+ 		} else {
+ 			/* Disable override */
+ 			if (!override_en)
+ 				wcd9xxx_turn_onoff_override(mbhc, false);
+ 		}
+ 	}
+ 	pr_debug("%s: leave\n", __func__);
+ 	return anc_mic_found;
+ }
+ 
++>>>>>>> FETCH_HEAD
  /* called under codec_resource_lock acquisition */
  static void wcd9xxx_find_plug_and_report(struct wcd9xxx_mbhc *mbhc,
  					 enum wcd9xxx_mbhc_plug_type plug_type)
  {
++<<<<<<< HEAD
++=======
+ 	bool anc_mic_found = false;
+ 
++>>>>>>> FETCH_HEAD
  	pr_debug("%s: enter current_plug(%d) new_plug(%d)\n",
  		 __func__, mbhc->current_plug, plug_type);
  
@@@ -2016,24 -2260,50 +2519,70 @@@
  		wcd9xxx_report_plug(mbhc, 1, SND_JACK_UNSUPPORTED);
  		wcd9xxx_cleanup_hs_polling(mbhc);
  	} else if (plug_type == PLUG_TYPE_HEADSET) {
++<<<<<<< HEAD
 +		/*
 +		 * If Headphone was reported previously, this will
 +		 * only report the mic line
 +		 */
 +		wcd9xxx_report_plug(mbhc, 1, SND_JACK_HEADSET);
 +		/* Button detection required RC oscillator */
 +		wcd9xxx_mbhc_ctrl_clk_bandgap(mbhc, true);
 +		msleep(100);
 +
 +		/* if PA is already on, switch micbias source to VDDIO */
 +		if (mbhc->event_state &
 +		    (1 << MBHC_EVENT_PA_HPHL | 1 << MBHC_EVENT_PA_HPHR))
 +			__wcd9xxx_switch_micbias(mbhc, 1, false, false);
++=======
+ 
+ 		if (mbhc->mbhc_cfg->enable_anc_mic_detect) {
+ 			/*
+ 			 * Do not report Headset, because at this point
+ 			 * it could be a ANC headphone having two mics.
+ 			 * So, proceed further to detect if there is a
+ 			 * second mic.
+ 			 */
+ 			mbhc->scaling_mux_in = 0x08;
+ 			anc_mic_found = wcd9xxx_detect_anc_plug_type(mbhc);
+ 		}
+ 
+ 		if (anc_mic_found) {
+ 			/* Report ANC headphone */
+ 			wcd9xxx_report_plug(mbhc, 1, SND_JACK_ANC_HEADPHONE);
+ 		} else {
+ 			/*
+ 			 * If Headphone was reported previously, this will
+ 			 * only report the mic line
+ 			 */
+ 			wcd9xxx_report_plug(mbhc, 1, SND_JACK_HEADSET);
+ 		}
+ 		/* Button detection required RC oscillator */
+ 		wcd9xxx_mbhc_ctrl_clk_bandgap(mbhc, true);
+ 		/*
+ 		 * sleep so that audio path completely tears down
+ 		 * before report plug insertion to the user space
+ 		 */
+ 		msleep(100);
+ 
+ 		/*
+ 		 * if PA is already on, switch micbias
+ 		 * source to VDDIO
+ 		 */
+ 		if (mbhc->event_state &
+ 		(1 << MBHC_EVENT_PA_HPHL | 1 << MBHC_EVENT_PA_HPHR))
+ 			__wcd9xxx_switch_micbias(mbhc, 1, false,
+ 						 false);
++>>>>>>> FETCH_HEAD
  		wcd9xxx_start_hs_polling(mbhc);
  	} else if (plug_type == PLUG_TYPE_HIGH_HPH) {
  		if (mbhc->mbhc_cfg->detect_extn_cable) {
  			/* High impedance device found. Report as LINEOUT*/
++<<<<<<< HEAD
 +			wcd9xxx_report_plug(mbhc, 1, SND_JACK_LINEOUT);
++=======
+ 			if (mbhc->current_plug == PLUG_TYPE_NONE)
+ 				wcd9xxx_report_plug(mbhc, 1, SND_JACK_LINEOUT);
++>>>>>>> FETCH_HEAD
  			wcd9xxx_cleanup_hs_polling(mbhc);
  			pr_debug("%s: setup mic trigger for further detection\n",
  				 __func__);
@@@ -2077,10 -2347,14 +2626,21 @@@ static void wcd9xxx_mbhc_decide_swch_pl
  		     (!(snd_soc_read(mbhc->codec,
  				     mbhc->mbhc_bias_regs.ctl_reg) & 0x80)));
  
++<<<<<<< HEAD
 +	if (current_source_enable) {
 +		wcd9xxx_turn_onoff_current_source(mbhc, true, false);
 +		plug_type = wcd9xxx_codec_cs_get_plug_type(mbhc, false);
 +		wcd9xxx_turn_onoff_current_source(mbhc, false, false);
++=======
+ 	mbhc->scaling_mux_in = 0x04;
+ 
+ 	if (current_source_enable) {
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  true, false);
+ 		plug_type = wcd9xxx_codec_cs_get_plug_type(mbhc, false);
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  false, false);
++>>>>>>> FETCH_HEAD
  	} else {
  		wcd9xxx_turn_onoff_override(mbhc, true);
  		plug_type = wcd9xxx_codec_get_plug_type(mbhc, true);
@@@ -2205,7 -2479,8 +2765,12 @@@ static bool wcd9xxx_hs_remove_settle(st
  		     (!(snd_soc_read(mbhc->codec,
  				     mbhc->mbhc_bias_regs.ctl_reg) & 0x80)));
  	if (cs_enable)
++<<<<<<< HEAD
 +		wcd9xxx_turn_onoff_current_source(mbhc, true, false);
++=======
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  true, false);
++>>>>>>> FETCH_HEAD
  
  	timeout = jiffies + msecs_to_jiffies(HS_DETECT_PLUG_TIME_MS);
  	while (!(timedout = time_after(jiffies, timeout))) {
@@@ -2273,7 -2548,8 +2838,12 @@@
  	}
  
  	if (cs_enable)
++<<<<<<< HEAD
 +		wcd9xxx_turn_onoff_current_source(mbhc, false, false);
++=======
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  false, false);
++>>>>>>> FETCH_HEAD
  
  	if (timedout)
  		pr_debug("%s: Microphone did not settle in %d seconds\n",
@@@ -2304,7 -2580,8 +2874,12 @@@ static void wcd9xxx_hs_remove_irq_noswc
  	u32 mb_mv;
  
  	pr_debug("%s: enter\n", __func__);
++<<<<<<< HEAD
 +	if (mbhc->current_plug != PLUG_TYPE_HEADSET) {
++=======
+ 	if (mbhc->current_plug != PLUG_TYPE_HEADSET &&
+ 		mbhc->current_plug != PLUG_TYPE_ANC_HEADPHONE) {
++>>>>>>> FETCH_HEAD
  		pr_debug("%s(): Headset is not inserted, ignore removal\n",
  			 __func__);
  		snd_soc_update_bits(codec, WCD9XXX_A_CDC_MBHC_CLK_CTL,
@@@ -2321,7 -2598,8 +2896,12 @@@
  		     (!(snd_soc_read(codec,
  				     mbhc->mbhc_bias_regs.ctl_reg) & 0x80)));
  	if (cs_enable)
++<<<<<<< HEAD
 +		wcd9xxx_turn_onoff_current_source(mbhc, true, false);
++=======
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  true, false);
++>>>>>>> FETCH_HEAD
  
  	timeout = jiffies + msecs_to_jiffies(FAKE_REMOVAL_MIN_PERIOD_MS);
  	do {
@@@ -2352,7 -2630,8 +2932,12 @@@
  		  removed ? "" : "not ");
  
  	if (cs_enable)
++<<<<<<< HEAD
 +		wcd9xxx_turn_onoff_current_source(mbhc, false, false);
++=======
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  false, false);
++>>>>>>> FETCH_HEAD
  
  	if (removed) {
  		if (mbhc->mbhc_cfg->detect_extn_cable) {
@@@ -2734,8 -3013,8 +3319,13 @@@ static void wcd9xxx_correct_swch_plug(s
  	 * headphone detection.
  	 */
  	if (current_source_enable)
++<<<<<<< HEAD
 +		wcd9xxx_turn_onoff_current_source(mbhc, true,
 +						  false);
++=======
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  true, false);
++>>>>>>> FETCH_HEAD
  	else
  		wcd9xxx_turn_onoff_override(mbhc, true);
  
@@@ -2793,6 -3072,14 +3383,17 @@@
  		} else if (plug_type == PLUG_TYPE_HIGH_HPH) {
  			pr_debug("%s: High HPH detected, continue polling\n",
  				  __func__);
++<<<<<<< HEAD
++=======
+ 			if (mbhc->mbhc_cfg->detect_extn_cable) {
+ 				if (mbhc->current_plug != plug_type)
+ 					wcd9xxx_report_plug(mbhc, 1,
+ 							    SND_JACK_LINEOUT);
+ 			} else if (mbhc->current_plug == PLUG_TYPE_NONE) {
+ 				wcd9xxx_report_plug(mbhc, 1,
+ 						    SND_JACK_HEADPHONE);
+ 			}
++>>>>>>> FETCH_HEAD
  		} else {
  			if (plug_type == PLUG_TYPE_GND_MIC_SWAP) {
  				pt_gnd_mic_swap_cnt++;
@@@ -2819,8 -3106,9 +3420,14 @@@
  			WCD9XXX_BCL_LOCK(mbhc->resmgr);
  			/* Turn off override/current source */
  			if (current_source_enable)
++<<<<<<< HEAD
 +				wcd9xxx_turn_onoff_current_source(mbhc, false,
 +								  false);
++=======
+ 				wcd9xxx_turn_onoff_current_source(mbhc,
+ 							  &mbhc->mbhc_bias_regs,
+ 							  false, false);
++>>>>>>> FETCH_HEAD
  			else
  				wcd9xxx_turn_onoff_override(mbhc, false);
  			/*
@@@ -2846,7 -3134,8 +3453,12 @@@
  	}
  
  	if (!correction && current_source_enable)
++<<<<<<< HEAD
 +		wcd9xxx_turn_onoff_current_source(mbhc, false, highhph);
++=======
+ 		wcd9xxx_turn_onoff_current_source(mbhc, &mbhc->mbhc_bias_regs,
+ 						  false, highhph);
++>>>>>>> FETCH_HEAD
  	else if (!correction)
  		wcd9xxx_turn_onoff_override(mbhc, false);
  
@@@ -2888,16 -3177,15 +3500,25 @@@ static void wcd9xxx_swch_irq_handler(st
  	if (wcd9xxx_cancel_btn_work(mbhc))
  		pr_debug("%s: button press is canceled\n", __func__);
  
++<<<<<<< HEAD
 +	/* cancel detect plug */
 +	wcd9xxx_cancel_hs_detect_plug(mbhc,
 +				      &mbhc->correct_plug_swch);
 +
++=======
++>>>>>>> FETCH_HEAD
  	insert = !wcd9xxx_swch_level_remove(mbhc);
  	pr_debug("%s: Current plug type %d, insert %d\n", __func__,
  		 mbhc->current_plug, insert);
  	if ((mbhc->current_plug == PLUG_TYPE_NONE) && insert) {
  		mbhc->lpi_enabled = false;
  		wmb();
++<<<<<<< HEAD
++=======
+ 		/* cancel detect plug */
+ 		wcd9xxx_cancel_hs_detect_plug(mbhc,
+ 				      &mbhc->correct_plug_swch);
++>>>>>>> FETCH_HEAD
  
  		if ((mbhc->current_plug != PLUG_TYPE_NONE) &&
  		    !(snd_soc_read(codec, WCD9XXX_A_MBHC_INSERT_DETECT) &
@@@ -2912,6 -3200,9 +3533,12 @@@
  	} else if ((mbhc->current_plug != PLUG_TYPE_NONE) && !insert) {
  		mbhc->lpi_enabled = false;
  		wmb();
++<<<<<<< HEAD
++=======
+ 		/* cancel detect plug */
+ 		wcd9xxx_cancel_hs_detect_plug(mbhc,
+ 				      &mbhc->correct_plug_swch);
++>>>>>>> FETCH_HEAD
  
  		if (mbhc->current_plug == PLUG_TYPE_HEADPHONE) {
  			wcd9xxx_report_plug(mbhc, 0, SND_JACK_HEADPHONE);
@@@ -2928,6 -3219,12 +3555,15 @@@
  		} else if (mbhc->current_plug == PLUG_TYPE_HIGH_HPH) {
  			wcd9xxx_report_plug(mbhc, 0, SND_JACK_LINEOUT);
  			is_removed = true;
++<<<<<<< HEAD
++=======
+ 		} else if (mbhc->current_plug == PLUG_TYPE_ANC_HEADPHONE) {
+ 			wcd9xxx_pause_hs_polling(mbhc);
+ 			wcd9xxx_mbhc_ctrl_clk_bandgap(mbhc, false);
+ 			wcd9xxx_cleanup_hs_polling(mbhc);
+ 			wcd9xxx_report_plug(mbhc, 0, SND_JACK_ANC_HEADPHONE);
+ 			is_removed = true;
++>>>>>>> FETCH_HEAD
  		}
  
  		if (is_removed) {
@@@ -3088,7 -3385,9 +3724,13 @@@ static int wcd9xxx_get_button_mask(cons
  	return mask;
  }
  
++<<<<<<< HEAD
 +static void wcd9xxx_get_z(struct wcd9xxx_mbhc *mbhc, s16 *dce_z, s16 *sta_z)
++=======
+ static void wcd9xxx_get_z(struct wcd9xxx_mbhc *mbhc, s16 *dce_z, s16 *sta_z,
+ 			  struct mbhc_micbias_regs *micb_regs,
+ 			  bool norel_detection)
++>>>>>>> FETCH_HEAD
  {
  	s16 reg0, reg1;
  	int change;
@@@ -3096,21 -3395,21 +3738,36 @@@
  
  	WCD9XXX_BCL_ASSERT_LOCKED(mbhc->resmgr);
  	/* Pull down micbias to ground and disconnect vddio switch */
++<<<<<<< HEAD
 +	reg0 = snd_soc_read(codec, mbhc->mbhc_bias_regs.ctl_reg);
 +	snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.ctl_reg, 0x81, 0x1);
 +	reg1 = snd_soc_read(codec, mbhc->mbhc_bias_regs.mbhc_reg);
 +	snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.mbhc_reg, 1 << 7, 0);
++=======
+ 	reg0 = snd_soc_read(codec, micb_regs->ctl_reg);
+ 	snd_soc_update_bits(codec, micb_regs->ctl_reg, 0x81, 0x1);
+ 	reg1 = snd_soc_read(codec, micb_regs->mbhc_reg);
+ 	snd_soc_update_bits(codec, micb_regs->mbhc_reg, 1 << 7, 0);
++>>>>>>> FETCH_HEAD
  
  	/* Disconnect override from micbias */
  	change = snd_soc_update_bits(codec, WCD9XXX_A_MAD_ANA_CTRL, 1 << 4,
  				     1 << 0);
  	usleep_range(1000, 1000 + 1000);
  	if (sta_z) {
++<<<<<<< HEAD
 +		*sta_z = wcd9xxx_codec_sta_dce(mbhc, 0, false);
 +		pr_debug("%s: sta_z 0x%x\n", __func__, *sta_z & 0xFFFF);
 +	}
 +	if (dce_z) {
 +		*dce_z = wcd9xxx_codec_sta_dce(mbhc, 1, false);
++=======
+ 		*sta_z = wcd9xxx_codec_sta_dce(mbhc, 0, norel_detection);
+ 		pr_debug("%s: sta_z 0x%x\n", __func__, *sta_z & 0xFFFF);
+ 	}
+ 	if (dce_z) {
+ 		*dce_z = wcd9xxx_codec_sta_dce(mbhc, 1, norel_detection);
++>>>>>>> FETCH_HEAD
  		pr_debug("%s: dce_z 0x%x\n", __func__, *dce_z & 0xFFFF);
  	}
  
@@@ -3119,16 -3418,22 +3776,33 @@@
  		snd_soc_update_bits(codec, WCD9XXX_A_MAD_ANA_CTRL, 1 << 4,
  				    1 << 4);
  	/* Disable pull down micbias to ground */
++<<<<<<< HEAD
 +	snd_soc_write(codec, mbhc->mbhc_bias_regs.mbhc_reg, reg1);
 +	snd_soc_write(codec, mbhc->mbhc_bias_regs.ctl_reg, reg0);
 +}
 +
++=======
+ 	snd_soc_write(codec, micb_regs->mbhc_reg, reg1);
+ 	snd_soc_write(codec, micb_regs->ctl_reg, reg0);
+ }
+ 
+ /*
+  * This function recalibrates dce_z and sta_z parameters.
+  * No release detection will be false when this function is
+  * used.
+  */
++>>>>>>> FETCH_HEAD
  void wcd9xxx_update_z(struct wcd9xxx_mbhc *mbhc)
  {
  	const u16 sta_z = mbhc->mbhc_data.sta_z;
  	const u16 dce_z = mbhc->mbhc_data.dce_z;
  
++<<<<<<< HEAD
 +	wcd9xxx_get_z(mbhc, &mbhc->mbhc_data.dce_z, &mbhc->mbhc_data.sta_z);
++=======
+ 	wcd9xxx_get_z(mbhc, &mbhc->mbhc_data.dce_z, &mbhc->mbhc_data.sta_z,
+ 		      &mbhc->mbhc_bias_regs, false);
++>>>>>>> FETCH_HEAD
  	pr_debug("%s: sta_z 0x%x,dce_z 0x%x -> sta_z 0x%x,dce_z 0x%x\n",
  		 __func__, sta_z & 0xFFFF, dce_z & 0xFFFF,
  		 mbhc->mbhc_data.sta_z & 0xFFFF,
@@@ -3154,15 -3459,22 +3828,34 @@@ static int wcd9xxx_update_rel_threshold
  	mv = ceilmv + btn_det->v_btn_press_delta_cic;
  	pr_debug("%s: reprogram vb1hu/vbrh to %dmv\n", __func__, mv);
  
++<<<<<<< HEAD
 +	/* update LSB first so mbhc hardware block doesn't see too low value */
 +	v_b1_hu = wcd9xxx_codec_v_sta_dce(mbhc, STA, mv, false);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL, v_b1_hu & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
 +		      (v_b1_hu >> 8) & 0xFF);
 +	v_brh = wcd9xxx_codec_v_sta_dce(mbhc, DCE, mv, false);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL, v_brh & 0xFF);
 +	snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
 +		      (v_brh >> 8) & 0xFF);
++=======
+ 	if (mbhc->mbhc_state != MBHC_STATE_POTENTIAL_RECOVERY) {
+ 		/*
+ 		 * update LSB first so mbhc hardware block
+ 		 * doesn't see too low value.
+ 		 */
+ 		v_b1_hu = wcd9xxx_codec_v_sta_dce(mbhc, STA, mv, false);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B3_CTL, v_b1_hu &
+ 				0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B4_CTL,
+ 				(v_b1_hu >> 8) & 0xFF);
+ 		v_brh = wcd9xxx_codec_v_sta_dce(mbhc, DCE, mv, false);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B9_CTL, v_brh &
+ 				0xFF);
+ 		snd_soc_write(codec, WCD9XXX_A_CDC_MBHC_VOLT_B10_CTL,
+ 				(v_brh >> 8) & 0xFF);
+ 	}
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -3568,7 -3880,7 +4261,11 @@@ static void wcd9xxx_mbhc_cal(struct wcd
  	 * turn on the external voltage source for Calibration.
  	 */
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->enable_mb_source)
++<<<<<<< HEAD
 +		mbhc->mbhc_cb->enable_mb_source(codec, true);
++=======
+ 		mbhc->mbhc_cb->enable_mb_source(codec, true, false);
++>>>>>>> FETCH_HEAD
  
  	cfilt_mode = snd_soc_read(codec, mbhc->mbhc_bias_regs.cfilt_ctl);
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->cfilt_fast_mode)
@@@ -3690,7 -4002,7 +4387,11 @@@
  	usleep_range(100, 100);
  
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->enable_mb_source)
++<<<<<<< HEAD
 +		mbhc->mbhc_cb->enable_mb_source(codec, false);
++=======
+ 		mbhc->mbhc_cb->enable_mb_source(codec, false, false);
++>>>>>>> FETCH_HEAD
  
  	wcd9xxx_enable_irq(mbhc->resmgr->core_res,
  			   mbhc->intr_ids->dce_est_complete);
@@@ -4038,7 -4350,10 +4739,14 @@@ int wcd9xxx_mbhc_start(struct wcd9xxx_m
  	mbhc->mbhc_cfg = mbhc_cfg;
  
  	/* Get HW specific mbhc registers' address */
++<<<<<<< HEAD
 +	wcd9xxx_get_mbhc_micbias_regs(mbhc, &mbhc->mbhc_bias_regs);
++=======
+ 	wcd9xxx_get_mbhc_micbias_regs(mbhc, MBHC_PRIMARY_MIC_MB);
+ 
+ 	/* Get HW specific mbhc registers' address for anc */
+ 	wcd9xxx_get_mbhc_micbias_regs(mbhc, MBHC_ANC_MIC_MB);
++>>>>>>> FETCH_HEAD
  
  	/* Put CFILT in fast mode by default */
  	if (mbhc->mbhc_cb && mbhc->mbhc_cb->cfilt_fast_mode)
@@@ -4251,6 -4566,14 +4959,17 @@@ static int wcd9xxx_event_notify(struct 
  			if (!mbhc->polling_active)
  				wcd9xxx_enable_mbhc_txfe(mbhc, false);
  		}
++<<<<<<< HEAD
++=======
+ 		if (mbhc->micbias_enable && mbhc->polling_active &&
+ 		    !(snd_soc_read(mbhc->codec, mbhc->mbhc_bias_regs.ctl_reg)
+ 		      & 0x80)) {
+ 			pr_debug("%s:Micbias turned off by recording, set up again",
+ 				 __func__);
+ 			snd_soc_update_bits(codec, mbhc->mbhc_bias_regs.ctl_reg,
+ 					    0x80, 0x80);
+ 		}
++>>>>>>> FETCH_HEAD
  		break;
  	/* PA usage change */
  	case WCD9XXX_EVENT_PRE_HPHL_PA_ON:
@@@ -4271,7 -4594,7 +4990,11 @@@
  			hphlocp_off_report(mbhc, SND_JACK_OC_HPHL);
  		if (!(mbhc->event_state &
  		      (1 << MBHC_EVENT_PA_HPHL | 1 << MBHC_EVENT_PA_HPHR |
++<<<<<<< HEAD
 +		       1 << MBHC_EVENT_PRE_TX_3_ON)))
++=======
+ 		       1 << MBHC_EVENT_PRE_TX_1_3_ON)))
++>>>>>>> FETCH_HEAD
  			wcd9xxx_switch_micbias(mbhc, 0);
  		break;
  	case WCD9XXX_EVENT_POST_HPHR_PA_OFF:
@@@ -4283,7 -4606,7 +5006,11 @@@
  			hphrocp_off_report(mbhc, SND_JACK_OC_HPHL);
  		if (!(mbhc->event_state &
  		      (1 << MBHC_EVENT_PA_HPHL | 1 << MBHC_EVENT_PA_HPHR |
++<<<<<<< HEAD
 +		       1 << MBHC_EVENT_PRE_TX_3_ON)))
++=======
+ 		       1 << MBHC_EVENT_PRE_TX_1_3_ON)))
++>>>>>>> FETCH_HEAD
  			wcd9xxx_switch_micbias(mbhc, 0);
  		break;
  	/* Clock usage change */
@@@ -4365,23 -4688,23 +5092,39 @@@
  	case WCD9XXX_EVENT_POST_BG_MBHC_ON:
  		/* Not used for now */
  		break;
++<<<<<<< HEAD
 +	case WCD9XXX_EVENT_PRE_TX_3_ON:
++=======
+ 	case WCD9XXX_EVENT_PRE_TX_1_3_ON:
++>>>>>>> FETCH_HEAD
  		/*
  		 * if polling is ON, mbhc micbias not enabled
  		 *  switch micbias source to VDDIO
  		 */
++<<<<<<< HEAD
 +		set_bit(MBHC_EVENT_PRE_TX_3_ON, &mbhc->event_state);
++=======
+ 		set_bit(MBHC_EVENT_PRE_TX_1_3_ON, &mbhc->event_state);
++>>>>>>> FETCH_HEAD
  		if (!(snd_soc_read(codec, mbhc->mbhc_bias_regs.ctl_reg)
  		      & 0x80) &&
  		    mbhc->polling_active && !mbhc->mbhc_micbias_switched)
  			wcd9xxx_switch_micbias(mbhc, 1);
  		break;
++<<<<<<< HEAD
 +	case WCD9XXX_EVENT_POST_TX_3_OFF:
++=======
+ 	case WCD9XXX_EVENT_POST_TX_1_3_OFF:
++>>>>>>> FETCH_HEAD
  		/*
  		 * Switch back to micbias if HPH PA or TX3 path
  		 * is disabled
  		 */
++<<<<<<< HEAD
 +		clear_bit(MBHC_EVENT_PRE_TX_3_ON, &mbhc->event_state);
++=======
+ 		clear_bit(MBHC_EVENT_PRE_TX_1_3_ON, &mbhc->event_state);
++>>>>>>> FETCH_HEAD
  		if (mbhc->polling_active && mbhc->mbhc_micbias_switched &&
  		    !(mbhc->event_state & (1 << MBHC_EVENT_PA_HPHL |
  		      1 << MBHC_EVENT_PA_HPHR)))
@@@ -4434,6 -4757,7 +5177,10 @@@ static int wcd9xxx_detect_impedance(str
  	s16 *z[] = {
  		&l[0], &r[0], &r[1], &l[1], &l[2], &r[2],
  	};
++<<<<<<< HEAD
++=======
+ 	bool override_en;
++>>>>>>> FETCH_HEAD
  	struct snd_soc_codec *codec = mbhc->codec;
  	const int mux_wait_us = 25;
  	const struct wcd9xxx_reg_mask_val reg_set_mux[] = {
@@@ -4470,7 -4794,10 +5217,14 @@@
  
  	wcd9xxx_onoff_ext_mclk(mbhc, true);
  
++<<<<<<< HEAD
 +	wcd9xxx_turn_onoff_override(mbhc, true);
++=======
+ 	override_en = (snd_soc_read(codec, WCD9XXX_A_CDC_MBHC_B1_CTL) & 0x04) ?
+ 					true : false;
+ 	if (!override_en)
+ 		wcd9xxx_turn_onoff_override(mbhc, true);
++>>>>>>> FETCH_HEAD
  	pr_debug("%s: Setting impedance detection\n", __func__);
  
  	/* Codec specific setup for L0, R0, L1 and R1 measurements */
@@@ -4518,7 -4845,8 +5272,12 @@@
  
  	wcd9xxx_onoff_ext_mclk(mbhc, false);
  
++<<<<<<< HEAD
 +	wcd9xxx_turn_onoff_override(mbhc, false);
++=======
+ 	if (!override_en)
+ 		wcd9xxx_turn_onoff_override(mbhc, false);
++>>>>>>> FETCH_HEAD
  	mbhc->mbhc_cb->compute_impedance(l, r, zl, zr);
  
  	pr_debug("%s: L0: 0x%x(%d), L1: 0x%x(%d), L2: 0x%x(%d)\n",
@@@ -4536,10 -4864,8 +5295,15 @@@
  int wcd9xxx_mbhc_get_impedance(struct wcd9xxx_mbhc *mbhc, uint32_t *zl,
  			       uint32_t *zr)
  {
++<<<<<<< HEAD
 +	WCD9XXX_BCL_LOCK(mbhc->resmgr);
 +	*zl = mbhc->zl;
 +	*zr = mbhc->zr;
 +	WCD9XXX_BCL_UNLOCK(mbhc->resmgr);
++=======
+ 	*zl = mbhc->zl;
+ 	*zr = mbhc->zr;
++>>>>>>> FETCH_HEAD
  
  	if (*zl && *zr)
  		return 0;
@@@ -4554,7 -4880,8 +5318,12 @@@
   */
  int wcd9xxx_mbhc_init(struct wcd9xxx_mbhc *mbhc, struct wcd9xxx_resmgr *resmgr,
  		      struct snd_soc_codec *codec,
++<<<<<<< HEAD
 +		      int (*micbias_enable_cb) (struct snd_soc_codec*,  bool),
++=======
+ 		      int (*micbias_enable_cb) (struct snd_soc_codec*,  bool,
+ 						enum wcd9xxx_micbias_num),
++>>>>>>> FETCH_HEAD
  		      const struct wcd9xxx_mbhc_cb *mbhc_cb,
  		      const struct wcd9xxx_mbhc_intr *mbhc_cdc_intr_ids,
  		      int rco_clk_rate,
diff --cc sound/soc/codecs/wcd9xxx-mbhc.h
index 98f73fc,cf25798..0000000
--- a/sound/soc/codecs/wcd9xxx-mbhc.h
+++ b/sound/soc/codecs/wcd9xxx-mbhc.h
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -78,6 -78,12 +82,15 @@@ enum wcd9xxx_mbhc_plug_type 
  	PLUG_TYPE_HEADPHONE,
  	PLUG_TYPE_HIGH_HPH,
  	PLUG_TYPE_GND_MIC_SWAP,
++<<<<<<< HEAD
++=======
+ 	PLUG_TYPE_ANC_HEADPHONE,
+ };
+ 
+ enum wcd9xxx_mbhc_micbias_type {
+ 	MBHC_PRIMARY_MIC_MB,
+ 	MBHC_ANC_MIC_MB,
++>>>>>>> FETCH_HEAD
  };
  
  enum wcd9xxx_micbias_num {
@@@ -88,6 -94,12 +101,15 @@@
  	MBHC_MICBIAS4,
  };
  
++<<<<<<< HEAD
++=======
+ enum hw_jack_type {
+ 	FOUR_POLE_JACK = 0,
+ 	FIVE_POLE_JACK,
+ 	SIX_POLE_JACK,
+ };
+ 
++>>>>>>> FETCH_HEAD
  enum wcd9xx_mbhc_micbias_enable_bits {
  	MBHC_MICBIAS_ENABLE_THRESHOLD_HEADSET,
  	MBHC_MICBIAS_ENABLE_REGULAR_HEADSET,
@@@ -97,6 -109,7 +119,10 @@@ enum wcd9xx_mbhc_cs_enable_bits 
  	MBHC_CS_ENABLE_POLLING,
  	MBHC_CS_ENABLE_INSERTION,
  	MBHC_CS_ENABLE_REMOVAL,
++<<<<<<< HEAD
++=======
+ 	MBHC_CS_ENABLE_DET_ANC,
++>>>>>>> FETCH_HEAD
  };
  
  enum wcd9xxx_mbhc_state {
@@@ -123,8 -136,8 +149,13 @@@ enum wcd9xxx_mbhc_clk_freq 
  enum wcd9xxx_mbhc_event_state {
  	MBHC_EVENT_PA_HPHL,
  	MBHC_EVENT_PA_HPHR,
++<<<<<<< HEAD
 +	MBHC_EVENT_PRE_TX_3_ON,
 +	MBHC_EVENT_POST_TX_3_OFF,
++=======
+ 	MBHC_EVENT_PRE_TX_1_3_ON,
+ 	MBHC_EVENT_POST_TX_1_3_OFF,
++>>>>>>> FETCH_HEAD
  };
  
  struct wcd9xxx_mbhc_general_cfg {
@@@ -217,6 -230,7 +248,10 @@@ struct wcd9xxx_mbhc_config 
  	 */
  	void *calibration;
  	enum wcd9xxx_micbias_num micbias;
++<<<<<<< HEAD
++=======
+ 	enum wcd9xxx_micbias_num anc_micbias;
++>>>>>>> FETCH_HEAD
  	int (*mclk_cb_fn) (struct snd_soc_codec*, int, bool);
  	unsigned int mclk_rate;
  	unsigned int gpio;
@@@ -232,6 -246,8 +267,11 @@@
  	bool use_int_rbias;
  	bool do_recalibration;
  	bool use_vddio_meas;
++<<<<<<< HEAD
++=======
+ 	bool enable_anc_mic_detect;
+ 	enum hw_jack_type hw_jack_type;
++>>>>>>> FETCH_HEAD
  };
  
  struct wcd9xxx_cfilt_mode {
@@@ -266,7 -282,7 +306,11 @@@ struct wcd9xxx_mbhc_cb 
  			   enum mbhc_impedance_detect_stages stage);
  	void (*compute_impedance) (s16 *, s16 *, uint32_t *, uint32_t *);
  	void (*enable_mbhc_txfe) (struct snd_soc_codec *, bool);
++<<<<<<< HEAD
 +	int (*enable_mb_source) (struct snd_soc_codec *, bool);
++=======
+ 	int (*enable_mb_source) (struct snd_soc_codec *, bool, bool);
++>>>>>>> FETCH_HEAD
  	void (*setup_int_rbias) (struct snd_soc_codec *, bool);
  	void (*pull_mb_to_vddio) (struct snd_soc_codec *, bool);
  };
@@@ -283,6 -299,8 +327,11 @@@ struct wcd9xxx_mbhc 
  	struct mbhc_internal_cal_data mbhc_data;
  
  	struct mbhc_micbias_regs mbhc_bias_regs;
++<<<<<<< HEAD
++=======
+ 	struct mbhc_micbias_regs mbhc_anc_bias_regs;
+ 
++>>>>>>> FETCH_HEAD
  	bool mbhc_micbias_switched;
  
  	u32 hph_status; /* track headhpone status */
@@@ -331,7 -349,8 +380,12 @@@
  	struct notifier_block nblock;
  
  	bool micbias_enable;
++<<<<<<< HEAD
 +	int (*micbias_enable_cb) (struct snd_soc_codec*,  bool);
++=======
+ 	int (*micbias_enable_cb) (struct snd_soc_codec*,  bool,
+ 				  enum wcd9xxx_micbias_num);
++>>>>>>> FETCH_HEAD
  
  	bool impedance_detect;
  	/* impedance of hphl and hphr */
@@@ -340,6 -359,8 +394,11 @@@
  	u32 rco_clk_rate;
  
  	bool update_z;
++<<<<<<< HEAD
++=======
+ 
+ 	u8   scaling_mux_in;
++>>>>>>> FETCH_HEAD
  	/* Holds codec specific interrupt mapping */
  	const struct wcd9xxx_mbhc_intr *intr_ids;
  
@@@ -409,7 -430,8 +468,12 @@@ int wcd9xxx_mbhc_start(struct wcd9xxx_m
  void wcd9xxx_mbhc_stop(struct wcd9xxx_mbhc *mbhc);
  int wcd9xxx_mbhc_init(struct wcd9xxx_mbhc *mbhc, struct wcd9xxx_resmgr *resmgr,
  		      struct snd_soc_codec *codec,
++<<<<<<< HEAD
 +		      int (*micbias_enable_cb) (struct snd_soc_codec*,  bool),
++=======
+ 		      int (*micbias_enable_cb) (struct snd_soc_codec*,  bool,
+ 						enum wcd9xxx_micbias_num),
++>>>>>>> FETCH_HEAD
  		      const struct wcd9xxx_mbhc_cb *mbhc_cb,
  		      const struct wcd9xxx_mbhc_intr *mbhc_cdc_intr_ids,
  		      int rco_clk_rate,
diff --cc sound/soc/codecs/wcd9xxx-resmgr.c
index e56b182,4843b51..0000000
--- a/sound/soc/codecs/wcd9xxx-resmgr.c
+++ b/sound/soc/codecs/wcd9xxx-resmgr.c
@@@ -92,8 -92,8 +92,13 @@@ static char wcd9xxx_event_string[][64] 
  
  	"WCD9XXX_EVENT_POST_RESUME",
  
++<<<<<<< HEAD
 +	"WCD9XXX_EVENT_PRE_TX_3_ON",
 +	"WCD9XXX_EVENT_POST_TX_3_OFF",
++=======
+ 	"WCD9XXX_EVENT_PRE_TX_1_3_ON",
+ 	"WCD9XXX_EVENT_POST_TX_1_3_OFF",
++>>>>>>> FETCH_HEAD
  
  	"WCD9XXX_EVENT_LAST",
  };
diff --cc sound/soc/codecs/wcd9xxx-resmgr.h
index 9f383b6,29896fc..0000000
--- a/sound/soc/codecs/wcd9xxx-resmgr.h
+++ b/sound/soc/codecs/wcd9xxx-resmgr.h
@@@ -105,8 -105,8 +105,13 @@@ enum wcd9xxx_notify_event 
  
  	WCD9XXX_EVENT_POST_RESUME,
  
++<<<<<<< HEAD
 +	WCD9XXX_EVENT_PRE_TX_3_ON,
 +	WCD9XXX_EVENT_POST_TX_3_OFF,
++=======
+ 	WCD9XXX_EVENT_PRE_TX_1_3_ON,
+ 	WCD9XXX_EVENT_POST_TX_1_3_OFF,
++>>>>>>> FETCH_HEAD
  
  	WCD9XXX_EVENT_LAST,
  };
diff --cc sound/soc/msm/apq8074.c
index 3a055e2,4e79109..0000000
--- a/sound/soc/msm/apq8074.c
+++ b/sound/soc/msm/apq8074.c
@@@ -19,18 -19,22 +19,34 @@@
  #include <linux/mfd/pm8xxx/pm8921.h>
  #include <linux/qpnp/clkdiv.h>
  #include <linux/regulator/consumer.h>
++<<<<<<< HEAD
++=======
+ #include <linux/io.h>
++>>>>>>> FETCH_HEAD
  #include <sound/core.h>
  #include <sound/soc.h>
  #include <sound/soc-dapm.h>
  #include <sound/pcm.h>
  #include <sound/jack.h>
  #include <sound/q6afe-v2.h>
++<<<<<<< HEAD
 +#include <asm/mach-types.h>
 +#include <mach/socinfo.h>
 +#include <sound/pcm_params.h>
 +#include "qdsp6v2/msm-pcm-routing-v2.h"
 +#include "../codecs/wcd9320.h"
 +#include <linux/io.h>
++=======
+ #include <sound/pcm_params.h>
+ #include <asm/mach-types.h>
+ #include <mach/subsystem_notif.h>
+ #include <mach/socinfo.h>
+ 
+ #include "qdsp6v2/msm-pcm-routing-v2.h"
+ #include "qdsp6v2/q6core.h"
+ #include "../codecs/wcd9xxx-common.h"
+ #include "../codecs/wcd9320.h"
++>>>>>>> FETCH_HEAD
  
  #define DRV_NAME "apq8074-asoc-taiko"
  
@@@ -82,6 -86,10 +98,13 @@@ static int apq8074_auxpcm_rate = 8000
  
  #define NUM_OF_AUXPCM_GPIOS 4
  
++<<<<<<< HEAD
++=======
+ static void *adsp_state_notifier;
+ 
+ #define ADSP_STATE_READY_TIMEOUT_MS 3000
+ 
++>>>>>>> FETCH_HEAD
  static inline int param_is_mask(int p)
  {
  	return ((p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
@@@ -1230,6 -1238,101 +1253,104 @@@ static bool apq8074_swap_gnd_mic(struc
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_afe_set_config(struct snd_soc_codec *codec)
+ {
+ 	int rc;
+ 	void *config_data;
+ 
+ 	pr_debug("%s: enter\n", __func__);
+ 	config_data = taiko_get_afe_config(codec, AFE_CDC_REGISTERS_CONFIG);
+ 	rc = afe_set_config(AFE_CDC_REGISTERS_CONFIG, config_data, 0);
+ 	if (rc) {
+ 		pr_err("%s: Failed to set codec registers config %d\n",
+ 		       __func__, rc);
+ 		return rc;
+ 	}
+ 
+ 	config_data = taiko_get_afe_config(codec, AFE_SLIMBUS_SLAVE_CONFIG);
+ 	rc = afe_set_config(AFE_SLIMBUS_SLAVE_CONFIG, config_data, 0);
+ 	if (rc) {
+ 		pr_err("%s: Failed to set slimbus slave config %d\n", __func__,
+ 		       rc);
+ 		return rc;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void msm_afe_clear_config(void)
+ {
+ 	afe_clear_config(AFE_CDC_REGISTERS_CONFIG);
+ 	afe_clear_config(AFE_SLIMBUS_SLAVE_CONFIG);
+ }
+ 
+ static int  msm8974_adsp_state_callback(struct notifier_block *nb,
+ 		unsigned long value, void *priv)
+ {
+ 	if (value == SUBSYS_BEFORE_SHUTDOWN) {
+ 		pr_debug("%s: ADSP is about to shutdown. Clearing AFE config\n",
+ 			 __func__);
+ 		msm_afe_clear_config();
+ 	} else if (value == SUBSYS_AFTER_POWERUP) {
+ 		pr_debug("%s: ADSP is up\n", __func__);
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block adsp_state_notifier_block = {
+ 	.notifier_call = msm8974_adsp_state_callback,
+ 	.priority = -INT_MAX,
+ };
+ 
+ static int msm8974_taiko_codec_up(struct snd_soc_codec *codec)
+ {
+ 	int err;
+ 	unsigned long timeout;
+ 	int adsp_ready = 0;
+ 
+ 	timeout = jiffies +
+ 		msecs_to_jiffies(ADSP_STATE_READY_TIMEOUT_MS);
+ 
+ 	do {
+ 		if (!q6core_is_adsp_ready()) {
+ 			pr_err("%s: ADSP Audio isn't ready\n", __func__);
+ 		} else {
+ 			pr_debug("%s: ADSP Audio is ready\n", __func__);
+ 			adsp_ready = 1;
+ 			break;
+ 		}
+ 	} while (time_after(timeout, jiffies));
+ 
+ 	if (!adsp_ready) {
+ 		pr_err("%s: timed out waiting for ADSP Audio\n", __func__);
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	err = msm_afe_set_config(codec);
+ 	if (err)
+ 		pr_err("%s: Failed to set AFE config. err %d\n",
+ 				__func__, err);
+ 	return err;
+ }
+ 
+ static int apq8074_taiko_event_cb(struct snd_soc_codec *codec,
+ 		enum wcd9xxx_codec_event codec_event)
+ {
+ 	switch (codec_event) {
+ 	case WCD9XXX_CODEC_EVENT_CODEC_UP:
+ 		return msm8974_taiko_codec_up(codec);
+ 		break;
+ 	default:
+ 		pr_err("%s: UnSupported codec event %d\n",
+ 				__func__, codec_event);
+ 		return -EINVAL;
+ 	}
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_audrx_init(struct snd_soc_pcm_runtime *rtd)
  {
  	int err;
@@@ -1291,19 -1394,9 +1412,25 @@@
  				    tx_ch, ARRAY_SIZE(rx_ch), rx_ch);
  
  
++<<<<<<< HEAD
 +	config_data = taiko_get_afe_config(codec, AFE_CDC_REGISTERS_CONFIG);
 +	err = afe_set_config(AFE_CDC_REGISTERS_CONFIG, config_data, 0);
 +	if (err) {
 +		pr_err("%s: Failed to set codec registers config %d\n",
 +		       __func__, err);
 +		goto out;
 +	}
 +
 +	config_data = taiko_get_afe_config(codec, AFE_SLIMBUS_SLAVE_CONFIG);
 +	err = afe_set_config(AFE_SLIMBUS_SLAVE_CONFIG, config_data, 0);
 +	if (err) {
 +		pr_err("%s: Failed to set slimbus slave config %d\n", __func__,
 +		       err);
++=======
+ 	err = msm_afe_set_config(codec);
+ 	if (err) {
+ 		pr_err("%s: Failed to set AFE config %d\n", __func__, err);
++>>>>>>> FETCH_HEAD
  		goto out;
  	}
  
@@@ -1340,12 -1433,23 +1467,31 @@@
  		err = taiko_hs_detect(codec, &mbhc_cfg);
  		if (err)
  			goto out;
++<<<<<<< HEAD
 +		else
 +			return err;
++=======
++>>>>>>> FETCH_HEAD
  	} else {
  		err = -ENOMEM;
  		goto out;
  	}
++<<<<<<< HEAD
++=======
+ 	adsp_state_notifier =
+ 	    subsys_notif_register_notifier("adsp",
+ 					   &adsp_state_notifier_block);
+ 	if (!adsp_state_notifier) {
+ 		pr_err("%s: Failed to register adsp state notifier\n",
+ 		       __func__);
+ 		err = -EFAULT;
+ 		taiko_hs_detect_exit(codec);
+ 		goto out;
+ 	}
+ 
+ 	taiko_event_register(apq8074_taiko_event_cb, rtd->codec);
+ 	return 0;
++>>>>>>> FETCH_HEAD
  out:
  	clk_put(codec_clk);
  	return err;
@@@ -1708,7 -1812,7 +1854,11 @@@ static struct snd_soc_dai_link apq8074_
  		.name = "MSM8974 Compr",
  		.stream_name = "COMPR",
  		.cpu_dai_name	= "MultiMedia4",
++<<<<<<< HEAD
 +		.platform_name  = "msm-compr-dsp",
++=======
+ 		.platform_name  = "msm-compress-dsp",
++>>>>>>> FETCH_HEAD
  		.dynamic = 1,
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			 SND_SOC_DPCM_TRIGGER_POST},
diff --cc sound/soc/msm/msm-compr-q6.c
index 373090e,635f125..0000000
--- a/sound/soc/msm/msm-compr-q6.c
+++ b/sound/soc/msm/msm-compr-q6.c
@@@ -1179,7 -1179,13 +1179,17 @@@ static int msm_compr_ioctl(struct snd_p
  			char modelId[128];
  			struct snd_dec_dts opt_dts =
  				compr->info.codec_param.codec.dts;
++<<<<<<< HEAD
 +			int modelIdLength = opt_dts.modelIdLength;
++=======
+ 			unsigned int modelIdLength = opt_dts.modelIdLength;
+ 			if (modelIdLength >= sizeof(modelId)) {
+ 				rc = -EINVAL;
+ 				pr_err("%s: ERROR: modelIdLength is"
+ 						"invalid\n", __func__);
+ 				return rc;
+ 			}
++>>>>>>> FETCH_HEAD
  			if (copy_from_user(modelId, (void *)opt_dts.modelId,
  				modelIdLength))
  				pr_err("%s: ERROR: copy modelId\n", __func__);
@@@ -1222,8 -1228,14 +1232,19 @@@
  			char modelId[128];
  			struct snd_dec_dts opt_dts =
  				compr->info.codec_param.codec.dts;
++<<<<<<< HEAD
 +			int modelIdLength = opt_dts.modelIdLength;
 +			pr_debug("SND_AUDIOCODEC_DTS\n");
++=======
+ 			unsigned int modelIdLength = opt_dts.modelIdLength;
+ 			pr_debug("SND_AUDIOCODEC_DTS\n");
+ 			if (modelIdLength >= sizeof(modelId)) {
+ 				rc = -EINVAL;
+ 				pr_err("%s: ERROR: modelIdLength is"
+ 						"invalid\n", __func__);
+ 				return rc;
+ 			}
++>>>>>>> FETCH_HEAD
  			if (copy_from_user(modelId, (void *)opt_dts.modelId,
  				modelIdLength))
  				pr_err("%s: ERROR: copy modelId\n", __func__);
diff --cc sound/soc/msm/msm-dai-fe.c
index e6bd926,fd251ff..0000000
--- a/sound/soc/msm/msm-dai-fe.c
+++ b/sound/soc/msm/msm-dai-fe.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -25,7 -25,7 +29,11 @@@ static struct snd_soc_dai_ops msm_fe_da
  /* Conventional and unconventional sample rate supported */
  static unsigned int supported_sample_rates[] = {
  	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
++<<<<<<< HEAD
 +	96000, 192000
++=======
+ 	88200, 96000, 176400, 192000
++>>>>>>> FETCH_HEAD
  };
  
  static struct snd_pcm_hw_constraint_list constraints_sample_rates = {
@@@ -422,6 -422,30 +430,33 @@@ static struct snd_soc_dai_driver msm_fe
  	},
  	{
  		.playback = {
++<<<<<<< HEAD
++=======
+ 			.stream_name = "INT_HFP_BT Hostless Playback",
+ 			.aif_name = "INTHFP_DL_HL",
+ 			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+ 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+ 			.channels_min = 1,
+ 			.channels_max = 2,
+ 			.rate_min =     8000,
+ 			.rate_max =     16000,
+ 		},
+ 		.capture = {
+ 			.stream_name = "INT_HFP_BT Hostless Capture",
+ 			.aif_name = "INTHFP_UL_HL",
+ 			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+ 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+ 			.channels_min = 1,
+ 			.channels_max = 2,
+ 			.rate_min =     8000,
+ 			.rate_max =     16000,
+ 		},
+ 		.ops = &msm_fe_dai_ops,
+ 		.name = "INT_HFP_BT_HOSTLESS",
+ 	},
+ 	{
+ 		.playback = {
++>>>>>>> FETCH_HEAD
  			.stream_name = "AFE-PROXY Playback",
  			.aif_name = "PCM_RX",
  			.rates = (SNDRV_PCM_RATE_8000 |
diff --cc sound/soc/msm/msm8226.c
index ad74b7e,10ab800..0000000
--- a/sound/soc/msm/msm8226.c
+++ b/sound/soc/msm/msm8226.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -89,6 -89,7 +93,10 @@@ static struct wcd9xxx_mbhc_config mbhc_
  	.read_fw_bin = false,
  	.calibration = NULL,
  	.micbias = MBHC_MICBIAS2,
++<<<<<<< HEAD
++=======
+ 	.anc_micbias = MBHC_MICBIAS2,
++>>>>>>> FETCH_HEAD
  	.mclk_cb_fn = msm_snd_enable_codec_ext_clk,
  	.mclk_rate = TAPAN_EXT_CLK_RATE,
  	.gpio = 0,
@@@ -100,9 -101,12 +108,18 @@@
  	.swap_gnd_mic = NULL,
  	.cs_enable_flags = (1 << MBHC_CS_ENABLE_POLLING |
  			    1 << MBHC_CS_ENABLE_INSERTION |
++<<<<<<< HEAD
 +			    1 << MBHC_CS_ENABLE_REMOVAL),
 +	.do_recalibration = true,
 +	.use_vddio_meas = true,
++=======
+ 			    1 << MBHC_CS_ENABLE_REMOVAL |
+ 			    1 << MBHC_CS_ENABLE_DET_ANC),
+ 	.do_recalibration = true,
+ 	.use_vddio_meas = true,
+ 	.enable_anc_mic_detect = false,
+ 	.hw_jack_type = FOUR_POLE_JACK,
++>>>>>>> FETCH_HEAD
  };
  
  struct msm_auxpcm_gpio {
@@@ -1665,6 -1669,21 +1682,24 @@@ static struct snd_soc_dai_link msm8226_
  		.codec_name = "snd-soc-dummy",
  		.be_id = MSM_FRONTEND_DAI_LSM1,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		.name = "MSM8226 Compr8",
+ 		.stream_name = "COMPR8",
+ 		.cpu_dai_name	= "MultiMedia8",
+ 		.platform_name  = "msm-compr-dsp",
+ 		.dynamic = 1,
+ 		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+ 			 SND_SOC_DPCM_TRIGGER_POST},
+ 		.codec_dai_name = "snd-soc-dummy-dai",
+ 		.codec_name = "snd-soc-dummy",
+ 		.ignore_suspend = 1,
+ 		.ignore_pmdown_time = 1,
+ 		 /* this dainlink has playback support */
+ 		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA8,
+ 	},
++>>>>>>> FETCH_HEAD
  	/* Backend BT/FM DAI Links */
  	{
  		.name = LPASS_BE_INT_BT_SCO_RX,
@@@ -2390,6 -2409,8 +2425,11 @@@ static __devinit int msm8226_asoc_machi
  	struct msm8226_asoc_mach_data *pdata;
  	int ret;
  	const char *auxpcm_pri_gpio_set = NULL;
++<<<<<<< HEAD
++=======
+ 	const char *mbhc_audio_jack_type = NULL;
+ 	size_t n = strlen("4-pole-jack");
++>>>>>>> FETCH_HEAD
  
  	if (!pdev->dev.of_node) {
  		dev_err(&pdev->dev, "No platform supplied from device tree\n");
@@@ -2455,6 -2476,35 +2495,38 @@@
  	mbhc_cfg.gpio_level_insert = of_property_read_bool(pdev->dev.of_node,
  					"qcom,headset-jack-type-NC");
  
++<<<<<<< HEAD
++=======
+ 	ret = of_property_read_string(pdev->dev.of_node,
+ 		"qcom,mbhc-audio-jack-type", &mbhc_audio_jack_type);
+ 	if (ret) {
+ 		dev_dbg(&pdev->dev, "Looking up %s property in node %s failed",
+ 			"qcom,mbhc-audio-jack-type",
+ 			pdev->dev.of_node->full_name);
+ 		mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 		mbhc_cfg.enable_anc_mic_detect = false;
+ 		dev_dbg(&pdev->dev, "Jack type properties set to default");
+ 	} else {
+ 		if (!strncmp(mbhc_audio_jack_type, "4-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = false;
+ 			dev_dbg(&pdev->dev, "This hardware has 4 pole jack");
+ 		} else if (!strncmp(mbhc_audio_jack_type, "5-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = FIVE_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = true;
+ 			dev_dbg(&pdev->dev, "This hardware has 5 pole jack");
+ 		} else if (!strncmp(mbhc_audio_jack_type, "6-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = SIX_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = true;
+ 			dev_dbg(&pdev->dev, "This hardware has 6 pole jack");
+ 		} else {
+ 			mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = false;
+ 			dev_dbg(&pdev->dev, "Unknown value, hence setting to default");
+ 		}
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	ret = snd_soc_register_card(card);
  	if (ret == -EPROBE_DEFER)
  		goto err;
diff --cc sound/soc/msm/msm8974.c
index 92beb6e,9ee6b93..0000000
--- a/sound/soc/msm/msm8974.c
+++ b/sound/soc/msm/msm8974.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -122,6 -122,7 +126,10 @@@ static struct wcd9xxx_mbhc_config mbhc_
  	.read_fw_bin = true,
  	.calibration = NULL,
  	.micbias = MBHC_MICBIAS2,
++<<<<<<< HEAD
++=======
+ 	.anc_micbias = MBHC_MICBIAS2,
++>>>>>>> FETCH_HEAD
  	.mclk_cb_fn = msm_snd_enable_codec_ext_clk,
  	.mclk_rate = TAIKO_EXT_CLK_RATE,
  	.gpio = 0,
@@@ -133,9 -134,12 +141,18 @@@
  	.swap_gnd_mic = NULL,
  	.cs_enable_flags = (1 << MBHC_CS_ENABLE_POLLING |
  			    1 << MBHC_CS_ENABLE_INSERTION |
++<<<<<<< HEAD
 +			    1 << MBHC_CS_ENABLE_REMOVAL),
 +	.do_recalibration = true,
 +	.use_vddio_meas = true,
++=======
+ 			    1 << MBHC_CS_ENABLE_REMOVAL |
+ 			    1 << MBHC_CS_ENABLE_DET_ANC),
+ 	.do_recalibration = true,
+ 	.use_vddio_meas = true,
+ 	.enable_anc_mic_detect = false,
+ 	.hw_jack_type = SIX_POLE_JACK,
++>>>>>>> FETCH_HEAD
  };
  
  struct msm_auxpcm_gpio {
@@@ -167,12 -171,21 +184,27 @@@ static char *msm_prim_auxpcm_gpio_name[
  	{"PRIM_AUXPCM_DOUT",      "qcom,prim-auxpcm-gpio-dout"},
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PCM_ROUTE_VOICE_STUB
+ static char *msm_sec_auxpcm_gpio_name[][2] = {
+ 	{"SEC_AUXPCM_CLK",       "qcom,sec-auxpcm-gpio-clk_duos"},
+ 	{"SEC_AUXPCM_SYNC",      "qcom,sec-auxpcm-gpio-sync_duos"},
+ 	{"SEC_AUXPCM_DIN",       "qcom,sec-auxpcm-gpio-din_duos"},
+ 	{"SEC_AUXPCM_DOUT",      "qcom,sec-auxpcm-gpio-dout_duos"},
+ };
+ #else
++>>>>>>> FETCH_HEAD
  static char *msm_sec_auxpcm_gpio_name[][2] = {
  	{"SEC_AUXPCM_CLK",       "qcom,sec-auxpcm-gpio-clk"},
  	{"SEC_AUXPCM_SYNC",      "qcom,sec-auxpcm-gpio-sync"},
  	{"SEC_AUXPCM_DIN",       "qcom,sec-auxpcm-gpio-din"},
  	{"SEC_AUXPCM_DOUT",      "qcom,sec-auxpcm-gpio-dout"},
  };
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_PCM_ROUTE_VOICE_STUB */
++>>>>>>> FETCH_HEAD
  
  struct msm8974_liquid_dock_dev {
  	int dock_plug_gpio;
@@@ -1464,6 -1477,8 +1496,11 @@@ static int msm_slim_0_tx_be_hw_params_f
  			SNDRV_PCM_HW_PARAM_CHANNELS);
  
  	pr_debug("%s()\n", __func__);
++<<<<<<< HEAD
++=======
+ 	param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
+ 				   slim0_rx_bit_format);
++>>>>>>> FETCH_HEAD
  	rate->min = rate->max = 48000;
  	channels->min = channels->max = msm_slim_0_tx_ch;
  
@@@ -2055,6 -2070,7 +2092,10 @@@ static struct snd_soc_dai_link msm8974_
  		.cpu_dai_name	= "MultiMedia1",
  		.platform_name  = "msm-pcm-dsp.0",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2070,6 -2086,7 +2111,10 @@@
  		.cpu_dai_name   = "MultiMedia2",
  		.platform_name  = "msm-pcm-dsp.0",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.codec_dai_name = "snd-soc-dummy-dai",
  		.codec_name = "snd-soc-dummy",
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
@@@ -2085,6 -2102,7 +2130,10 @@@
  		.cpu_dai_name   = "CS-VOICE",
  		.platform_name  = "msm-pcm-voice",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.codec_dai_name = "snd-soc-dummy-dai",
  		.codec_name = "snd-soc-dummy",
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
@@@ -2101,6 -2119,7 +2150,10 @@@
  		.cpu_dai_name	= "VoIP",
  		.platform_name  = "msm-voip-dsp",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2116,6 -2135,7 +2169,10 @@@
  		.cpu_dai_name	= "MultiMedia3",
  		.platform_name  = "msm-pcm-lpa",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2132,6 -2152,7 +2189,10 @@@
  		.cpu_dai_name = "SLIMBUS0_HOSTLESS",
  		.platform_name = "msm-pcm-hostless",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			    SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2146,6 -2167,7 +2207,10 @@@
  		.cpu_dai_name	= "INT_FM_HOSTLESS",
  		.platform_name  = "msm-pcm-hostless",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2181,6 -2203,8 +2246,11 @@@
  		.cpu_dai_name	= "MultiMedia4",
  		.platform_name  = "msm-compress-dsp",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE
+ 			| ASYNC_DPCM_SND_SOC_HW_PARAMS,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			 SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2196,6 -2220,7 +2266,10 @@@
  		.cpu_dai_name   = "AUXPCM_HOSTLESS",
  		.platform_name  = "msm-pcm-hostless",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2211,6 -2236,7 +2285,10 @@@
  		.cpu_dai_name = "SLIMBUS1_HOSTLESS",
  		.platform_name = "msm-pcm-hostless",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			    SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2225,6 -2251,7 +2303,10 @@@
  		.cpu_dai_name = "SLIMBUS3_HOSTLESS",
  		.platform_name = "msm-pcm-hostless",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			    SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2239,6 -2266,7 +2321,10 @@@
  		.cpu_dai_name = "SLIMBUS4_HOSTLESS",
  		.platform_name = "msm-pcm-hostless",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			    SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2253,6 -2281,7 +2339,10 @@@
  		.cpu_dai_name   = "VoLTE",
  		.platform_name  = "msm-pcm-voice",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			    SND_SOC_DPCM_TRIGGER_POST},
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2269,6 -2298,7 +2359,10 @@@
  		.cpu_dai_name   = "MultiMedia5",
  		.platform_name  = "msm-pcm-dsp.1",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.codec_dai_name = "snd-soc-dummy-dai",
  		.codec_name = "snd-soc-dummy",
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
@@@ -2285,6 -2315,7 +2379,10 @@@
  		.cpu_dai_name = "LSM",
  		.platform_name = "msm-lsm-client",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
++>>>>>>> FETCH_HEAD
  		.trigger = { SND_SOC_DPCM_TRIGGER_POST,
  			     SND_SOC_DPCM_TRIGGER_POST },
  		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
@@@ -2301,6 -2332,8 +2399,11 @@@
  		.cpu_dai_name	= "MultiMedia6",
  		.platform_name  = "msm-compress-dsp",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE
+ 			| ASYNC_DPCM_SND_SOC_HW_PARAMS,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			 SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2316,6 -2349,8 +2419,11 @@@
  		.cpu_dai_name	= "MultiMedia7",
  		.platform_name  = "msm-compress-dsp",
  		.dynamic = 1,
++<<<<<<< HEAD
++=======
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE
+ 			| ASYNC_DPCM_SND_SOC_HW_PARAMS,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			 SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2329,8 -2364,10 +2437,15 @@@
  		.name = "MSM8974 Compr4",
  		.stream_name = "COMPR4",
  		.cpu_dai_name	= "MultiMedia8",
++<<<<<<< HEAD
 +		.platform_name  = "msm-compr-dsp",
 +		.dynamic = 1,
++=======
+ 		.platform_name  = "msm-compress-dsp",
+ 		.dynamic = 1,
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE
+ 			| ASYNC_DPCM_SND_SOC_HW_PARAMS,
++>>>>>>> FETCH_HEAD
  		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
  			 SND_SOC_DPCM_TRIGGER_POST},
  		.codec_dai_name = "snd-soc-dummy-dai",
@@@ -2372,6 -2409,56 +2487,59 @@@
  		.codec_name = "snd-soc-dummy",
  	},
  	{
++<<<<<<< HEAD
++=======
+ 		.name = "Voice2",
+ 		.stream_name = "Voice2",
+ 		.cpu_dai_name   = "Voice2",
+ 		.platform_name  = "msm-pcm-voice",
+ 		.dynamic = 1,
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
+ 		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+ 			    SND_SOC_DPCM_TRIGGER_POST},
+ 		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+ 		.ignore_suspend = 1,
+ 		/* this dainlink has playback support */
+ 		.ignore_pmdown_time = 1,
+ 		.codec_dai_name = "snd-soc-dummy-dai",
+ 		.codec_name = "snd-soc-dummy",
+ 		.be_id = MSM_FRONTEND_DAI_VOICE2,
+ 	},
+ 	{
+ 		.name = "INT_HFP_BT Hostless",
+ 		.stream_name = "INT_HFP_BT Hostless",
+ 		.cpu_dai_name   = "INT_HFP_BT_HOSTLESS",
+ 		.platform_name  = "msm-pcm-hostless",
+ 		.dynamic = 1,
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
+ 		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+ 			    SND_SOC_DPCM_TRIGGER_POST},
+ 		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+ 		.ignore_suspend = 1,
+ 		/* this dai link has playback support */
+ 		.ignore_pmdown_time = 1,
+ 		.codec_dai_name = "snd-soc-dummy-dai",
+ 		.codec_name = "snd-soc-dummy",
+ 	},
+ 	{
+ 		.name = "MSM8974 HFP TX",
+ 		.stream_name = "MultiMedia6",
+ 		.cpu_dai_name = "MultiMedia6",
+ 		.platform_name  = "msm-pcm-loopback",
+ 		.dynamic = 1,
+ 		.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,
+ 		.codec_dai_name = "snd-soc-dummy-dai",
+ 		.codec_name = "snd-soc-dummy",
+ 		.trigger = {SND_SOC_DPCM_TRIGGER_POST,
+ 			    SND_SOC_DPCM_TRIGGER_POST},
+ 		.ignore_suspend = 1,
+ 		.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,
+ 		/* this dainlink has playback support */
+ 		.ignore_pmdown_time = 1,
+ 		.be_id = MSM_FRONTEND_DAI_MULTIMEDIA6,
+ 	},
+ 	{
++>>>>>>> FETCH_HEAD
  		.name = LPASS_BE_SLIMBUS_4_TX,
  		.stream_name = "Slimbus4 Capture",
  		.cpu_dai_name = "msm-dai-q6-dev.16393",
@@@ -2489,7 -2576,7 +2657,11 @@@
  		.ignore_suspend = 1,
  	},
  #ifdef CONFIG_PCM_ROUTE_VOICE_STUB
++<<<<<<< HEAD
 +	{
++=======
+ 	{ // 25
++>>>>>>> FETCH_HEAD
  		.name = "Voice Stub", 
  		.stream_name = "Voice Stub", 
  		.cpu_dai_name = "VOICE_STUB", 
@@@ -2951,6 -3038,8 +3123,11 @@@ static __devinit int msm8974_asoc_machi
  	int ret;
  	const char *auxpcm_pri_gpio_set = NULL;
  	const char *prop_name_ult_lo_gpio = "qcom,ext-ult-lo-amp-gpio";
++<<<<<<< HEAD
++=======
+ 	const char *mbhc_audio_jack_type = NULL;
+ 	size_t n = strlen("4-pole-jack");
++>>>>>>> FETCH_HEAD
  	struct resource	*pri_muxsel;
  	struct resource	*sec_muxsel;
  
@@@ -3010,6 -3099,34 +3187,37 @@@
  	if (ret)
  		goto err;
  
++<<<<<<< HEAD
++=======
+ 	ret = of_property_read_string(pdev->dev.of_node,
+ 		"qcom,mbhc-audio-jack-type", &mbhc_audio_jack_type);
+ 	if (ret) {
+ 		dev_dbg(&pdev->dev, "Looking up %s property in node %s failed",
+ 			"qcom,mbhc-audio-jack-type",
+ 			pdev->dev.of_node->full_name);
+ 		mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 		mbhc_cfg.enable_anc_mic_detect = false;
+ 		dev_dbg(&pdev->dev, "Jack type properties set to default");
+ 	} else {
+ 		if (!strncmp(mbhc_audio_jack_type, "4-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = false;
+ 			dev_dbg(&pdev->dev, "This hardware has 4 pole jack");
+ 		} else if (!strncmp(mbhc_audio_jack_type, "5-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = FIVE_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = true;
+ 			dev_dbg(&pdev->dev, "This hardware has 5 pole jack");
+ 		} else if (!strncmp(mbhc_audio_jack_type, "6-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = SIX_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = true;
+ 			dev_dbg(&pdev->dev, "This hardware has 6 pole jack");
+ 		} else {
+ 			mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = false;
+ 			dev_dbg(&pdev->dev, "Unknown value, hence setting to default");
+ 		}
+ 	}
++>>>>>>> FETCH_HEAD
  	if (of_property_read_bool(pdev->dev.of_node, "qcom,hdmi-audio-rx")) {
  		dev_info(&pdev->dev, "%s(): hdmi audio support present\n",
  				__func__);
@@@ -3187,14 -3304,9 +3395,20 @@@
  			goto err1;
  		}
  	}
++<<<<<<< HEAD
 +#ifdef CONFIG_PCM_ROUTE_VOICE_STUB
 +      sec_muxsel = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 +						"lpaif_quat_mode_muxsel");
 +#else
 +	sec_muxsel = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 +						"lpaif_sec_mode_muxsel");
 +#endif /* CONFIG_PCM_ROUTE_VOICE_STUB */
 +
++=======
+ 
+ 	sec_muxsel = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+ 						"lpaif_sec_mode_muxsel");
++>>>>>>> FETCH_HEAD
  	if (!sec_muxsel) {
  		dev_err(&pdev->dev, "MUX addr invalid for secondary AUXPCM\n");
  		ret = -ENODEV;
diff --cc sound/soc/msm/msm8x10.c
index e480a53,642953d..0000000
--- a/sound/soc/msm/msm8x10.c
+++ b/sound/soc/msm/msm8x10.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 + /* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+  /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -110,11 -110,14 +114,20 @@@ static struct wcd9xxx_mbhc_config mbhc_
  	.insert_detect = true,
  	.swap_gnd_mic = NULL,
  	.use_int_rbias = false,
++<<<<<<< HEAD
++=======
+ 	.micbias_enable_flags = 1 << MBHC_MICBIAS_ENABLE_THRESHOLD_HEADSET |
+ 				1 << MBHC_MICBIAS_ENABLE_REGULAR_HEADSET,
++>>>>>>> FETCH_HEAD
  	.cs_enable_flags = (1 << MBHC_CS_ENABLE_POLLING |
  			    1 << MBHC_CS_ENABLE_INSERTION |
  			    1 << MBHC_CS_ENABLE_REMOVAL),
  	.do_recalibration = false,
  	.use_vddio_meas = false,
++<<<<<<< HEAD
++=======
+ 	.hw_jack_type = FOUR_POLE_JACK,
++>>>>>>> FETCH_HEAD
  };
  
  /*
@@@ -189,6 -192,8 +202,11 @@@ static const struct snd_soc_dapm_widge
  #endif
  	SND_SOC_DAPM_MIC("Headset Mic", NULL),
  	SND_SOC_DAPM_MIC("Secondary Mic", NULL),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_MIC("Digital Mic1", NULL),
+ 	SND_SOC_DAPM_MIC("Digital Mic2", NULL),
++>>>>>>> FETCH_HEAD
  };
  static int msm8x10_ext_spk_power_amp_init(void)
  {
@@@ -371,6 -376,8 +389,11 @@@ static int msm_tx_be_hw_params_fixup(st
  					SNDRV_PCM_HW_PARAM_CHANNELS);
  
  	pr_debug("%s(), channel:%d\n", __func__, msm_pri_mi2s_tx_ch);
++<<<<<<< HEAD
++=======
+ 	param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
+ 					msm_sec_mi2s_rx_bit_format);
++>>>>>>> FETCH_HEAD
  	rate->min = rate->max = 48000;
  	channels->min = channels->max = msm_pri_mi2s_tx_ch;
  
@@@ -712,21 -719,21 +735,39 @@@ static void *def_msm8x10_wcd_mbhc_cal(v
  	btn_high = wcd9xxx_mbhc_cal_btn_det_mp(btn_cfg,
  					       MBHC_BTN_DET_V_BTN_HIGH);
  	btn_low[0] = -50;
++<<<<<<< HEAD
 +	btn_high[0] = 10;
 +	btn_low[1] = 11;
 +	btn_high[1] = 52;
 +	btn_low[2] = 53;
 +	btn_high[2] = 94;
 +	btn_low[3] = 95;
 +	btn_high[3] = 133;
 +	btn_low[4] = 134;
 +	btn_high[4] = 171;
 +	btn_low[5] = 172;
 +	btn_high[5] = 208;
 +	btn_low[6] = 209;
 +	btn_high[6] = 244;
 +	btn_low[7] = 245;
 +	btn_high[7] = 330;
++=======
+ 	btn_high[0] = 20;
+ 	btn_low[1] = 21;
+ 	btn_high[1] = 61;
+ 	btn_low[2] = 62;
+ 	btn_high[2] = 104;
+ 	btn_low[3] = 105;
+ 	btn_high[3] = 148;
+ 	btn_low[4] = 149;
+ 	btn_high[4] = 189;
+ 	btn_low[5] = 190;
+ 	btn_high[5] = 228;
+ 	btn_low[6] = 229;
+ 	btn_high[6] = 269;
+ 	btn_low[7] = 270;
+ 	btn_high[7] = 500;
++>>>>>>> FETCH_HEAD
  	n_ready = wcd9xxx_mbhc_cal_btn_det_mp(btn_cfg, MBHC_BTN_DET_N_READY);
  	n_ready[0] = 80;
  	n_ready[1] = 68;
@@@ -1192,6 -1199,8 +1233,11 @@@ struct snd_soc_card snd_soc_card_msm8x1
  static __devinit int msm8x10_asoc_machine_probe(struct platform_device *pdev)
  {
  	struct snd_soc_card *card = &snd_soc_card_msm8x10;
++<<<<<<< HEAD
++=======
+ 	const char *mbhc_audio_jack_type = NULL;
+ 	size_t n = strlen("4-pole-jack");
++>>>>>>> FETCH_HEAD
  	int ret;
  
  	dev_dbg(&pdev->dev, "%s\n", __func__);
@@@ -1229,6 -1238,35 +1275,38 @@@
  	mbhc_cfg.use_int_rbias = of_property_read_bool(pdev->dev.of_node,
  						"qcom,mbhc-bias-internal");
  
++<<<<<<< HEAD
++=======
+ 	ret = of_property_read_string(pdev->dev.of_node,
+ 		"qcom,mbhc-audio-jack-type", &mbhc_audio_jack_type);
+ 	if (ret) {
+ 		dev_dbg(&pdev->dev, "Looking up %s property in node %s failed",
+ 			"qcom,mbhc-audio-jack-type",
+ 			pdev->dev.of_node->full_name);
+ 		mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 		mbhc_cfg.enable_anc_mic_detect = false;
+ 		dev_dbg(&pdev->dev, "Jack type properties set to default");
+ 	} else {
+ 		if (!strncmp(mbhc_audio_jack_type, "4-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = false;
+ 			dev_dbg(&pdev->dev, "This hardware has 4 pole jack");
+ 		} else if (!strncmp(mbhc_audio_jack_type, "5-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = FIVE_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = true;
+ 			dev_dbg(&pdev->dev, "This hardware has 5 pole jack");
+ 		} else if (!strncmp(mbhc_audio_jack_type, "6-pole-jack", n)) {
+ 			mbhc_cfg.hw_jack_type = SIX_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = true;
+ 			dev_dbg(&pdev->dev, "This hardware has 6 pole jack");
+ 		} else {
+ 			mbhc_cfg.hw_jack_type = FOUR_POLE_JACK;
+ 			mbhc_cfg.enable_anc_mic_detect = false;
+ 			dev_dbg(&pdev->dev, "Unknown value, hence setting to default");
+ 		}
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	spdev = pdev;
  
  	ret = snd_soc_register_card(card);
diff --cc sound/soc/msm/qdsp6v2/Makefile
index ea16f47,f0f5db6..0000000
--- a/sound/soc/msm/qdsp6v2/Makefile
+++ b/sound/soc/msm/qdsp6v2/Makefile
@@@ -3,7 -3,8 +3,12 @@@ snd-soc-qdsp6v2-objs += msm-dai-q6-v2.
  			msm-multi-ch-pcm-q6-v2.o msm-pcm-lpa-v2.o \
  			msm-pcm-afe-v2.o msm-pcm-voip-v2.o \
  			msm-pcm-voice-v2.o msm-dai-q6-hdmi-v2.o \
++<<<<<<< HEAD
 +			msm-lsm-client.o msm-audio-effects-q6-v2.o
++=======
+ 			msm-lsm-client.o msm-audio-effects-q6-v2.o \
+ 			msm-pcm-loopback-v2.o
++>>>>>>> FETCH_HEAD
  obj-$(CONFIG_SND_SOC_QDSP6V2) += snd-soc-qdsp6v2.o msm-pcm-dtmf-v2.o \
  				 msm-dai-stub-v2.o
  obj-$(CONFIG_DOLBY_DAP) += msm-dolby-dap-config.o
diff --cc sound/soc/msm/qdsp6v2/audio_acdb.c
index 58c3cdf,4e04bef..0000000
--- a/sound/soc/msm/qdsp6v2/audio_acdb.c
+++ b/sound/soc/msm/qdsp6v2/audio_acdb.c
@@@ -405,9 -405,9 +405,15 @@@ int get_hw_delay(int32_t path, struct h
  
  done:
  	mutex_unlock(&acdb_data.acdb_mutex);
++<<<<<<< HEAD
 +ret:
 +	pr_debug("ACDB=> %s: Path = %d samplerate = %u usec = %u status %d\n",
 +		 __func__, path, entry->sample_rate, entry->delay_usec, result);
++=======
+ 	pr_debug("ACDB=> %s: Path = %d samplerate = %u usec = %u status %d\n",
+ 		 __func__, path, entry->sample_rate, entry->delay_usec, result);
+ ret:
++>>>>>>> FETCH_HEAD
  	return result;
  }
  
diff --cc sound/soc/msm/qdsp6v2/audio_ocmem.c
index 4a25606,dd1eadd..0000000
--- a/sound/soc/msm/qdsp6v2/audio_ocmem.c
+++ b/sound/soc/msm/qdsp6v2/audio_ocmem.c
@@@ -22,8 -22,8 +22,13 @@@
  #include <linux/slab.h>
  #include <linux/io.h>
  #include <linux/of_device.h>
++<<<<<<< HEAD
 +#include <linux/memory_alloc.h>
 +#include <asm/mach-types.h>
++=======
+ #include <asm/mach-types.h>
+ #include <linux/dma-mapping.h>
++>>>>>>> FETCH_HEAD
  #include <mach/msm_bus.h>
  #include <mach/msm_bus_board.h>
  #include <mach/ocmem.h>
@@@ -132,7 -132,8 +137,12 @@@ struct audio_ocmem_prv 
  	bool audio_ocmem_running;
  	void *ocmem_ramdump_dev;
  	struct ramdump_segment ocmem_ramdump_segment;
++<<<<<<< HEAD
 +	unsigned long ocmem_dump_addr;
++=======
+ 	dma_addr_t ocmem_dump_addr;
+ 	void *ocmem_dump_virt;
++>>>>>>> FETCH_HEAD
  };
  
  static struct audio_ocmem_prv audio_ocmem_lcl;
@@@ -536,6 -537,7 +546,10 @@@ fail_cmd2
  	mutex_unlock(&audio_ocmem_lcl.state_process_lock);
  fail_cmd:
  	pr_debug("%s: exit\n", __func__);
++<<<<<<< HEAD
++=======
+ 	audio_ocmem_lcl.buf = NULL;
++>>>>>>> FETCH_HEAD
  	audio_ocmem_lcl.audio_ocmem_running = false;
  	return ret;
  }
@@@ -777,13 -779,10 +791,20 @@@ static int audio_ocmem_platform_data_po
  static void do_ocmem_ramdump(void)
  {
  	int ret = 0;
++<<<<<<< HEAD
 +	void *virt = NULL;
 +
 +	virt = ioremap(audio_ocmem_lcl.ocmem_dump_addr, AUDIO_OCMEM_BUF_SIZE);
 +	ret = ocmem_dump(OCMEM_LP_AUDIO,
 +			 audio_ocmem_lcl.buf,
 +			 (unsigned long)virt);
 +	iounmap(virt);
++=======
+ 
+ 	ret = ocmem_dump(OCMEM_LP_AUDIO,
+ 			 audio_ocmem_lcl.buf,
+ 			 (unsigned long)audio_ocmem_lcl.ocmem_dump_virt);
++>>>>>>> FETCH_HEAD
  
  	if (ret)
  		pr_err("%s: ocmem_dump failed\n", __func__);
@@@ -834,6 -833,7 +855,10 @@@ static void process_ocmem_dump(void
  	ret = ocmem_free(OCMEM_LP_AUDIO, audio_ocmem_lcl.buf);
  	if (ret)
  		pr_err("%s: ocmem_free failed\n", __func__);
++<<<<<<< HEAD
++=======
+ 	audio_ocmem_lcl.buf = NULL;
++>>>>>>> FETCH_HEAD
  }
  
  static int lpass_notifier_cb(struct notifier_block *this, unsigned long code,
@@@ -890,12 -890,12 +915,21 @@@ static int ocmem_audio_client_probe(str
  	}
  	subsys_notif_register_notifier("adsp", &anb);
  
++<<<<<<< HEAD
 +	audio_ocmem_lcl.ocmem_dump_addr =
 +		allocate_contiguous_memory_nomap(AUDIO_OCMEM_BUF_SIZE,
 +						 MEMTYPE_EBI1,
 +						 AUDIO_OCMEM_BUF_SIZE);
 +
 +	if (audio_ocmem_lcl.ocmem_dump_addr) {
++=======
+ 	audio_ocmem_lcl.ocmem_dump_virt = dma_alloc_coherent(NULL,
+ 					AUDIO_OCMEM_BUF_SIZE,
+ 					&audio_ocmem_lcl.ocmem_dump_addr,
+ 					GFP_KERNEL);
+ 
+ 	if (audio_ocmem_lcl.ocmem_dump_virt) {
++>>>>>>> FETCH_HEAD
  		audio_ocmem_lcl.ocmem_ramdump_dev =
  			create_ramdump_device("audio-ocmem", &pdev->dev);
  
@@@ -968,9 -968,10 +1002,16 @@@ destroy_audio_wq
  destroy_ramdump:
  	if (audio_ocmem_lcl.ocmem_ramdump_dev)
  		destroy_ramdump_device(audio_ocmem_lcl.ocmem_ramdump_dev);
++<<<<<<< HEAD
 +	if (audio_ocmem_lcl.ocmem_dump_addr)
 +		free_contiguous_memory_by_paddr(
 +		    audio_ocmem_lcl.ocmem_dump_addr);
++=======
+ 	if (audio_ocmem_lcl.ocmem_dump_virt)
+ 		dma_free_coherent(NULL, AUDIO_OCMEM_BUF_SIZE,
+ 			audio_ocmem_lcl.ocmem_dump_virt,
+ 			audio_ocmem_lcl.ocmem_dump_addr);
++>>>>>>> FETCH_HEAD
  	return ret;
  }
  
@@@ -986,9 -987,11 +1027,17 @@@ static int ocmem_audio_client_remove(st
  					&audio_ocmem_client_nb);
  	if (audio_ocmem_lcl.ocmem_ramdump_dev)
  		destroy_ramdump_device(audio_ocmem_lcl.ocmem_ramdump_dev);
++<<<<<<< HEAD
 +	if (audio_ocmem_lcl.ocmem_dump_addr)
 +		free_contiguous_memory_by_paddr(
 +		    audio_ocmem_lcl.ocmem_dump_addr);
++=======
+ 
+ 	if (audio_ocmem_lcl.ocmem_dump_virt)
+ 		dma_free_coherent(NULL, AUDIO_OCMEM_BUF_SIZE,
+ 			audio_ocmem_lcl.ocmem_dump_virt,
+ 			audio_ocmem_lcl.ocmem_dump_addr);
++>>>>>>> FETCH_HEAD
  
  	return 0;
  }
diff --cc sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
index bb325d8,4bedd0c..0000000
--- a/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
@@@ -373,11 -373,67 +373,75 @@@ static int msm_compr_playback_prepare(s
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
  	struct compr_audio *compr = runtime->private_data;
++<<<<<<< HEAD
 +	struct msm_audio *prtd = &compr->prtd;
 +	struct asm_aac_cfg aac_cfg;
 +	int ret;
 +
 +	pr_debug("compressed stream prepare\n");
++=======
+ 	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+ 	struct msm_audio *prtd = &compr->prtd;
+ 	struct snd_pcm_hw_params *params;
+ 	struct asm_aac_cfg aac_cfg;
+ 	uint16_t bits_per_sample = 16;
+ 	int ret;
+ 
+ 	struct asm_softpause_params softpause = {
+ 		.enable = SOFT_PAUSE_ENABLE,
+ 		.period = SOFT_PAUSE_PERIOD,
+ 		.step = SOFT_PAUSE_STEP,
+ 		.rampingcurve = SOFT_PAUSE_CURVE_LINEAR,
+ 	};
+ 	struct asm_softvolume_params softvol = {
+ 		.period = SOFT_VOLUME_PERIOD,
+ 		.step = SOFT_VOLUME_STEP,
+ 		.rampingcurve = SOFT_VOLUME_CURVE_LINEAR,
+ 	};
+ 
+ 	pr_debug("%s\n", __func__);
+ 
+ 	params = &soc_prtd->dpcm[substream->stream].hw_params;
+ 	if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
+ 		bits_per_sample = 24;
+ 
+ 	ret = q6asm_open_write_v2(prtd->audio_client,
+ 			compr->codec, bits_per_sample);
+ 	if (ret < 0) {
+ 		pr_err("%s: Session out open failed\n",
+ 				__func__);
+ 		return -ENOMEM;
+ 	}
+ 	msm_pcm_routing_reg_phy_stream(
+ 			soc_prtd->dai_link->be_id,
+ 			prtd->audio_client->perf_mode,
+ 			prtd->session_id,
+ 			substream->stream);
+ 	/*
+ 	 * the number of channels are required to call volume api
+ 	 * accoridngly. So, get channels from hw params
+ 	 */
+ 	if ((params_channels(params) > 0) &&
+ 			(params_periods(params) <= runtime->hw.channels_max))
+ 		prtd->channel_mode = params_channels(params);
+ 
+ 	ret = q6asm_set_softpause(prtd->audio_client, &softpause);
+ 	if (ret < 0)
+ 		pr_err("%s: Send SoftPause Param failed ret=%d\n",
+ 				__func__, ret);
+ 	ret = q6asm_set_softvolume(prtd->audio_client, &softvol);
+ 	if (ret < 0)
+ 		pr_err("%s: Send SoftVolume Param failed ret=%d\n",
+ 				__func__, ret);
+ 
+ 	ret = q6asm_set_io_mode(prtd->audio_client,
+ 			(COMPRESSED_IO | ASYNC_IO_MODE));
+ 	if (ret < 0) {
+ 		pr_err("%s: Set IO mode failed\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
  	prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
  	prtd->pcm_irq_pos = 0;
@@@ -442,13 -498,68 +506,77 @@@ static int msm_compr_capture_prepare(st
  	struct msm_audio *prtd = &compr->prtd;
  	struct audio_buffer *buf = prtd->audio_client->port[OUT].buf;
  	struct snd_codec *codec = &compr->info.codec_param.codec;
++<<<<<<< HEAD
 +	struct audio_aio_read_param read_param;
 +	int ret = 0;
 +	int i;
++=======
+ 	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+ 	struct audio_aio_read_param read_param;
+ 	uint16_t bits_per_sample = 16;
+ 	int ret = 0;
+ 	int i;
+ 
++>>>>>>> FETCH_HEAD
  	prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
  	prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
  	prtd->pcm_irq_pos = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
+ 		bits_per_sample = 24;
+ 
+ 	if (!msm_compr_capture_codecs(
+ 				compr->info.codec_param.codec.id)) {
+ 		/*
+ 		 * request codec invalid or not supported,
+ 		 * use default compress format
+ 		 */
+ 		compr->info.codec_param.codec.id =
+ 			SND_AUDIOCODEC_AMRWB;
+ 	}
+ 	switch (compr->info.codec_param.codec.id) {
+ 	case SND_AUDIOCODEC_AMRWB:
+ 		pr_debug("q6asm_open_read(FORMAT_AMRWB)\n");
+ 		ret = q6asm_open_read(prtd->audio_client,
+ 				FORMAT_AMRWB);
+ 		if (ret < 0) {
+ 			pr_err("%s: compressed Session out open failed\n",
+ 					__func__);
+ 			return -ENOMEM;
+ 		}
+ 		pr_debug("msm_pcm_routing_reg_phy_stream\n");
+ 		msm_pcm_routing_reg_phy_stream(
+ 				soc_prtd->dai_link->be_id,
+ 				prtd->audio_client->perf_mode,
+ 				prtd->session_id, substream->stream);
+ 		break;
+ 	default:
+ 		pr_debug("q6asm_open_read_compressed(COMPRESSED_META_DATA_MODE)\n");
+ 		/*
+ 		   ret = q6asm_open_read_compressed(prtd->audio_client,
+ 		   MAX_NUM_FRAMES_PER_BUFFER,
+ 		   COMPRESSED_META_DATA_MODE);
+ 		 */
+ 			ret = -EINVAL;
+ 			break;
+ 	}
+ 
+ 	if (ret < 0) {
+ 		pr_err("%s: compressed Session out open failed\n",
+ 				__func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	ret = q6asm_set_io_mode(prtd->audio_client,
+ 		(COMPRESSED_IO | ASYNC_IO_MODE));
+ 		if (ret < 0) {
+ 			pr_err("%s: Set IO mode failed\n", __func__);
+ 				return -ENOMEM;
+ 		}
+ 
++>>>>>>> FETCH_HEAD
  	if (!msm_compr_capture_codecs(codec->id)) {
  		/*request codec invalid or not supported,
  		use default compress format*/
@@@ -757,6 -868,7 +885,10 @@@ static int msm_compr_close(struct snd_p
  		ret = msm_compr_capture_close(substream);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_prepare(struct snd_pcm_substream *substream)
  {
  	int ret = 0;
@@@ -810,114 -922,17 +942,124 @@@ static int msm_compr_hw_params(struct s
  				struct snd_pcm_hw_params *params)
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
++<<<<<<< HEAD
 +	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
++=======
++>>>>>>> FETCH_HEAD
  	struct compr_audio *compr = runtime->private_data;
  	struct msm_audio *prtd = &compr->prtd;
  	struct snd_dma_buffer *dma_buf = &substream->dma_buffer;
  	struct audio_buffer *buf;
  	int dir, ret;
++<<<<<<< HEAD
 +	uint16_t bits_per_sample = 16;
 +
 +	struct asm_softpause_params softpause = {
 +		.enable = SOFT_PAUSE_ENABLE,
 +		.period = SOFT_PAUSE_PERIOD,
 +		.step = SOFT_PAUSE_STEP,
 +		.rampingcurve = SOFT_PAUSE_CURVE_LINEAR,
 +	};
 +	struct asm_softvolume_params softvol = {
 +		.period = SOFT_VOLUME_PERIOD,
 +		.step = SOFT_VOLUME_STEP,
 +		.rampingcurve = SOFT_VOLUME_CURVE_LINEAR,
 +	};
 +
 +	pr_debug("%s\n", __func__);
++=======
+ 
++>>>>>>> FETCH_HEAD
  	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
  		dir = IN;
  	else
  		dir = OUT;
  
++<<<<<<< HEAD
 +	if (runtime->format == SNDRV_PCM_FORMAT_S24_LE)
 +		bits_per_sample = 24;
 +
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 +		ret = q6asm_open_write_v2(prtd->audio_client,
 +				compr->codec, bits_per_sample);
 +		if (ret < 0) {
 +			pr_err("%s: Session out open failed\n",
 +				__func__);
 +			return -ENOMEM;
 +		}
 +		msm_pcm_routing_reg_phy_stream(
 +			soc_prtd->dai_link->be_id,
 +			prtd->audio_client->perf_mode,
 +			prtd->session_id,
 +			substream->stream);
 +		/* the number of channels are required to call volume api
 +		   accoridngly. So, get channels from hw params */
 +		if ((params_channels(params) > 0) &&
 +		    (params_periods(params) <= runtime->hw.channels_max))
 +			prtd->channel_mode = params_channels(params);
 +
 +		ret = compressed_set_volume(prtd, 0);
 +		if (ret < 0)
 +			pr_err("%s : Set Volume failed : %d", __func__, ret);
 +
 +		ret = q6asm_set_softpause(prtd->audio_client, &softpause);
 +		if (ret < 0)
 +			pr_err("%s: Send SoftPause Param failed ret=%d\n",
 +				__func__, ret);
 +		ret = q6asm_set_softvolume(prtd->audio_client, &softvol);
 +		if (ret < 0)
 +			pr_err("%s: Send SoftVolume Param failed ret=%d\n",
 +				__func__, ret);
 +	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 +		if (!msm_compr_capture_codecs(
 +			compr->info.codec_param.codec.id)) {
 +			/*request codec invalid or not supported,
 +			use default compress format*/
 +			compr->info.codec_param.codec.id =
 +				SND_AUDIOCODEC_AMRWB;
 +		}
 +		switch (compr->info.codec_param.codec.id) {
 +		case SND_AUDIOCODEC_AMRWB:
 +			pr_debug("q6asm_open_read(FORMAT_AMRWB)\n");
 +			ret = q6asm_open_read(prtd->audio_client,
 +				FORMAT_AMRWB);
 +			if (ret < 0) {
 +				pr_err("%s: compressed Session out open failed\n",
 +					__func__);
 +				return -ENOMEM;
 +			}
 +			pr_debug("msm_pcm_routing_reg_phy_stream\n");
 +			msm_pcm_routing_reg_phy_stream(
 +					soc_prtd->dai_link->be_id,
 +					prtd->audio_client->perf_mode,
 +					prtd->session_id, substream->stream);
 +			break;
 +		default:
 +			pr_debug("q6asm_open_read_compressed(COMPRESSED_META_DATA_MODE)\n");
 +			/*
 +			ret = q6asm_open_read_compressed(prtd->audio_client,
 +				MAX_NUM_FRAMES_PER_BUFFER,
 +				COMPRESSED_META_DATA_MODE);
 +			*/
 +			ret = -EINVAL;
 +			break;
 +		}
 +
 +		if (ret < 0) {
 +			pr_err("%s: compressed Session out open failed\n",
 +				__func__);
 +			return -ENOMEM;
 +		}
 +	}
 +
 +	ret = q6asm_set_io_mode(prtd->audio_client,
 +					(COMPRESSED_IO | ASYNC_IO_MODE));
 +	if (ret < 0) {
 +		pr_err("%s: Set IO mode failed\n", __func__);
 +		return -ENOMEM;
 +	}
++=======
++>>>>>>> FETCH_HEAD
  	/* Modifying kernel hardware params based on userspace config */
  	if (params_periods(params) > 0 &&
  		(params_periods(params) != runtime->hw.periods_max)) {
@@@ -961,7 -976,7 +1103,11 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int msm_compr_ioctl(struct snd_pcm_substream *substream,
++=======
+ static int msm_compr_ioctl_shared(struct snd_pcm_substream *substream,
++>>>>>>> FETCH_HEAD
  		unsigned int cmd, void *arg)
  {
  	int rc = 0;
@@@ -973,10 -988,10 +1119,17 @@@
  
  	switch (cmd) {
  	case SNDRV_COMPRESS_TSTAMP: {
++<<<<<<< HEAD
 +		struct snd_compr_tstamp tstamp;
 +		pr_debug("SNDRV_COMPRESS_TSTAMP\n");
 +
 +		memset(&tstamp, 0x0, sizeof(struct snd_compr_tstamp));
++=======
+ 		struct snd_compr_tstamp *tstamp;
+ 		pr_debug("SNDRV_COMPRESS_TSTAMP\n");
+ 		tstamp = arg;
+ 		memset(tstamp, 0x0, sizeof(*tstamp));
++>>>>>>> FETCH_HEAD
  		rc = q6asm_get_session_time(prtd->audio_client, &timestamp);
  		if (rc < 0) {
  			pr_err("%s: Get Session Time return value =%lld\n",
@@@ -986,33 -1001,25 +1139,55 @@@
  		temp = (timestamp * 2 * runtime->channels);
  		temp = temp * (runtime->rate/1000);
  		temp = div_u64(temp, 1000);
++<<<<<<< HEAD
 +		tstamp.sampling_rate = runtime->rate;
 +		tstamp.timestamp = timestamp;
 +		pr_debug("%s: bytes_consumed:,timestamp = %lld,\n",
 +						__func__,
 +			tstamp.timestamp);
 +		if (copy_to_user((void *) arg, &tstamp,
 +			sizeof(struct snd_compr_tstamp)))
 +				return -EFAULT;
 +		return 0;
 +	}
 +	case SNDRV_COMPRESS_GET_CAPS:
 +		pr_debug("SNDRV_COMPRESS_GET_CAPS\n");
 +		if (copy_to_user((void *) arg, &compr->info.compr_cap,
 +			sizeof(struct snd_compr_caps))) {
 +			rc = -EFAULT;
 +			pr_err("%s: ERROR: copy to user\n", __func__);
 +			return rc;
 +		}
 +		return 0;
 +	case SNDRV_COMPRESS_SET_PARAMS:
 +		pr_debug("SNDRV_COMPRESS_SET_PARAMS:\n");
 +		if (copy_from_user(&compr->info.codec_param, (void *) arg,
 +			sizeof(struct snd_compr_params))) {
 +			rc = -EFAULT;
 +			pr_err("%s: ERROR: copy from user\n", __func__);
 +			return rc;
 +		}
++=======
+ 		tstamp->sampling_rate = runtime->rate;
+ 		tstamp->timestamp = timestamp;
+ 		pr_debug("%s: bytes_consumed:,timestamp = %lld,\n",
+ 						__func__,
+ 			tstamp->timestamp);
+ 		return 0;
+ 	}
+ 	case SNDRV_COMPRESS_GET_CAPS: {
+ 		struct snd_compr_caps *caps;
+ 		caps = arg;
+ 		memset(caps, 0, sizeof(*caps));
+ 		pr_debug("SNDRV_COMPRESS_GET_CAPS\n");
+ 		memcpy(caps, &compr->info.compr_cap, sizeof(*caps));
+ 		return 0;
+ 	}
+ 	case SNDRV_COMPRESS_SET_PARAMS:
+ 		pr_debug("SNDRV_COMPRESS_SET_PARAMS:\n");
+ 		memcpy(&compr->info.codec_param, (void *) arg,
+ 			sizeof(struct snd_compr_params));
++>>>>>>> FETCH_HEAD
  		switch (compr->info.codec_param.codec.id) {
  		case SND_AUDIOCODEC_MP3:
  			/* For MP3 we dont need any other parameter */
@@@ -1030,12 -1037,19 +1205,28 @@@
  			int i;
  			struct snd_dec_ddp *ddp =
  				&compr->info.codec_param.codec.options.ddp;
++<<<<<<< HEAD
 +			uint32_t params_length = ddp->params_length*sizeof(int);
 +			if (params_length > MAX_AC3_PARAM_SIZE) {
 +				/*MAX is 36*sizeof(int) this should not happen*/
 +				pr_err("params_length(%d) is greater than %d",
 +				params_length, MAX_AC3_PARAM_SIZE);
 +				params_length = MAX_AC3_PARAM_SIZE;
++=======
+ 			uint32_t params_length = 0;
+ 			/* check integer overflow */
+ 			if (ddp->params_length > UINT_MAX/sizeof(int)) {
+ 				pr_err("%s: Integer overflow ddp->params_length %d\n",
+ 				__func__, ddp->params_length);
+ 				return -EINVAL;
+ 			}
+ 			params_length = ddp->params_length*sizeof(int);
+ 			if (params_length > MAX_AC3_PARAM_SIZE) {
+ 				/*MAX is 36*sizeof(int) this should not happen*/
+ 				pr_err("%s: params_length(%d) is greater than %zd\n",
+ 				__func__, params_length, MAX_AC3_PARAM_SIZE);
+ 				return -EINVAL;
++>>>>>>> FETCH_HEAD
  			}
  			pr_debug("SND_AUDIOCODEC_AC3\n");
  			compr->codec = FORMAT_AC3;
@@@ -1044,7 -1058,7 +1235,11 @@@
  				pr_err("%s: copy ddp params value, size=%d\n",
  					__func__, params_length);
  			pr_debug("params_length: %d\n", ddp->params_length);
++<<<<<<< HEAD
 +			for (i = 0; i < params_length; i++)
++=======
+ 			for (i = 0; i < params_length/sizeof(int); i++)
++>>>>>>> FETCH_HEAD
  				pr_debug("params_value[%d]: %x\n", i,
  					params_value_data[i]);
  			for (i = 0; i < ddp->params_length/2; i++) {
@@@ -1067,12 -1081,18 +1262,27 @@@
  			int i;
  			struct snd_dec_ddp *ddp =
  				&compr->info.codec_param.codec.options.ddp;
++<<<<<<< HEAD
 +			uint32_t params_length = ddp->params_length*sizeof(int);
 +			if (params_length > MAX_AC3_PARAM_SIZE) {
 +				/*MAX is 36*sizeof(int) this should not happen*/
 +				pr_err("params_length(%d) is greater than %d",
 +				params_length, MAX_AC3_PARAM_SIZE);
 +				params_length = MAX_AC3_PARAM_SIZE;
++=======
+ 			uint32_t params_length = 0;
+ 			/* check integer overflow */
+ 			if (ddp->params_length > UINT_MAX/sizeof(int)) {
+ 				pr_err("%s: Integer overflow ddp->params_length %d\n",
+ 				__func__, ddp->params_length);
+ 				return -EINVAL;
+ 			}
+ 			if (params_length > MAX_AC3_PARAM_SIZE) {
+ 				/*MAX is 36*sizeof(int) this should not happen*/
+ 				pr_err("%s: params_length(%d) is greater than %d\n",
+ 				__func__, params_length, MAX_AC3_PARAM_SIZE);
+ 				return -EINVAL;
++>>>>>>> FETCH_HEAD
  			}
  			pr_debug("SND_AUDIOCODEC_EAC3\n");
  			compr->codec = FORMAT_EAC3;
@@@ -1162,6 -1182,342 +1372,345 @@@
  	}
  	return snd_pcm_lib_ioctl(substream, cmd, arg);
  }
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_COMPAT
+ struct snd_enc_wma32 {
+ 	u32 super_block_align; /* WMA Type-specific data */
+ 	u32 encodeopt1;
+ 	u32 encodeopt2;
+ };
+ 
+ struct snd_enc_vorbis32 {
+ 	s32 quality;
+ 	u32 managed;
+ 	u32 max_bit_rate;
+ 	u32 min_bit_rate;
+ 	u32 downmix;
+ };
+ 
+ struct snd_enc_real32 {
+ 	u32 quant_bits;
+ 	u32 start_region;
+ 	u32 num_regions;
+ };
+ 
+ struct snd_enc_flac32 {
+ 	u32 num;
+ 	u32 gain;
+ };
+ 
+ struct snd_enc_generic32 {
+ 	u32 bw;	/* encoder bandwidth */
+ 	s32 reserved[15];
+ };
+ struct snd_dec_dts32 {
+ 	u32 modelIdLength;
+ 	compat_uptr_t modelId;
+ };
+ struct snd_dec_ddp32 {
+ 	u32 params_length;
+ 	compat_uptr_t params;
+ 	u32 params_id[18];
+ 	u32 params_value[18];
+ };
+ 
+ union snd_codec_options32 {
+ 	struct snd_enc_wma32 wma;
+ 	struct snd_enc_vorbis32 vorbis;
+ 	struct snd_enc_real32 real;
+ 	struct snd_enc_flac32 flac;
+ 	struct snd_enc_generic32 generic;
+ 	struct snd_dec_dts32 dts;
+ 	struct snd_dec_ddp32 ddp;
+ };
+ 
+ struct snd_codec32 {
+ 	u32 id;
+ 	u32 ch_in;
+ 	u32 ch_out;
+ 	u32 sample_rate;
+ 	u32 bit_rate;
+ 	u32 rate_control;
+ 	u32 profile;
+ 	u32 level;
+ 	u32 ch_mode;
+ 	u32 format;
+ 	u32 align;
+ 	u32 transcode_dts;
+ 	struct snd_dec_dts32 dts;
+ 	union snd_codec_options32 options;
+ 	u32 reserved[3];
+ };
+ 
+ struct snd_compressed_buffer32 {
+ 	u32 fragment_size;
+ 	u32 fragments;
+ };
+ 
+ struct snd_compr_params32 {
+ 	struct snd_compressed_buffer32 buffer;
+ 	struct snd_codec32 codec;
+ 	u8 no_wake_mode;
+ };
+ 
+ struct snd_compr_caps32 {
+ 	u32 num_codecs;
+ 	u32 direction;
+ 	u32 min_fragment_size;
+ 	u32 max_fragment_size;
+ 	u32 min_fragments;
+ 	u32 max_fragments;
+ 	u32 codecs[MAX_NUM_CODECS];
+ 	u32 reserved[11];
+ };
+ struct snd_compr_tstamp32 {
+ 	u32 byte_offset;
+ 	u32 copied_total;
+ 	compat_ulong_t pcm_frames;
+ 	compat_ulong_t pcm_io_frames;
+ 	u32 sampling_rate;
+ 	compat_u64 timestamp;
+ };
+ enum {
+ 	SNDRV_COMPRESS_TSTAMP32 = _IOR('C', 0x20, struct snd_compr_tstamp32),
+ 	SNDRV_COMPRESS_GET_CAPS32 = _IOWR('C', 0x10, struct snd_compr_caps32),
+ 	SNDRV_COMPRESS_SET_PARAMS32 =
+ 	_IOW('C', 0x12, struct snd_compr_params32),
+ };
+ static int msm_compr_compat_ioctl(struct snd_pcm_substream *substream,
+ 		unsigned int cmd, void *arg)
+ {
+ 	int err = 0;
+ 	switch (cmd) {
+ 	case SNDRV_COMPRESS_TSTAMP32: {
+ 		struct snd_compr_tstamp tstamp;
+ 		struct snd_compr_tstamp32 tstamp32;
+ 		memset(&tstamp, 0, sizeof(tstamp));
+ 		memset(&tstamp32, 0, sizeof(tstamp32));
+ 		cmd = SNDRV_COMPRESS_TSTAMP;
+ 		err = msm_compr_ioctl_shared(substream, cmd, &tstamp);
+ 		if (err) {
+ 			pr_err("%s: COMPRESS_TSTAMP failed rc %d\n",
+ 			__func__, err);
+ 			goto bail_out;
+ 		}
+ 		tstamp32.byte_offset = tstamp.byte_offset;
+ 		tstamp32.copied_total = tstamp.copied_total;
+ 		tstamp32.pcm_frames = tstamp.pcm_frames;
+ 		tstamp32.pcm_io_frames = tstamp.pcm_io_frames;
+ 		tstamp32.sampling_rate = tstamp.sampling_rate;
+ 		tstamp32.timestamp = tstamp.timestamp;
+ 		if (copy_to_user(arg, &tstamp32, sizeof(tstamp32))) {
+ 			pr_err("%s: copytouser failed COMPRESS_TSTAMP32\n",
+ 			__func__);
+ 			err = -EFAULT;
+ 		}
+ 		break;
+ 	}
+ 	case SNDRV_COMPRESS_GET_CAPS32: {
+ 		struct snd_compr_caps caps;
+ 		struct snd_compr_caps32 caps32;
+ 		u32 i;
+ 		memset(&caps, 0, sizeof(caps));
+ 		memset(&caps32, 0, sizeof(caps32));
+ 		cmd = SNDRV_COMPRESS_GET_CAPS;
+ 		err = msm_compr_ioctl_shared(substream, cmd, &caps);
+ 		if (err) {
+ 			pr_err("%s: GET_CAPS failed rc %d\n",
+ 			__func__, err);
+ 			goto bail_out;
+ 		}
+ 		pr_debug("SNDRV_COMPRESS_GET_CAPS_32\n");
+ 		if (!err && caps.num_codecs >= MAX_NUM_CODECS) {
+ 			pr_err("%s: Invalid number of codecs\n", __func__);
+ 			err = -EINVAL;
+ 			goto bail_out;
+ 		}
+ 		caps32.direction = caps.direction;
+ 		caps32.max_fragment_size = caps.max_fragment_size;
+ 		caps32.max_fragments = caps.max_fragments;
+ 		caps32.min_fragment_size = caps.min_fragment_size;
+ 		caps32.num_codecs = caps.num_codecs;
+ 		for (i = 0; i < caps.num_codecs; i++)
+ 			caps32.codecs[i] = caps.codecs[i];
+ 		if (copy_to_user(arg, &caps32, sizeof(caps32))) {
+ 			pr_err("%s: copytouser failed COMPRESS_GETCAPS32\n",
+ 			__func__);
+ 			err = -EFAULT;
+ 		}
+ 		break;
+ 	}
+ 	case SNDRV_COMPRESS_SET_PARAMS32: {
+ 		struct snd_compr_params32 params32;
+ 		struct snd_compr_params params;
+ 		memset(&params32, 0 , sizeof(params32));
+ 		memset(&params, 0 , sizeof(params));
+ 		cmd = SNDRV_COMPRESS_SET_PARAMS;
+ 		if (copy_from_user(&params32, arg, sizeof(params32))) {
+ 			pr_err("%s: copyfromuser failed SET_PARAMS32\n",
+ 			__func__);
+ 			err = -EFAULT;
+ 			goto bail_out;
+ 		}
+ 		params.no_wake_mode = params32.no_wake_mode;
+ 		params.codec.id = params32.codec.id;
+ 		params.codec.ch_in = params32.codec.ch_in;
+ 		params.codec.ch_out = params32.codec.ch_out;
+ 		params.codec.sample_rate = params32.codec.sample_rate;
+ 		params.codec.bit_rate = params32.codec.bit_rate;
+ 		params.codec.rate_control = params32.codec.rate_control;
+ 		params.codec.profile = params32.codec.profile;
+ 		params.codec.level = params32.codec.level;
+ 		params.codec.ch_mode = params32.codec.ch_mode;
+ 		params.codec.format = params32.codec.format;
+ 		params.codec.align = params32.codec.align;
+ 		params.codec.transcode_dts = params32.codec.transcode_dts;
+ 
+ 		switch (params.codec.id) {
+ 		case SND_AUDIOCODEC_WMA:
+ 		case SND_AUDIOCODEC_WMA_PRO:
+ 			params.codec.options.wma.encodeopt1 =
+ 			params32.codec.options.wma.encodeopt1;
+ 			params.codec.options.wma.encodeopt2 =
+ 			params32.codec.options.wma.encodeopt2;
+ 			params.codec.options.wma.super_block_align =
+ 			params32.codec.options.wma.super_block_align;
+ 		break;
+ 		case SND_AUDIOCODEC_VORBIS:
+ 			params.codec.options.vorbis.downmix =
+ 			params32.codec.options.vorbis.downmix;
+ 			params.codec.options.vorbis.managed =
+ 			params32.codec.options.vorbis.managed;
+ 			params.codec.options.vorbis.max_bit_rate =
+ 			params32.codec.options.vorbis.max_bit_rate;
+ 			params.codec.options.vorbis.min_bit_rate =
+ 			params32.codec.options.vorbis.min_bit_rate;
+ 			params.codec.options.vorbis.quality =
+ 			params32.codec.options.vorbis.quality;
+ 		break;
+ 		case SND_AUDIOCODEC_REAL:
+ 			params.codec.options.real.num_regions =
+ 			params32.codec.options.real.num_regions;
+ 			params.codec.options.real.quant_bits =
+ 			params32.codec.options.real.quant_bits;
+ 			params.codec.options.real.start_region =
+ 			params32.codec.options.real.start_region;
+ 		break;
+ 		case SND_AUDIOCODEC_FLAC:
+ 			params.codec.options.flac.gain =
+ 			params32.codec.options.flac.gain;
+ 			params.codec.options.flac.num =
+ 			params32.codec.options.flac.num;
+ 		break;
+ 		case SND_AUDIOCODEC_DTS:
+ 		case SND_AUDIOCODEC_DTS_PASS_THROUGH:
+ 		case SND_AUDIOCODEC_DTS_LBR:
+ 		case SND_AUDIOCODEC_DTS_LBR_PASS_THROUGH:
+ 		case SND_AUDIOCODEC_DTS_TRANSCODE_LOOPBACK:
+ 			params.codec.options.dts.modelIdLength =
+ 			params32.codec.options.dts.modelIdLength;
+ 			params.codec.options.dts.modelId =
+ 			compat_ptr(params32.codec.options.dts.modelId);
+ 		break;
+ 		case SND_AUDIOCODEC_AC3:
+ 		case SND_AUDIOCODEC_EAC3:
+ 			params.codec.options.ddp.params_length =
+ 			params32.codec.options.ddp.params_length;
+ 			params.codec.options.ddp.params =
+ 			compat_ptr(params32.codec.options.ddp.params);
+ 			memcpy(params.codec.options.ddp.params_value,
+ 			params32.codec.options.ddp.params_value,
+ 			sizeof(params32.codec.options.ddp.params_value));
+ 			memcpy(params.codec.options.ddp.params_id,
+ 			params32.codec.options.ddp.params_id,
+ 			sizeof(params32.codec.options.ddp.params_id));
+ 		break;
+ 		default:
+ 			params.codec.options.generic.bw =
+ 			params32.codec.options.generic.bw;
+ 		break;
+ 		}
+ 		if (!err)
+ 			err = msm_compr_ioctl_shared(substream, cmd, &params);
+ 		break;
+ 	}
+ 	default:
+ 		err = msm_compr_ioctl_shared(substream, cmd, arg);
+ 	}
+ bail_out:
+ 	return err;
+ 
+ }
+ #endif
+ static int msm_compr_ioctl(struct snd_pcm_substream *substream,
+ 		unsigned int cmd, void *arg)
+ {
+ 	int err = 0;
+ 	if (!substream) {
+ 		pr_err("%s: Invalid params\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 	pr_debug("%s called with cmd = %d\n", __func__, cmd);
+ 	switch (cmd) {
+ 	case SNDRV_COMPRESS_TSTAMP: {
+ 		struct snd_compr_tstamp tstamp;
+ 		if (!arg) {
+ 			pr_err("%s: Invalid params Tstamp\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 		err = msm_compr_ioctl_shared(substream, cmd, &tstamp);
+ 		if (err)
+ 			pr_err("%s: COMPRESS_TSTAMP failed rc %d\n",
+ 			__func__, err);
+ 		if (!err && copy_to_user(arg, &tstamp, sizeof(tstamp))) {
+ 			pr_err("%s: copytouser failed COMPRESS_TSTAMP\n",
+ 			__func__);
+ 			err = -EFAULT;
+ 		}
+ 		break;
+ 	}
+ 	case SNDRV_COMPRESS_GET_CAPS: {
+ 		struct snd_compr_caps cap;
+ 		if (!arg) {
+ 			pr_err("%s: Invalid params getcaps\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 		pr_debug("SNDRV_COMPRESS_GET_CAPS\n");
+ 		err = msm_compr_ioctl_shared(substream, cmd, &cap);
+ 		if (err)
+ 			pr_err("%s: GET_CAPS failed rc %d\n",
+ 			__func__, err);
+ 		if (!err && copy_to_user(arg, &cap, sizeof(cap))) {
+ 			pr_err("%s: copytouser failed GET_CAPS\n",
+ 			__func__);
+ 			err = -EFAULT;
+ 		}
+ 		break;
+ 	}
+ 	case SNDRV_COMPRESS_SET_PARAMS: {
+ 		struct snd_compr_params params;
+ 		if (!arg) {
+ 			pr_err("%s: Invalid params setparam\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 		if (copy_from_user(&params, arg,
+ 			sizeof(struct snd_compr_params))) {
+ 			pr_err("%s: SET_PARAMS\n", __func__);
+ 			return -EFAULT;
+ 		}
+ 		err = msm_compr_ioctl_shared(substream, cmd, &params);
+ 		if (err)
+ 			pr_err("%s: SET_PARAMS failed rc %d\n",
+ 			__func__, err);
+ 		break;
+ 	}
+ 	default:
+ 		err = msm_compr_ioctl_shared(substream, cmd, arg);
+ 	}
+ 	return err;
+ }
++>>>>>>> FETCH_HEAD
  
  static int msm_compr_restart(struct snd_pcm_substream *substream)
  {
@@@ -1296,6 -1652,9 +1845,12 @@@ static struct snd_pcm_ops msm_compr_op
  	.pointer	= msm_compr_pointer,
  	.mmap		= msm_compr_mmap,
  	.restart	= msm_compr_restart,
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_COMPAT
+ 	.compat_ioctl   = msm_compr_compat_ioctl,
+ #endif
++>>>>>>> FETCH_HEAD
  };
  
  static int msm_asoc_pcm_new(struct snd_soc_pcm_runtime *rtd)
diff --cc sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
index d57b000,43d4535..0000000
--- a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
@@@ -49,8 -49,13 +49,18 @@@
  #define PARTIAL_DRAIN_ACK_EARLY_BY_MSEC	150
  #define MP3_OUTPUT_FRAME_SZ		1152
  #define AAC_OUTPUT_FRAME_SZ		1024
++<<<<<<< HEAD
 +#define DSP_NUM_OUTPUT_FRAME_BUFFERED	2
 +
++=======
+ #define AC3_OUTPUT_FRAME_SZ		1536
+ #define EAC3_OUTPUT_FRAME_SZ		1536
+ #define DSP_NUM_OUTPUT_FRAME_BUFFERED	2
+ 
+ /* decoder parameter length */
+ #define DDP_DEC_MAX_NUM_PARAM		18
+ 
++>>>>>>> FETCH_HEAD
  /* Default values used if user space does not set */
  #define COMPR_PLAYBACK_MIN_FRAGMENT_SIZE (8 * 1024)
  #define COMPR_PLAYBACK_MAX_FRAGMENT_SIZE (128 * 1024)
@@@ -61,9 -66,22 +71,28 @@@
  const DECLARE_TLV_DB_LINEAR(msm_compr_vol_gain, 0,
  				COMPRESSED_LR_VOL_MAX_STEPS);
  
++<<<<<<< HEAD
 +struct msm_compr_gapless_state {
 +	bool set_next_stream_id;
 +	int32_t stream_opened[2];
++=======
+ /*
+  * LSB 8 bits is used as stream id for some DSP
+  * commands for compressed playback.
+  */
+ #define STREAM_ID_FROM_TOKEN(i) (i & 0xFF)
+ 
+ /* Stream id switches between 1 and 2 */
+ #define NEXT_STREAM_ID(stream_id) ((stream_id & 1) + 1)
+ 
+ #define STREAM_ARRAY_INDEX(stream_id) (stream_id - 1)
+ 
+ #define MAX_NUMBER_OF_STREAMS 2
+ 
+ struct msm_compr_gapless_state {
+ 	bool set_next_stream_id;
+ 	int32_t stream_opened[MAX_NUMBER_OF_STREAMS];
++>>>>>>> FETCH_HEAD
  	uint32_t initial_samples_drop;
  	uint32_t trailing_samples_drop;
  	uint32_t gapless_transition;
@@@ -76,6 -94,7 +105,10 @@@ struct msm_compr_pdata 
  	uint32_t volume[MSM_FRONTEND_DAI_MAX][2]; /* For both L & R */
  	struct msm_compr_audio_effects *audio_effects[MSM_FRONTEND_DAI_MAX];
  	bool use_dsp_gapless_mode;
++<<<<<<< HEAD
++=======
+ 	struct msm_compr_dec_params *dec_params[MSM_FRONTEND_DAI_MAX];
++>>>>>>> FETCH_HEAD
  };
  
  struct msm_compr_audio {
@@@ -91,8 -110,10 +124,15 @@@
  	uint32_t app_pointer;
  	uint32_t buffer_size;
  	uint32_t byte_offset;
++<<<<<<< HEAD
 +	uint32_t copied_total;
 +	uint32_t bytes_received;
++=======
+ 	uint32_t copied_total; /* bytes consumed by DSP */
+ 	uint32_t bytes_received; /* from userspace */
+ 	uint32_t bytes_sent; /* to DSP */
+ 
++>>>>>>> FETCH_HEAD
  	int32_t first_buffer;
  	int32_t last_buffer;
  	int32_t partial_drain_delay;
@@@ -105,6 -126,10 +145,13 @@@
  	uint32_t cmd_ack;
  	uint32_t cmd_interrupt;
  	uint32_t drain_ready;
++<<<<<<< HEAD
++=======
+ 	uint32_t stream_available;
+ 	uint32_t next_stream;
+ 
+ 	uint64_t marker_timestamp;
++>>>>>>> FETCH_HEAD
  
  	struct msm_compr_gapless_state gapless_state;
  
@@@ -120,6 -145,7 +167,10 @@@
  	wait_queue_head_t drain_wait;
  	wait_queue_head_t flush_wait;
  	wait_queue_head_t close_wait;
++<<<<<<< HEAD
++=======
+ 	wait_queue_head_t wait_for_stream_avail;
++>>>>>>> FETCH_HEAD
  
  	spinlock_t lock;
  };
@@@ -131,6 -157,10 +182,13 @@@ struct msm_compr_audio_effects 
  	struct eq_params equalizer;
  };
  
++<<<<<<< HEAD
++=======
+ struct msm_compr_dec_params {
+ 	struct snd_dec_ddp ddp_params;
+ };
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_set_volume(struct snd_compr_stream *cstream,
  				uint32_t volume_l, uint32_t volume_r)
  {
@@@ -139,14 -169,41 +197,49 @@@
  
  	pr_debug("%s: volume_l %d volume_r %d\n",
  		__func__, volume_l, volume_r);
++<<<<<<< HEAD
++=======
+ 	if (!cstream || !cstream->runtime) {
+ 		pr_err("%s: session not active\n", __func__);
+ 		return -EPERM;
+ 	}
++>>>>>>> FETCH_HEAD
  	prtd = cstream->runtime->private_data;
  	if (prtd && prtd->audio_client) {
  		if (volume_l != volume_r) {
  			pr_debug("%s: call q6asm_set_lrgain\n", __func__);
  			rc = q6asm_set_lrgain(prtd->audio_client,
  						volume_l, volume_r);
++<<<<<<< HEAD
++		} else {
++			pr_debug("%s: call q6asm_set_volume\n", __func__);
++=======
+ 			if (rc < 0) {
+ 				pr_err("%s: set lrgain command failed rc=%d\n",
+ 				__func__, rc);
+ 				return rc;
+ 			}
+ 			/*
+ 			 * set master gain to unity so that only lr gain
+ 			 * is effective
+ 			 */
+ 			rc = q6asm_set_volume(prtd->audio_client,
+ 						COMPRESSED_LR_VOL_MAX_STEPS);
  		} else {
  			pr_debug("%s: call q6asm_set_volume\n", __func__);
+ 			/*
+ 			 * set left and right channel gain to unity so that
+ 			 * only master gain is effective
+ 			 */
+ 			rc = q6asm_set_lrgain(prtd->audio_client,
+ 						COMPRESSED_LR_VOL_MAX_STEPS,
+ 						COMPRESSED_LR_VOL_MAX_STEPS);
+ 			if (rc < 0) {
+ 				pr_err("%s: set lrgain command failed rc=%d\n",
+ 				__func__, rc);
+ 				return rc;
+ 			}
++>>>>>>> FETCH_HEAD
  			rc = q6asm_set_volume(prtd->audio_client, volume_l);
  		}
  		if (rc < 0) {
@@@ -158,6 -215,23 +251,26 @@@
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_compr_send_ddp_cfg(struct audio_client *ac,
+ 				  struct snd_dec_ddp *ddp)
+ {
+ 	int i, rc;
+ 	pr_debug("%s\n", __func__);
+ 	for (i = 0; i < ddp->params_length; i++) {
+ 		rc = q6asm_ds1_set_endp_params(ac, ddp->params_id[i],
+ 						ddp->params_value[i]);
+ 		if (rc) {
+ 			pr_err("sending params_id: %d failed\n",
+ 				ddp->params_id[i]);
+ 			return rc;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_send_buffer(struct msm_compr_audio *prtd)
  {
  	int buffer_length;
@@@ -178,7 -252,8 +291,12 @@@
  	pr_debug("%s: bytes_received = %d copied_total = %d\n",
  		__func__, prtd->bytes_received, prtd->copied_total);
  	if (prtd->first_buffer &&  prtd->gapless_state.use_dsp_gapless_mode)
++<<<<<<< HEAD
 +		q6asm_send_meta_data(prtd->audio_client,
++=======
+ 		q6asm_stream_send_meta_data(prtd->audio_client,
+ 				prtd->audio_client->stream_id,
++>>>>>>> FETCH_HEAD
  				prtd->gapless_state.initial_samples_drop,
  				prtd->gapless_state.trailing_samples_drop);
  
@@@ -211,6 -286,7 +329,10 @@@
  	if (q6asm_async_write(prtd->audio_client, &param) < 0) {
  		pr_err("%s:q6asm_async_write failed\n", __func__);
  	} else {
++<<<<<<< HEAD
++=======
+ 		prtd->bytes_sent += buffer_length;
++>>>>>>> FETCH_HEAD
  		if (prtd->first_buffer)
  			prtd->first_buffer = 0;
  	}
@@@ -222,16 -298,25 +344,37 @@@ static void compr_event_handler(uint32_
  		uint32_t token, uint32_t *payload, void *priv)
  {
  	struct msm_compr_audio *prtd = priv;
++<<<<<<< HEAD
 +	struct snd_compr_stream *cstream = prtd->cstream;
 +	struct audio_client *ac = prtd->audio_client;
 +	uint32_t chan_mode = 0;
 +	uint32_t sample_rate = 0;
 +	int bytes_available, stream_id;
++=======
+ 	struct snd_compr_stream *cstream;
+ 	struct audio_client *ac;
+ 	uint32_t chan_mode = 0;
+ 	uint32_t sample_rate = 0;
+ 	int bytes_available, stream_id;
+ 	uint32_t stream_index;
+ 	unsigned long flags;
+ 
+ 	if (!prtd) {
+ 		pr_err("%s: prtd is NULL\n", __func__);
+ 		return;
+ 	}
+ 	cstream = prtd->cstream;
+ 	ac = prtd->audio_client;
++>>>>>>> FETCH_HEAD
  
  	pr_debug("%s opcode =%08x\n", __func__, opcode);
  	switch (opcode) {
  	case ASM_DATA_EVENT_WRITE_DONE_V2:
++<<<<<<< HEAD
 +		spin_lock(&prtd->lock);
++=======
+ 		spin_lock_irqsave(&prtd->lock, flags);
++>>>>>>> FETCH_HEAD
  
  		if (payload[3]) {
  			pr_err("WRITE FAILED w/ err 0x%x !, paddr 0x%x"
@@@ -256,7 -341,7 +399,11 @@@
  			/* Writes must be restarted from _copy() */
  			pr_debug("write_done received while not started, treat as xrun");
  			atomic_set(&prtd->xrun, 1);
++<<<<<<< HEAD
 +			spin_unlock(&prtd->lock);
++=======
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
++>>>>>>> FETCH_HEAD
  			break;
  		}
  
@@@ -281,11 -366,13 +428,21 @@@
  		} else
  			msm_compr_send_buffer(prtd);
  
++<<<<<<< HEAD
 +		spin_unlock(&prtd->lock);
 +		break;
 +	case ASM_DATA_EVENT_RENDERED_EOS:
 +		pr_debug("ASM_DATA_CMDRSP_EOS\n");
 +		spin_lock(&prtd->lock);
++=======
+ 		spin_unlock_irqrestore(&prtd->lock, flags);
+ 		break;
+ 	case ASM_DATA_EVENT_RENDERED_EOS:
+ 		spin_lock_irqsave(&prtd->lock, flags);
+ 		pr_debug("%s: ASM_DATA_CMDRSP_EOS token 0x%x,stream id %d\n",
+ 			  __func__, token, STREAM_ID_FROM_TOKEN(token));
+ 		stream_id = STREAM_ID_FROM_TOKEN(token);
++>>>>>>> FETCH_HEAD
  		if (atomic_read(&prtd->eos) &&
  		    !prtd->gapless_state.set_next_stream_id) {
  			pr_debug("ASM_DATA_CMDRSP_EOS wake up\n");
@@@ -293,16 -380,27 +450,40 @@@
  			wake_up(&prtd->eos_wait);
  		}
  		atomic_set(&prtd->eos, 0);
++<<<<<<< HEAD
 +		stream_id = ac->stream_id^1; /*prev stream */
 +		if (prtd->gapless_state.set_next_stream_id &&
 +		    prtd->gapless_state.stream_opened[stream_id]) {
 +			q6asm_stream_cmd_nowait(prtd->audio_client,
 +						CMD_CLOSE, stream_id);
 +			atomic_set(&prtd->close, 1);
 +			prtd->gapless_state.stream_opened[stream_id] = 0;
 +			prtd->gapless_state.set_next_stream_id = false;
 +		}
 +		spin_unlock(&prtd->lock);
++=======
+ 		stream_index = STREAM_ARRAY_INDEX(stream_id);
+ 		if (stream_index >= MAX_NUMBER_OF_STREAMS ||
+ 		    stream_index < 0) {
+ 			pr_err("%s: Invalid stream index %d", __func__,
+ 				stream_index);
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
+ 			break;
+ 		}
+ 
+ 		if (prtd->gapless_state.set_next_stream_id &&
+ 			prtd->gapless_state.stream_opened[stream_index]) {
+ 			pr_debug("%s: CMD_CLOSE stream_id %d\n",
+ 				  __func__, stream_id);
+ 			q6asm_stream_cmd_nowait(ac, CMD_CLOSE, stream_id);
+ 			atomic_set(&prtd->close, 1);
+ 			prtd->gapless_state.stream_opened[stream_index] = 0;
+ 			prtd->gapless_state.set_next_stream_id = false;
+ 		}
+ 		if (prtd->gapless_state.gapless_transition)
+ 			prtd->gapless_state.gapless_transition = 0;
+ 		spin_unlock_irqrestore(&prtd->lock, flags);
++>>>>>>> FETCH_HEAD
  		break;
  	case ASM_DATA_EVENT_SR_CM_CHANGE_NOTIFY:
  	case ASM_DATA_EVENT_ENC_SR_CM_CHANGE_NOTIFY: {
@@@ -321,9 -419,9 +502,15 @@@
  			/* check if the first buffer need to be sent to DSP */
  			pr_debug("ASM_SESSION_CMD_RUN_V2\n");
  
++<<<<<<< HEAD
 +			spin_lock(&prtd->lock);
 +			/* FIXME: A state is a much better way of dealing with this */
 +			if (!prtd->copied_total) {
++=======
+ 			/* FIXME: A state is a better way, dealing with this*/
+ 			spin_lock_irqsave(&prtd->lock, flags);
+ 			if (!prtd->bytes_sent) {
++>>>>>>> FETCH_HEAD
  				bytes_available = prtd->bytes_received - prtd->copied_total;
  				if (bytes_available < cstream->runtime->fragment_size) {
  					pr_debug("CMD_RUN_V2 Insufficient data to send. break out\n");
@@@ -331,21 -429,42 +518,59 @@@
  				} else
  					msm_compr_send_buffer(prtd);
  			}
++<<<<<<< HEAD
 +			spin_unlock(&prtd->lock);
 +			break;
 +		case ASM_STREAM_CMD_FLUSH:
 +			pr_debug("ASM_STREAM_CMD_FLUSH\n");
++=======
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
+ 			break;
+ 		case ASM_STREAM_CMD_FLUSH:
+ 			pr_debug("%s: ASM_STREAM_CMD_FLUSH:", __func__);
+ 			pr_debug("token 0x%x, stream id %d\n", token,
+ 				  STREAM_ID_FROM_TOKEN(token));
++>>>>>>> FETCH_HEAD
  			prtd->cmd_ack = 1;
  			wake_up(&prtd->flush_wait);
  			break;
  		case ASM_DATA_CMD_REMOVE_INITIAL_SILENCE:
++<<<<<<< HEAD
 +			pr_debug("ASM_DATA_CMD_REMOVE_INITIAL_SILENCE\n");
 +			break;
 +		case ASM_DATA_CMD_REMOVE_TRAILING_SILENCE:
 +			pr_debug("ASM_DATA_CMD_REMOVE_TRAILING_SILENCE\n");
 +			break;
 +		case ASM_STREAM_CMD_CLOSE:
 +			pr_debug("ASM_DATA_CMD_CLOSE\n");
++=======
+ 			pr_debug("%s: ASM_DATA_CMD_REMOVE_INITIAL_SILENCE:",
+ 				   __func__);
+ 			pr_debug("token 0x%x, stream id = %d\n", token,
+ 				  STREAM_ID_FROM_TOKEN(token));
+ 			break;
+ 		case ASM_DATA_CMD_REMOVE_TRAILING_SILENCE:
+ 			pr_debug("%s: ASM_DATA_CMD_REMOVE_TRAILING_SILENCE:",
+ 				  __func__);
+ 			pr_debug("token = 0x%x,	stream id = %d\n", token,
+ 				  STREAM_ID_FROM_TOKEN(token));
+ 			break;
+ 		case ASM_STREAM_CMD_CLOSE:
+ 			pr_debug("%s: ASM_DATA_CMD_CLOSE:", __func__);
+ 			pr_debug("token 0x%x, stream id %d\n", token,
+ 				  STREAM_ID_FROM_TOKEN(token));
+ 			/*
+ 			 * wakeup wait for stream avail on stream 3
+ 			 * after stream 1 ends.
+ 			 */
+ 			if (prtd->next_stream) {
+ 				pr_debug("%s:CLOSE:wakeup wait for stream\n",
+ 					  __func__);
+ 				prtd->stream_available = 1;
+ 				wake_up(&prtd->wait_for_stream_avail);
+ 				prtd->next_stream = 0;
+ 			}
++>>>>>>> FETCH_HEAD
  			if (atomic_read(&prtd->close) &&
  			    atomic_read(&prtd->wait_on_close)) {
  				prtd->cmd_ack = 1;
@@@ -359,18 -478,21 +584,36 @@@
  		break;
  	}
  	case ASM_SESSION_CMDRSP_GET_SESSIONTIME_V3:
++<<<<<<< HEAD
 +		pr_debug("ASM_SESSION_CMDRSP_GET_SESSIONTIME_V3\n");
 +		break;
 +	case RESET_EVENTS:
 +		pr_err("Received reset events CB, move to error state");
 +		spin_lock(&prtd->lock);
 +		snd_compr_fragment_elapsed(cstream);
 +		prtd->copied_total = prtd->bytes_received;
 +		atomic_set(&prtd->error, 1);
 +		spin_unlock(&prtd->lock);
 +		break;
 +	default:
 +		pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
++=======
+ 		pr_debug("%s: ASM_SESSION_CMDRSP_GET_SESSIONTIME_V3\n",
+ 			  __func__);
+ 		break;
+ 	case RESET_EVENTS:
+ 		pr_err("%s: Received reset events CB, move to error state",
+ 			__func__);
+ 		spin_lock_irqsave(&prtd->lock, flags);
+ 		snd_compr_fragment_elapsed(cstream);
+ 		prtd->copied_total = prtd->bytes_received;
+ 		atomic_set(&prtd->error, 1);
+ 		spin_unlock_irqrestore(&prtd->lock, flags);
+ 		break;
+ 	default:
+ 		pr_debug("%s: Not Supported Event opcode[0x%x]\n",
+ 			  __func__, opcode);
++>>>>>>> FETCH_HEAD
  		break;
  	}
  }
@@@ -387,11 -509,16 +630,23 @@@ static void populate_codec_list(struct 
  			COMPR_PLAYBACK_MIN_NUM_FRAGMENTS;
  	prtd->compr_cap.max_fragments =
  			COMPR_PLAYBACK_MAX_NUM_FRAGMENTS;
++<<<<<<< HEAD
 +	prtd->compr_cap.num_codecs = 4;
++=======
+ 	prtd->compr_cap.num_codecs = 8;
++>>>>>>> FETCH_HEAD
  	prtd->compr_cap.codecs[0] = SND_AUDIOCODEC_MP3;
  	prtd->compr_cap.codecs[1] = SND_AUDIOCODEC_AAC;
  	prtd->compr_cap.codecs[2] = SND_AUDIOCODEC_AC3;
  	prtd->compr_cap.codecs[3] = SND_AUDIOCODEC_EAC3;
++<<<<<<< HEAD
++=======
+ 	prtd->compr_cap.codecs[4] = SND_AUDIOCODEC_MP2;
+ 	prtd->compr_cap.codecs[5] = SND_AUDIOCODEC_PCM;
+ 	prtd->compr_cap.codecs[6] = SND_AUDIOCODEC_WMA;
+ 	prtd->compr_cap.codecs[7] = SND_AUDIOCODEC_WMA_PRO;
+ 	prtd->compr_cap.codecs[8] = SND_AUDIOCODEC_FLAC;
++>>>>>>> FETCH_HEAD
  }
  
  static int msm_compr_send_media_format_block(struct snd_compr_stream *cstream,
@@@ -400,16 -527,39 +655,52 @@@
  	struct snd_compr_runtime *runtime = cstream->runtime;
  	struct msm_compr_audio *prtd = runtime->private_data;
  	struct asm_aac_cfg aac_cfg;
++<<<<<<< HEAD
 +	int ret = 0;
 +
 +	switch (prtd->codec) {
 +	case FORMAT_MP3:
 +		/* no media format block needed */
 +		break;
 +	case FORMAT_MPEG4_AAC:
 +		memset(&aac_cfg, 0x0, sizeof(struct asm_aac_cfg));
 +		aac_cfg.aot = AAC_ENC_MODE_EAAC_P;
 +		aac_cfg.format = 0x03;
++=======
+ 	struct asm_wma_cfg wma_cfg;
+ 	struct asm_wmapro_cfg wma_pro_cfg;
+ 	struct asm_flac_cfg flac_cfg;
+ 	int ret = 0;
+ 	uint16_t bit_width = 16;
+ 
+ 	switch (prtd->codec) {
+ 	case FORMAT_LINEAR_PCM:
+ 		pr_debug("SND_AUDIOCODEC_PCM\n");
+ 		if (prtd->codec_param.codec.format == SNDRV_PCM_FORMAT_S24_LE)
+ 			bit_width = 24;
+ 		ret = q6asm_media_format_block_pcm_format_support_v2(
+ 							prtd->audio_client,
+ 							prtd->sample_rate,
+ 							prtd->num_channels,
+ 							bit_width, stream_id);
+ 		if (ret < 0)
+ 			pr_err("%s: CMD Format block failed\n", __func__);
+ 
+ 		break;
+ 	case FORMAT_MP3:
+ 		pr_debug("SND_AUDIOCODEC_MP3\n");
+ 		/* no media format block needed */
+ 		break;
+ 	case FORMAT_MPEG4_AAC:
+ 		pr_debug("SND_AUDIOCODEC_AAC\n");
+ 		memset(&aac_cfg, 0x0, sizeof(struct asm_aac_cfg));
+ 		aac_cfg.aot = AAC_ENC_MODE_EAAC_P;
+ 		if (prtd->codec_param.codec.format ==
+ 					SND_AUDIOSTREAMFORMAT_MP4ADTS)
+ 			aac_cfg.format = 0x0;
+ 		else
+ 			aac_cfg.format = 0x03;
++>>>>>>> FETCH_HEAD
  		aac_cfg.ch_cfg = prtd->num_channels;
  		aac_cfg.sample_rate = prtd->sample_rate;
  		ret = q6asm_stream_media_format_block_aac(prtd->audio_client,
@@@ -418,8 -568,84 +709,89 @@@
  			pr_err("%s: CMD Format block failed\n", __func__);
  		break;
  	case FORMAT_AC3:
++<<<<<<< HEAD
++		break;
++	case FORMAT_EAC3:
++=======
+ 		pr_debug("SND_AUDIOCODEC_AC3\n");
  		break;
  	case FORMAT_EAC3:
+ 		pr_debug("SND_AUDIOCODEC_EAC3\n");
+ 		break;
+ 	case FORMAT_WMA_V9:
+ 		pr_debug("SND_AUDIOCODEC_WMA\n");
+ 		memset(&wma_cfg, 0x0, sizeof(struct asm_wma_cfg));
+ 		wma_cfg.format_tag = prtd->codec_param.codec.format;
+ 		wma_cfg.ch_cfg = prtd->codec_param.codec.ch_in;
+ 		wma_cfg.sample_rate = prtd->sample_rate;
+ 		wma_cfg.avg_bytes_per_sec =
+ 			prtd->codec_param.codec.bit_rate/8;
+ 		wma_cfg.block_align =
+ 			prtd->codec_param.codec.options.wma.super_block_align;
+ 		wma_cfg.valid_bits_per_sample =
+ 		prtd->codec_param.codec.options.wma.bits_per_sample;
+ 		wma_cfg.ch_mask =
+ 			prtd->codec_param.codec.options.wma.channelmask;
+ 		wma_cfg.encode_opt =
+ 			prtd->codec_param.codec.options.wma.encodeopt;
+ 		ret = q6asm_media_format_block_wma(prtd->audio_client,
+ 					&wma_cfg);
+ 		if (ret < 0)
+ 			pr_err("%s: CMD Format block failed\n", __func__);
+ 		break;
+ 	case FORMAT_WMA_V10PRO:
+ 		pr_debug("SND_AUDIOCODEC_WMA_PRO\n");
+ 		memset(&wma_pro_cfg, 0x0, sizeof(struct asm_wmapro_cfg));
+ 		wma_pro_cfg.format_tag = prtd->codec_param.codec.format;
+ 		wma_pro_cfg.ch_cfg = prtd->codec_param.codec.ch_in;
+ 		wma_pro_cfg.sample_rate =
+ 			prtd->sample_rate;
+ 		wma_pro_cfg.avg_bytes_per_sec =
+ 			prtd->codec_param.codec.bit_rate/8;
+ 		wma_pro_cfg.block_align =
+ 			prtd->codec_param.codec.options.wma.super_block_align;
+ 		wma_pro_cfg.valid_bits_per_sample =
+ 			prtd->codec_param.codec.options.wma.bits_per_sample;
+ 		wma_pro_cfg.ch_mask =
+ 			prtd->codec_param.codec.options.wma.channelmask;
+ 		wma_pro_cfg.encode_opt =
+ 			prtd->codec_param.codec.options.wma.encodeopt;
+ 		wma_pro_cfg.adv_encode_opt =
+ 			prtd->codec_param.codec.options.wma.encodeopt1;
+ 		wma_pro_cfg.adv_encode_opt2 =
+ 			prtd->codec_param.codec.options.wma.encodeopt2;
+ 		ret = q6asm_media_format_block_wmapro(prtd->audio_client,
+ 				&wma_pro_cfg);
+ 		if (ret < 0)
+ 			pr_err("%s: CMD Format block failed\n", __func__);
+ 		break;
+ 	case FORMAT_MP2:
+ 		pr_debug("%s: SND_AUDIOCODEC_MP2\n", __func__);
+ 		break;
+ 	case FORMAT_FLAC:
+ 		pr_debug("%s: SND_AUDIOCODEC_FLAC\n", __func__);
+ 		memset(&flac_cfg, 0x0, sizeof(struct asm_flac_cfg));
+ 		flac_cfg.ch_cfg = prtd->num_channels;
+ 		flac_cfg.sample_rate = prtd->sample_rate;
+ 		flac_cfg.stream_info_present = 1;
+ 		flac_cfg.sample_size =
+ 			prtd->codec_param.codec.options.flac_dec.sample_size;
+ 		flac_cfg.min_blk_size =
+ 			prtd->codec_param.codec.options.flac_dec.min_blk_size;
+ 		flac_cfg.max_blk_size =
+ 			prtd->codec_param.codec.options.flac_dec.max_blk_size;
+ 		flac_cfg.max_frame_size =
+ 			prtd->codec_param.codec.options.flac_dec.max_frame_size;
+ 		flac_cfg.min_frame_size =
+ 			prtd->codec_param.codec.options.flac_dec.min_frame_size;
+ 
+ 		ret = q6asm_stream_media_format_block_flac(prtd->audio_client,
+ 							&flac_cfg, stream_id);
+ 		if (ret < 0)
+ 			pr_err("%s: CMD Format block failed ret %d\n",
+ 				__func__, ret);
+ 
++>>>>>>> FETCH_HEAD
  		break;
  	default:
  		pr_debug("%s, unsupported format, skip", __func__);
@@@ -436,6 -662,7 +808,10 @@@ static int msm_compr_configure_dsp(stru
  	uint16_t bits_per_sample = 16;
  	int dir = IN, ret = 0;
  	struct audio_client *ac = prtd->audio_client;
++<<<<<<< HEAD
++=======
+ 	uint32_t stream_index;
++>>>>>>> FETCH_HEAD
  	struct asm_softpause_params softpause = {
  		.enable = SOFT_PAUSE_ENABLE,
  		.period = SOFT_PAUSE_PERIOD,
@@@ -447,8 -674,12 +823,17 @@@
  		.step = SOFT_VOLUME_STEP,
  		.rampingcurve = SOFT_VOLUME_CURVE_LINEAR,
  	};
++<<<<<<< HEAD
 +
 +	pr_debug("%s\n", __func__);
++=======
+ 	if (prtd->codec_param.codec.format == SNDRV_PCM_FORMAT_S24_LE)
+ 		bits_per_sample = 24;
+ 	if (prtd->codec_param.codec.format == SNDRV_PCM_FORMAT_S32_LE)
+ 		bits_per_sample = 32;
+ 
+ 	pr_debug("%s: stream_id %d\n", __func__, ac->stream_id);
++>>>>>>> FETCH_HEAD
  	ret = q6asm_stream_open_write_v2(ac,
  				prtd->codec, bits_per_sample,
  				ac->stream_id,
@@@ -458,13 -689,25 +843,32 @@@
  		 return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	prtd->gapless_state.stream_opened[ac->stream_id] = 1;
++=======
+ 	stream_index = STREAM_ARRAY_INDEX(ac->stream_id);
+ 	if (stream_index >= MAX_NUMBER_OF_STREAMS || stream_index < 0) {
+ 		pr_err("%s: Invalid stream index:%d", __func__, stream_index);
+ 		return -EINVAL;
+ 	}
+ 
+ 	prtd->gapless_state.stream_opened[stream_index] = 1;
++>>>>>>> FETCH_HEAD
  	pr_debug("%s be_id %d\n", __func__, soc_prtd->dai_link->be_id);
  	msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
  				ac->perf_mode,
  				prtd->session_id,
  				SNDRV_PCM_STREAM_PLAYBACK);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Setting the master volume gain to 0 while
+ 	 * configuring ASM session. This is to address
+ 	 * DSP pop noise issue where. This change is
+ 	 * there from begining may be DSP limitation
+ 	 */
++>>>>>>> FETCH_HEAD
  	ret = msm_compr_set_volume(cstream, 0, 0);
  	if (ret < 0)
  		pr_err("%s : Set Volume failed : %d", __func__, ret);
@@@ -479,7 -722,7 +883,11 @@@
  		pr_err("%s: Send SoftVolume Param failed ret=%d\n",
  			__func__, ret);
  
++<<<<<<< HEAD
 +	ret = q6asm_set_io_mode(ac, (COMPRESSED_IO | ASYNC_IO_MODE));
++=======
+ 	ret = q6asm_set_io_mode(ac, (COMPRESSED_STREAM_IO | ASYNC_IO_MODE));
++>>>>>>> FETCH_HEAD
  	if (ret < 0) {
  		pr_err("%s: Set IO mode failed\n", __func__);
  		return -EINVAL;
@@@ -502,6 -745,7 +910,10 @@@
  	prtd->copied_total = 0;
  	prtd->app_pointer  = 0;
  	prtd->bytes_received = 0;
++<<<<<<< HEAD
++=======
+ 	prtd->bytes_sent = 0;
++>>>>>>> FETCH_HEAD
  	prtd->buffer       = ac->port[dir].buf[0].data;
  	prtd->buffer_paddr = ac->port[dir].buf[0].phys;
  	prtd->buffer_size  = runtime->fragments * runtime->fragment_size;
@@@ -528,12 -772,24 +940,30 @@@ static int msm_compr_open(struct snd_co
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
++=======
+ 	runtime->private_data = NULL;
++>>>>>>> FETCH_HEAD
  	prtd->cstream = cstream;
  	pdata->cstream[rtd->dai_link->be_id] = cstream;
  	pdata->audio_effects[rtd->dai_link->be_id] =
  		 kzalloc(sizeof(struct msm_compr_audio_effects), GFP_KERNEL);
  	if (!pdata->audio_effects[rtd->dai_link->be_id]) {
  		pr_err("%s: Could not allocate memory for effects\n", __func__);
++<<<<<<< HEAD
++=======
+ 		pdata->cstream[rtd->dai_link->be_id] = NULL;
+ 		kfree(prtd);
+ 		return -ENOMEM;
+ 	}
+ 	pdata->dec_params[rtd->dai_link->be_id] =
+ 		 kzalloc(sizeof(struct msm_compr_dec_params), GFP_KERNEL);
+ 	if (!pdata->dec_params[rtd->dai_link->be_id]) {
+ 		pr_err("%s: Could not allocate memory for dec params\n",
+ 			__func__);
+ 		kfree(pdata->audio_effects[rtd->dai_link->be_id]);
+ 		pdata->cstream[rtd->dai_link->be_id] = NULL;
++>>>>>>> FETCH_HEAD
  		kfree(prtd);
  		return -ENOMEM;
  	}
@@@ -542,6 -798,8 +972,11 @@@
  	if (!prtd->audio_client) {
  		pr_err("%s: Could not allocate memory for client\n", __func__);
  		kfree(pdata->audio_effects[rtd->dai_link->be_id]);
++<<<<<<< HEAD
++=======
+ 		kfree(pdata->dec_params[rtd->dai_link->be_id]);
+ 		pdata->cstream[rtd->dai_link->be_id] = NULL;
++>>>>>>> FETCH_HEAD
  		kfree(prtd);
  		return -ENOMEM;
  	}
@@@ -551,6 -809,7 +986,10 @@@
  	prtd->session_id = prtd->audio_client->session;
  	prtd->codec = FORMAT_MP3;
  	prtd->bytes_received = 0;
++<<<<<<< HEAD
++=======
+ 	prtd->bytes_sent = 0;
++>>>>>>> FETCH_HEAD
  	prtd->copied_total = 0;
  	prtd->byte_offset = 0;
  	prtd->sample_rate = 44100;
@@@ -559,6 -818,7 +998,10 @@@
  	prtd->last_buffer = 0;
  	prtd->first_buffer = 1;
  	prtd->partial_drain_delay = 0;
++<<<<<<< HEAD
++=======
+ 	prtd->next_stream = 0;
++>>>>>>> FETCH_HEAD
  	memset(&prtd->gapless_state, 0, sizeof(struct msm_compr_gapless_state));
  	/*
  	 * Update the use_dsp_gapless_mode from gapless struture with the value
@@@ -582,6 -842,7 +1025,10 @@@
  	init_waitqueue_head(&prtd->drain_wait);
  	init_waitqueue_head(&prtd->flush_wait);
  	init_waitqueue_head(&prtd->close_wait);
++<<<<<<< HEAD
++=======
+ 	init_waitqueue_head(&prtd->wait_for_stream_avail);
++>>>>>>> FETCH_HEAD
  
  	runtime->private_data = prtd;
  	populate_codec_list(prtd);
@@@ -602,30 -863,38 +1049,65 @@@
  
  static int msm_compr_free(struct snd_compr_stream *cstream)
  {
++<<<<<<< HEAD
 +	struct snd_compr_runtime *runtime = cstream->runtime;
 +	struct msm_compr_audio *prtd = runtime->private_data;
 +	struct snd_soc_pcm_runtime *soc_prtd = cstream->private_data;
 +	struct msm_compr_pdata *pdata =
 +			snd_soc_platform_get_drvdata(soc_prtd->platform);
 +	struct audio_client *ac = prtd->audio_client;
 +	int dir = IN, ret = 0, stream_id;
 +	unsigned long flags;
 +
 +	pr_debug("%s\n", __func__);
 +	pdata->cstream[soc_prtd->dai_link->be_id] = NULL;
 +	if (cstream->direction == SND_COMPRESS_PLAYBACK) {
 +		if (atomic_read(&pdata->audio_ocmem_req) > 1)
 +			atomic_dec(&pdata->audio_ocmem_req);
 +		else if (atomic_cmpxchg(&pdata->audio_ocmem_req, 1, 0))
 +			audio_ocmem_process_req(AUDIO, false);
 +
 +		msm_pcm_routing_dereg_phy_stream(soc_prtd->dai_link->be_id,
 +						SNDRV_PCM_STREAM_PLAYBACK);
 +	}
 +
 +	pr_debug("%s: ocmem_req: %d\n", __func__,
 +		atomic_read(&pdata->audio_ocmem_req));
 +
++=======
+ 	struct snd_compr_runtime *runtime;
+ 	struct msm_compr_audio *prtd;
+ 	struct snd_soc_pcm_runtime *soc_prtd;
+ 	struct msm_compr_pdata *pdata;
+ 	struct audio_client *ac;
+ 	int dir = IN, ret = 0, stream_id;
+ 	unsigned long flags;
+ 	uint32_t stream_index;
+ 
+ 	pr_debug("%s\n", __func__);
+ 
+ 	if (!cstream) {
+ 		pr_err("%s cstream is null\n", __func__);
+ 		return 0;
+ 	}
+ 	runtime = cstream->runtime;
+ 	soc_prtd = cstream->private_data;
+ 	if (!runtime || !soc_prtd || !(soc_prtd->platform)) {
+ 		pr_err("%s runtime or soc_prtd or platform is null\n", __func__);
+ 		return 0;
+ 	}
+ 	prtd = runtime->private_data;
+ 	if (!prtd) {
+ 		pr_err("%s prtd is null\n", __func__);
+ 		return 0;
+ 	}
+ 	pdata = snd_soc_platform_get_drvdata(soc_prtd->platform);
+ 	ac = prtd->audio_client;
+ 	if (!pdata || !ac) {
+ 		pr_err("%s pdata or ac is null\n", __func__);
+ 		return 0;
+ 	}
++>>>>>>> FETCH_HEAD
  	if (atomic_read(&prtd->eos)) {
  		ret = wait_event_timeout(prtd->eos_wait,
  					 prtd->cmd_ack, 5 * HZ);
@@@ -643,25 -912,46 +1125,64 @@@
  
  	spin_lock_irqsave(&prtd->lock, flags);
  	stream_id = ac->stream_id;
++<<<<<<< HEAD
 +	if (prtd->gapless_state.stream_opened[stream_id^1]) {
 +		spin_unlock_irqrestore(&prtd->lock, flags);
 +		q6asm_stream_cmd(ac, CMD_CLOSE, stream_id^1);
 +		spin_lock_irqsave(&prtd->lock, flags);
 +	}
 +	if (prtd->gapless_state.stream_opened[stream_id]) {
 +		spin_unlock_irqrestore(&prtd->lock, flags);
++=======
+ 	stream_index = STREAM_ARRAY_INDEX(NEXT_STREAM_ID(stream_id));
+ 
+ 	if ((stream_index < MAX_NUMBER_OF_STREAMS && stream_index >= 0) &&
+ 	    (prtd->gapless_state.stream_opened[stream_index])) {
+ 		prtd->gapless_state.stream_opened[stream_index] = 0;
+ 		spin_unlock_irqrestore(&prtd->lock, flags);
+ 		pr_debug(" close stream %d", NEXT_STREAM_ID(stream_id));
+ 		q6asm_stream_cmd(ac, CMD_CLOSE, NEXT_STREAM_ID(stream_id));
+ 		spin_lock_irqsave(&prtd->lock, flags);
+ 	}
+ 
+ 	stream_index = STREAM_ARRAY_INDEX(stream_id);
+ 	if ((stream_index < MAX_NUMBER_OF_STREAMS && stream_index >= 0) &&
+ 	    (prtd->gapless_state.stream_opened[stream_index])) {
+ 		prtd->gapless_state.stream_opened[stream_index] = 0;
+ 		spin_unlock_irqrestore(&prtd->lock, flags);
+ 		pr_debug("close stream %d", stream_id);
++>>>>>>> FETCH_HEAD
  		q6asm_stream_cmd(ac, CMD_CLOSE, stream_id);
  		spin_lock_irqsave(&prtd->lock, flags);
  	}
  	spin_unlock_irqrestore(&prtd->lock, flags);
  
++<<<<<<< HEAD
 +	/* client buf alloc was with stream id 0, so free with the same */
 +	ac->stream_id = 0;
++=======
+ 	pdata->cstream[soc_prtd->dai_link->be_id] = NULL;
+ 	if (cstream->direction == SND_COMPRESS_PLAYBACK) {
+ 		if (atomic_read(&pdata->audio_ocmem_req) > 1)
+ 			atomic_dec(&pdata->audio_ocmem_req);
+ 		else if (atomic_cmpxchg(&pdata->audio_ocmem_req, 1, 0))
+ 			audio_ocmem_process_req(AUDIO, false);
+ 		msm_pcm_routing_dereg_phy_stream(soc_prtd->dai_link->be_id,
+ 						SNDRV_PCM_STREAM_PLAYBACK);
+ 	}
+ 
+ 	pr_debug("%s: ocmem_req: %d\n", __func__,
+ 		atomic_read(&pdata->audio_ocmem_req));
++>>>>>>> FETCH_HEAD
  	q6asm_audio_client_buf_free_contiguous(dir, ac);
  
  	q6asm_audio_client_free(ac);
  
  	kfree(pdata->audio_effects[soc_prtd->dai_link->be_id]);
++<<<<<<< HEAD
++=======
+ 	kfree(pdata->dec_params[soc_prtd->dai_link->be_id]);
++>>>>>>> FETCH_HEAD
  	kfree(prtd);
  
  	return 0;
@@@ -705,11 -995,32 +1226,38 @@@ static int msm_compr_set_params(struct 
  	case SNDRV_PCM_RATE_48000:
  		prtd->sample_rate = 48000;
  		break;
++<<<<<<< HEAD
++=======
+ 	case SNDRV_PCM_RATE_64000:
+ 		prtd->sample_rate = 64000;
+ 		break;
+ 	case SNDRV_PCM_RATE_88200:
+ 		prtd->sample_rate = 88200;
+ 		break;
+ 	case SNDRV_PCM_RATE_96000:
+ 		prtd->sample_rate = 96000;
+ 		break;
+ 	case SNDRV_PCM_RATE_176400:
+ 		prtd->sample_rate = 176400;
+ 		break;
+ 	case SNDRV_PCM_RATE_192000:
+ 		prtd->sample_rate = 192000;
+ 		break;
++>>>>>>> FETCH_HEAD
  	}
  
  	pr_debug("%s: sample_rate %d\n", __func__, prtd->sample_rate);
  
  	switch (params->codec.id) {
++<<<<<<< HEAD
++=======
+ 	case SND_AUDIOCODEC_PCM: {
+ 		pr_debug("SND_AUDIOCODEC_PCM\n");
+ 		prtd->codec = FORMAT_LINEAR_PCM;
+ 		break;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	case SND_AUDIOCODEC_MP3: {
  		pr_debug("SND_AUDIOCODEC_MP3\n");
  		prtd->codec = FORMAT_MP3;
@@@ -725,12 -1036,40 +1273,48 @@@
  	}
  
  	case SND_AUDIOCODEC_AC3: {
++<<<<<<< HEAD
++		prtd->codec = FORMAT_AC3;
++=======
+ 		pr_debug("SND_AUDIOCODEC_AC3\n");
  		prtd->codec = FORMAT_AC3;
+ 		frame_sz = AC3_OUTPUT_FRAME_SZ;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  
  	case SND_AUDIOCODEC_EAC3: {
++<<<<<<< HEAD
++		prtd->codec = FORMAT_EAC3;
++=======
+ 		pr_debug("SND_AUDIOCODEC_EAC3\n");
  		prtd->codec = FORMAT_EAC3;
+ 		frame_sz = EAC3_OUTPUT_FRAME_SZ;
+ 		break;
+ 	}
+ 
+ 	case SND_AUDIOCODEC_MP2: {
+ 		pr_debug("SND_AUDIOCODEC_MP2\n");
+ 		prtd->codec = FORMAT_MP2;
+ 		break;
+ 	}
+ 
+ 	case SND_AUDIOCODEC_WMA: {
+ 		pr_debug("SND_AUDIOCODEC_WMA\n");
+ 		prtd->codec = FORMAT_WMA_V9;
+ 		break;
+ 	}
+ 
+ 	case SND_AUDIOCODEC_WMA_PRO: {
+ 		pr_debug("SND_AUDIOCODEC_WMA_PRO\n");
+ 		prtd->codec = FORMAT_WMA_V10PRO;
+ 		break;
+ 	}
+ 
+ 	case SND_AUDIOCODEC_FLAC: {
+ 		pr_debug("%s: SND_AUDIOCODEC_FLAC\n", __func__);
+ 		prtd->codec = FORMAT_FLAC;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  
@@@ -773,6 -1112,45 +1357,48 @@@ static int msm_compr_drain_buffer(struc
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_compr_wait_for_stream_avail(struct msm_compr_audio *prtd,
+ 				    unsigned long *flags)
+ {
+ 	int rc = 0;
+ 	pr_debug("next session is already in opened state\n");
+ 	prtd->next_stream = 1;
+ 	prtd->cmd_interrupt = 0;
+ 	spin_unlock_irqrestore(&prtd->lock, *flags);
+ 	/*
+ 	 * Wait for stream to be available, or the wait to be interrupted by
+ 	 * commands like flush or till a timeout of one second.
+ 	 */
+ 	rc = wait_event_timeout(prtd->wait_for_stream_avail,
+ 		prtd->stream_available || prtd->cmd_interrupt, 1 * HZ);
+ 	pr_err("%s:prtd->stream_available %d, prtd->cmd_interrupt %d rc %d\n",
+ 		   __func__, prtd->stream_available, prtd->cmd_interrupt, rc);
+ 
+ 	spin_lock_irqsave(&prtd->lock, *flags);
+ 	if (rc == 0) {
+ 		pr_err("%s: wait_for_stream_avail timed out\n",
+ 						__func__);
+ 		rc =  -ETIMEDOUT;
+ 	} else if (prtd->cmd_interrupt == 1) {
+ 		/*
+ 		 * This scenario might not happen as we do not allow
+ 		 * flush in transition state.
+ 		 */
+ 		pr_debug("%s: wait_for_stream_avail interrupted\n", __func__);
+ 		prtd->cmd_interrupt = 0;
+ 		prtd->stream_available = 0;
+ 		rc = -EINTR;
+ 	} else {
+ 		prtd->stream_available = 0;
+ 		rc = 0;
+ 	}
+ 	pr_debug("%s : rc = %d",  __func__, rc);
+ 	return rc;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_trigger(struct snd_compr_stream *cstream, int cmd)
  {
  	struct snd_compr_runtime *runtime = cstream->runtime;
@@@ -786,6 -1164,7 +1412,10 @@@
  	int bytes_to_write;
  	unsigned long flags;
  	int stream_id;
++<<<<<<< HEAD
++=======
+ 	uint32_t stream_index;
++>>>>>>> FETCH_HEAD
  
  	if (cstream->direction != SND_COMPRESS_PLAYBACK) {
  		pr_err("%s: Unsupported stream type\n", __func__);
@@@ -817,6 -1196,13 +1447,16 @@@
  					prtd->gapless_state.gapless_transition);
  		stream_id = ac->stream_id;
  		atomic_set(&prtd->start, 0);
++<<<<<<< HEAD
++=======
+ 		if (prtd->next_stream) {
+ 			pr_debug("%s: interrupt next track wait queues\n",
+ 								__func__);
+ 			prtd->cmd_interrupt = 1;
+ 			wake_up(&prtd->wait_for_stream_avail);
+ 			prtd->next_stream = 0;
+ 		}
++>>>>>>> FETCH_HEAD
  		if (atomic_read(&prtd->eos)) {
  			pr_debug("%s: interrupt eos wait queues", __func__);
  			prtd->cmd_interrupt = 1;
@@@ -831,25 -1217,14 +1471,36 @@@
  			atomic_set(&prtd->drain, 0);
  		}
  		prtd->last_buffer = 0;
++<<<<<<< HEAD
 +		pr_debug("issue CMD_FLUSH\n");
 +		prtd->cmd_ack = 0;
 +		if (!prtd->gapless_state.gapless_transition) {
 +			spin_unlock_irqrestore(&prtd->lock, flags);
 +			rc = q6asm_stream_cmd(
 +				prtd->audio_client, CMD_FLUSH, stream_id);
 +			if (rc < 0) {
 +				pr_err("%s: flush cmd failed rc=%d\n",
 +							__func__, rc);
 +				return rc;
 +			}
 +			rc = wait_event_timeout(prtd->flush_wait,
 +					prtd->cmd_ack, 1 * HZ);
 +			if (!rc) {
 +				rc = -ETIMEDOUT;
 +				pr_err("Flush cmd timeout\n");
 +			} else {
 +				rc = 0; /* prtd->cmd_status == OK? 0 : -EPERM*/
 +			}
++=======
+ 		prtd->cmd_ack = 0;
+ 		if (!prtd->gapless_state.gapless_transition) {
+ 			pr_debug("issue CMD_FLUSH stream_id %d\n", stream_id);
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
+ 			q6asm_stream_cmd(
+ 				prtd->audio_client, CMD_FLUSH, stream_id);
+ 			wait_event_timeout(prtd->flush_wait,
+ 					prtd->cmd_ack, 1 * HZ);
++>>>>>>> FETCH_HEAD
  			spin_lock_irqsave(&prtd->lock, flags);
  		} else {
  			prtd->first_buffer = 0;
@@@ -859,6 -1234,9 +1510,12 @@@
  		prtd->copied_total = 0;
  		prtd->app_pointer  = 0;
  		prtd->bytes_received = 0;
++<<<<<<< HEAD
++=======
+ 		prtd->bytes_sent = 0;
+ 		prtd->marker_timestamp = 0;
+ 
++>>>>>>> FETCH_HEAD
  		atomic_set(&prtd->xrun, 0);
  		spin_unlock_irqrestore(&prtd->lock, flags);
  		break;
@@@ -866,7 -1244,9 +1523,13 @@@
  		pr_debug("SNDRV_PCM_TRIGGER_PAUSE_PUSH transition %d\n",
  				prtd->gapless_state.gapless_transition);
  		if (!prtd->gapless_state.gapless_transition) {
++<<<<<<< HEAD
 +			q6asm_cmd_nowait(prtd->audio_client, CMD_PAUSE);
++=======
+ 			pr_debug("issue CMD_PAUSE stream_id %d\n",
+ 				  ac->stream_id);
+ 			q6asm_stream_cmd_nowait(ac, CMD_PAUSE, ac->stream_id);
++>>>>>>> FETCH_HEAD
  			atomic_set(&prtd->start, 0);
  		}
  		break;
@@@ -942,7 -1322,8 +1605,12 @@@
  
  			/* send EOS */
  			prtd->cmd_ack = 0;
++<<<<<<< HEAD
 +			q6asm_cmd_nowait(prtd->audio_client, CMD_EOS);
++=======
+ 			pr_debug("issue CMD_EOS stream_id %d\n", ac->stream_id);
+ 			q6asm_stream_cmd_nowait(ac, CMD_EOS, ac->stream_id);
++>>>>>>> FETCH_HEAD
  			pr_info("PARTIAL DRAIN, do not wait for EOS ack\n");
  
  			/* send a zero length buffer */
@@@ -979,13 -1360,16 +1647,24 @@@
  			}
  
  			/* move to next stream and reset vars */
++<<<<<<< HEAD
 +			pr_debug("%s: Moving to next stream in gapless\n", __func__);
 +			ac->stream_id ^= 1;
++=======
+ 			pr_debug("%s: Moving to next stream in gapless\n",
+ 								__func__);
+ 			ac->stream_id = NEXT_STREAM_ID(ac->stream_id);
++>>>>>>> FETCH_HEAD
  			prtd->byte_offset = 0;
  			prtd->app_pointer  = 0;
  			prtd->first_buffer = 1;
  			prtd->last_buffer = 0;
  			prtd->gapless_state.gapless_transition = 1;
++<<<<<<< HEAD
++=======
+ 			prtd->marker_timestamp = 0;
+ 
++>>>>>>> FETCH_HEAD
  			/*
  			Don't reset these as these vars map to
  			total_bytes_transferred and total_bytes_available
@@@ -1007,11 -1391,11 +1686,19 @@@
  		   stream can be used for gapless playback
  		*/
  		prtd->gapless_state.set_next_stream_id = false;
++<<<<<<< HEAD
 +		pr_debug("%s: CMD_EOS\n", __func__);
 +
 +		prtd->cmd_ack = 0;
 +		atomic_set(&prtd->eos, 1);
 +		q6asm_cmd_nowait(prtd->audio_client, CMD_EOS);
++=======
+ 		pr_debug("%s:CMD_EOS stream_id %d\n", __func__, ac->stream_id);
+ 
+ 		prtd->cmd_ack = 0;
+ 		atomic_set(&prtd->eos, 1);
+ 		q6asm_stream_cmd_nowait(ac, CMD_EOS, ac->stream_id);
++>>>>>>> FETCH_HEAD
  
  		spin_unlock_irqrestore(&prtd->lock, flags);
  
@@@ -1023,7 -1407,8 +1710,12 @@@
  		if (rc < 0)
  			pr_err("%s: EOS wait failed\n", __func__);
  
++<<<<<<< HEAD
 +		pr_debug("%s: SNDRV_COMPRESS_DRAIN  out of wait for EOS\n", __func__);
++=======
+ 		pr_debug("%s: SNDRV_COMPRESS_DRAIN  out of wait for EOS\n",
+ 			  __func__);
++>>>>>>> FETCH_HEAD
  
  		if (prtd->cmd_interrupt)
  			rc = -EINTR;
@@@ -1035,32 -1420,44 +1727,71 @@@
  			 * so prepare the current stream in session for gapless playback
  			 */
  			spin_lock_irqsave(&prtd->lock, flags);
++<<<<<<< HEAD
 +			pr_debug("%s: issue CMD_PAUSE ", __func__);
 +			q6asm_cmd_nowait(prtd->audio_client, CMD_PAUSE);
 +			prtd->cmd_ack = 0;
 +			spin_unlock_irqrestore(&prtd->lock, flags);
 +			pr_debug("%s: issue CMD_FLUSH", __func__);
 +			q6asm_cmd(prtd->audio_client, CMD_FLUSH);
 +			wait_event_timeout(prtd->flush_wait,
 +					   prtd->cmd_ack, 1 * HZ / 4);
 +
 +			spin_lock_irqsave(&prtd->lock, flags);
 +			/*
 +			Don't reset these as these vars map to
 +			total_bytes_transferred and total_bytes_available
 +			directly, only total_bytes_transferred will be updated
 +			in the next avail() ioctl
 +			prtd->copied_total = 0;
 +			prtd->bytes_received = 0;
 +			*/
 +			prtd->byte_offset = 0;
++=======
+ 			pr_debug("%s:issue CMD_PAUSE stream_id %d",
+ 					  __func__, ac->stream_id);
+ 			q6asm_stream_cmd_nowait(ac, CMD_PAUSE, ac->stream_id);
+ 			prtd->cmd_ack = 0;
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
+ 
+ 			/*
+ 			 * Cache this time as last known time
+ 			 */
+ 			q6asm_get_session_time(prtd->audio_client,
+ 					       &prtd->marker_timestamp);
+ 			spin_lock_irqsave(&prtd->lock, flags);
+ 			/*
+ 			 * Don't reset these as these vars map to
+ 			 * total_bytes_transferred and total_bytes_available.
+ 			 * Just total_bytes_transferred will be updated
+ 			 * in the next avail() ioctl.
+ 			 * prtd->copied_total = 0;
+ 			 * prtd->bytes_received = 0;
+ 			 * do not reset prtd->bytes_sent as well as the same
+ 			 * session is used for gapless playback
+ 			 */
+ 			prtd->byte_offset = 0;
+ 
++>>>>>>> FETCH_HEAD
  			prtd->app_pointer  = 0;
  			prtd->first_buffer = 1;
  			prtd->last_buffer = 0;
  			atomic_set(&prtd->drain, 0);
  			atomic_set(&prtd->xrun, 1);
++<<<<<<< HEAD
 +			q6asm_run_nowait(prtd->audio_client, 0, 0, 0);
 +			spin_unlock_irqrestore(&prtd->lock, flags);
++=======
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
+ 
+ 			pr_debug("%s:issue CMD_FLUSH ac->stream_id %d",
+ 					      __func__, ac->stream_id);
+ 			q6asm_stream_cmd(ac, CMD_FLUSH, ac->stream_id);
+ 			wait_event_timeout(prtd->flush_wait,
+ 					   prtd->cmd_ack, 1 * HZ / 4);
+ 
+ 			q6asm_run_nowait(prtd->audio_client, 0, 0, 0);
++>>>>>>> FETCH_HEAD
  		}
  		prtd->cmd_interrupt = 0;
  		break;
@@@ -1073,13 -1470,56 +1804,66 @@@
  		pr_debug("%s: SND_COMPR_TRIGGER_NEXT_TRACK\n", __func__);
  		spin_lock_irqsave(&prtd->lock, flags);
  		rc = 0;
++<<<<<<< HEAD
 +		stream_id = ac->stream_id^1; /*next stream in gapless*/
 +		if (prtd->gapless_state.stream_opened[stream_id]) {
 +			pr_debug("next session is already in opened state\n");
 +			spin_unlock_irqrestore(&prtd->lock, flags);
 +			break;
 +		}
 +		spin_unlock_irqrestore(&prtd->lock, flags);
++=======
+ 		/* next stream in gapless */
+ 		stream_id = NEXT_STREAM_ID(ac->stream_id);
+ 		/*
+ 		 * Wait if stream 1 has not completed before honoring next
+ 		 * track for stream 3. Scenario happens if second clip is
+ 		 * small and fills in one buffer so next track will be
+ 		 * called immediately.
+ 		 */
+ 		stream_index = STREAM_ARRAY_INDEX(stream_id);
+ 		if (stream_index >= MAX_NUMBER_OF_STREAMS ||
+ 		    stream_index < 0) {
+ 			pr_err("%s: Invalid stream index: %d", __func__,
+ 				stream_index);
+ 			spin_unlock_irqrestore(&prtd->lock, flags);
+ 			rc = -EINVAL;
+ 			break;
+ 		}
+ 
+ 		if (prtd->gapless_state.stream_opened[stream_index]) {
+ 			if (prtd->gapless_state.gapless_transition) {
+ 				rc = msm_compr_wait_for_stream_avail(prtd,
+ 								    &flags);
+ 			} else {
+ 				/*
+ 				 * If session is already opened break out if
+ 				 * the state is not gapless transition. This
+ 				 * is when seek happens after the last buffer
+ 				 * is sent to the driver. Next track would be
+ 				 * called again after last buffer is sent.
+ 				 */
+ 				pr_debug("next session is in opened state\n");
+ 				spin_unlock_irqrestore(&prtd->lock, flags);
+ 				break;
+ 			}
+ 		}
+ 		spin_unlock_irqrestore(&prtd->lock, flags);
+ 		if (rc < 0) {
+ 			/*
+ 			 * if return type EINTR  then reset to zero. Tiny
+ 			 * compress treats EINTR as error and prevents PARTIAL
+ 			 * DRAIN. EINTR is not an error. wait for stream avail
+ 			 * is interrupted by some other command like FLUSH.
+ 			 */
+ 			if (rc == -EINTR) {
+ 				pr_debug("%s: EINTR reset rc to 0\n", __func__);
+ 				rc = 0;
+ 			}
+ 			break;
+ 		}
+ 		pr_debug("%s: open_write stream_id %d", __func__, stream_id);
++>>>>>>> FETCH_HEAD
  		rc = q6asm_stream_open_write_v2(prtd->audio_client,
  				prtd->codec, 16,
  				stream_id,
@@@ -1096,7 -1536,7 +1880,11 @@@
  			break;
  		}
  		spin_lock_irqsave(&prtd->lock, flags);
++<<<<<<< HEAD
 +		prtd->gapless_state.stream_opened[stream_id] = 1;
++=======
+ 		prtd->gapless_state.stream_opened[stream_index] = 1;
++>>>>>>> FETCH_HEAD
  		prtd->gapless_state.set_next_stream_id = true;
  		spin_unlock_irqrestore(&prtd->lock, flags);
  		break;
@@@ -1123,13 -1563,12 +1911,20 @@@ static int msm_compr_pointer(struct snd
  	tstamp.byte_offset = prtd->byte_offset;
  	tstamp.copied_total = prtd->copied_total;
  	first_buffer = prtd->first_buffer;
++<<<<<<< HEAD
 +
++=======
++>>>>>>> FETCH_HEAD
  	if (atomic_read(&prtd->error)) {
  		pr_err("%s Got RESET EVENTS notification, return error", __func__);
  		tstamp.pcm_io_frames = 0;
  		memcpy(arg, &tstamp, sizeof(struct snd_compr_tstamp));
  		spin_unlock_irqrestore(&prtd->lock, flags);
++<<<<<<< HEAD
 +		return -EINVAL;
++=======
+ 		return -ENETRESET;
++>>>>>>> FETCH_HEAD
  	}
  
  	spin_unlock_irqrestore(&prtd->lock, flags);
@@@ -1143,8 -1582,13 +1938,18 @@@
  		if (rc < 0) {
  			pr_err("%s: Get Session Time return value =%lld\n",
  				__func__, timestamp);
++<<<<<<< HEAD
 +			return -EAGAIN;
 +		}
++=======
+ 			if (atomic_read(&prtd->error))
+ 				return -ENETRESET;
+ 			else
+ 				return -EAGAIN;
+ 		}
+ 	} else {
+ 		timestamp = prtd->marker_timestamp;
++>>>>>>> FETCH_HEAD
  	}
  
  	/* DSP returns timestamp in usec */
@@@ -1224,7 -1668,7 +2029,11 @@@ static int msm_compr_copy(struct snd_co
  	if (atomic_read(&prtd->error)) {
  		pr_err("%s Got RESET EVENTS notification", __func__);
  		spin_unlock_irqrestore(&prtd->lock, flags);
++<<<<<<< HEAD
 +		return -EINVAL;
++=======
+ 		return -ENETRESET;
++>>>>>>> FETCH_HEAD
  	}
  	spin_unlock_irqrestore(&prtd->lock, flags);
  
@@@ -1247,8 -1691,6 +2056,11 @@@
  	 * since the available bytes fits fragment_size, copy the data right away
  	 */
  	spin_lock_irqsave(&prtd->lock, flags);
++<<<<<<< HEAD
 +	if (prtd->gapless_state.gapless_transition)
 +		prtd->gapless_state.gapless_transition = 0;
++=======
++>>>>>>> FETCH_HEAD
  	prtd->bytes_received += count;
  	if (atomic_read(&prtd->start)) {
  		if (atomic_read(&prtd->xrun)) {
@@@ -1274,11 -1716,17 +2086,25 @@@ static int msm_compr_get_caps(struct sn
  {
  	struct snd_compr_runtime *runtime = cstream->runtime;
  	struct msm_compr_audio *prtd = runtime->private_data;
++<<<<<<< HEAD
 +
 +	pr_debug("%s\n", __func__);
 +	memcpy(arg, &prtd->compr_cap, sizeof(struct snd_compr_caps));
 +
 +	return 0;
++=======
+ 	int ret = 0;
+ 
+ 	pr_debug("%s\n", __func__);
+ 	if ((arg != NULL) && (prtd != NULL)) {
+ 		memcpy(arg, &prtd->compr_cap, sizeof(struct snd_compr_caps));
+ 	} else {
+ 		ret = -EINVAL;
+ 		pr_err("%s: arg (0x%p), prtd (0x%p)\n", __func__, arg, prtd);
+ 	}
+ 
+ 	return ret;
++>>>>>>> FETCH_HEAD
  }
  
  static int msm_compr_get_codec_caps(struct snd_compr_stream *cstream,
@@@ -1315,6 -1763,8 +2141,11 @@@
  		break;
  	case SND_AUDIOCODEC_EAC3:
  		break;
++<<<<<<< HEAD
++=======
+ 	case SND_AUDIOCODEC_FLAC:
+ 		break;
++>>>>>>> FETCH_HEAD
  	default:
  		pr_err("%s: Unsupported audio codec %d\n",
  			__func__, codec->codec);
@@@ -1335,8 -1785,10 +2166,15 @@@ static int msm_compr_set_metadata(struc
  		return -EINVAL;
  
  	prtd = cstream->runtime->private_data;
++<<<<<<< HEAD
 +	if (!prtd && !prtd->audio_client)
 +		return -EINVAL;
++=======
+ 	if (!prtd || !prtd->audio_client) {
+ 		pr_err("%s: prtd or audio client is NULL\n", __func__);
+ 		return -EINVAL;
+ 	}
++>>>>>>> FETCH_HEAD
  	ac = prtd->audio_client;
  	if (metadata->key == SNDRV_COMPRESS_ENCODER_PADDING) {
  		pr_debug("%s, got encoder padding %u", __func__, metadata->value[0]);
@@@ -1470,6 -1922,75 +2308,78 @@@ static int msm_compr_audio_effects_conf
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_compr_dec_params_put(struct snd_kcontrol *kcontrol,
+ 				    struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+ 	unsigned long fe_id = kcontrol->private_value;
+ 	struct msm_compr_pdata *pdata = (struct msm_compr_pdata *)
+ 			snd_soc_platform_get_drvdata(platform);
+ 	struct msm_compr_dec_params *dec_params = NULL;
+ 	struct snd_compr_stream *cstream = NULL;
+ 	struct msm_compr_audio *prtd = NULL;
+ 	long *values = &(ucontrol->value.integer.value[0]);
+ 
+ 	pr_debug("%s\n", __func__);
+ 	if (fe_id >= MSM_FRONTEND_DAI_MAX) {
+ 		pr_err("%s Received out of bounds fe_id %lu\n",
+ 			__func__, fe_id);
+ 		return -EINVAL;
+ 	}
+ 
+ 	cstream = pdata->cstream[fe_id];
+ 	dec_params = pdata->dec_params[fe_id];
+ 
+ 	if (!cstream || !dec_params) {
+ 		pr_err("%s: stream or dec_params inactive\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 	prtd = cstream->runtime->private_data;
+ 	if (!prtd) {
+ 		pr_err("%s: cannot set dec_params\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 	switch (prtd->codec) {
+ 	case FORMAT_MP3:
+ 	case FORMAT_MPEG4_AAC:
+ 	case FORMAT_FLAC:
+ 		pr_debug("%s: no runtime parameters for codec: %d\n", __func__,
+ 			 prtd->codec);
+ 		break;
+ 	case FORMAT_AC3:
+ 	case FORMAT_EAC3: {
+ 		struct snd_dec_ddp *ddp = &dec_params->ddp_params;
+ 		int cnt;
+ 		ddp->params_length = (*values++);
+ 		if (ddp->params_length > DDP_DEC_MAX_NUM_PARAM) {
+ 			pr_err("%s: invalid num of params:: %d\n", __func__,
+ 				ddp->params_length);
+ 			return -EINVAL;
+ 		}
+ 		for (cnt = 0; cnt < ddp->params_length; cnt++) {
+ 			ddp->params_id[cnt] = *values++;
+ 			ddp->params_value[cnt] = *values++;
+ 		}
+ 		if (msm_compr_send_ddp_cfg(prtd->audio_client, ddp) < 0)
+ 			pr_err("%s: DDP CMD CFG failed\n", __func__);
+ 		break;
+ 	}
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static int msm_compr_dec_params_get(struct snd_kcontrol *kcontrol,
+ 				    struct snd_ctl_elem_value *ucontrol)
+ {
+ 	/* dummy function */
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_probe(struct snd_soc_platform *platform)
  {
  	struct msm_compr_pdata *pdata;
@@@ -1489,6 -2010,7 +2399,10 @@@
  		pdata->volume[i][0] = COMPRESSED_LR_VOL_MAX_STEPS;
  		pdata->volume[i][1] = COMPRESSED_LR_VOL_MAX_STEPS;
  		pdata->audio_effects[i] = NULL;
++<<<<<<< HEAD
++=======
+ 		pdata->dec_params[i] = NULL;
++>>>>>>> FETCH_HEAD
  		pdata->cstream[i] = NULL;
  	}
  
@@@ -1522,6 -2044,16 +2436,19 @@@ static int msm_compr_audio_effects_conf
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_compr_dec_params_info(struct snd_kcontrol *kcontrol,
+ 				     struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = 128;
+ 	uinfo->value.integer.min = 0;
+ 	uinfo->value.integer.max = 0xFFFFFFFF;
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_add_volume_control(struct snd_soc_pcm_runtime *rtd)
  {
  	const char *mixer_ctl_name = "Compress Playback";
@@@ -1561,7 -2093,7 +2488,11 @@@
  		 rtd->pcm->device, suffix);
  	fe_volume_control[0].name = mixer_str;
  	fe_volume_control[0].private_value = rtd->dai_link->be_id;
++<<<<<<< HEAD
 +	pr_debug("Registering new mixer ctl %s\n", mixer_str);
++=======
+ 	pr_debug("Registering new mixer ctl %s", mixer_str);
++>>>>>>> FETCH_HEAD
  	snd_soc_add_platform_controls(rtd->platform, fe_volume_control,
  				      ARRAY_SIZE(fe_volume_control));
  	kfree(mixer_str);
@@@ -1608,7 -2140,7 +2539,11 @@@ static int msm_compr_add_audio_effects_
  
  	fe_audio_effects_config_control[0].name = mixer_str;
  	fe_audio_effects_config_control[0].private_value = rtd->dai_link->be_id;
++<<<<<<< HEAD
 +	pr_debug("Registering new mixer ctl %s", mixer_str);
++=======
+ 	pr_debug("Registering new mixer ctl %s\n", mixer_str);
++>>>>>>> FETCH_HEAD
  	snd_soc_add_platform_controls(rtd->platform,
  				fe_audio_effects_config_control,
  				ARRAY_SIZE(fe_audio_effects_config_control));
@@@ -1648,6 -2180,57 +2583,60 @@@ static const struct snd_kcontrol_new ms
  			msm_compr_gapless_put),
  };
  
++<<<<<<< HEAD
++=======
+ static int msm_compr_add_dec_runtime_params_control(
+ 						struct snd_soc_pcm_runtime *rtd)
+ {
+ 	const char *mixer_ctl_name	= "Audio Stream";
+ 	const char *deviceNo		= "NN";
+ 	const char *suffix		= "Dec Params";
+ 	char *mixer_str = NULL;
+ 	int ctl_len;
+ 	struct snd_kcontrol_new fe_dec_params_control[1] = {
+ 		{
+ 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+ 		.name = "?",
+ 		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+ 		.info = msm_compr_dec_params_info,
+ 		.get = msm_compr_dec_params_get,
+ 		.put = msm_compr_dec_params_put,
+ 		.private_value = 0,
+ 		}
+ 	};
+ 
+ 	if (!rtd) {
+ 		pr_err("%s NULL rtd\n", __func__);
+ 		return 0;
+ 	}
+ 
+ 	pr_debug("%s: added new compr FE with name %s, id %d, cpu dai %s, device no %d\n",
+ 		 __func__, rtd->dai_link->name, rtd->dai_link->be_id,
+ 		 rtd->dai_link->cpu_dai_name, rtd->pcm->device);
+ 
+ 	ctl_len = strlen(mixer_ctl_name) + 1 + strlen(deviceNo) + 1 +
+ 		  strlen(suffix) + 1;
+ 	mixer_str = kzalloc(ctl_len, GFP_KERNEL);
+ 
+ 	if (!mixer_str) {
+ 		pr_err("failed to allocate mixer ctrl str of len %d", ctl_len);
+ 		return 0;
+ 	}
+ 
+ 	snprintf(mixer_str, ctl_len, "%s %d %s", mixer_ctl_name,
+ 		 rtd->pcm->device, suffix);
+ 
+ 	fe_dec_params_control[0].name = mixer_str;
+ 	fe_dec_params_control[0].private_value = rtd->dai_link->be_id;
+ 	pr_debug("Registering new mixer ctl %s", mixer_str);
+ 	snd_soc_add_platform_controls(rtd->platform,
+ 				      fe_dec_params_control,
+ 				      ARRAY_SIZE(fe_dec_params_control));
+ 	kfree(mixer_str);
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_compr_new(struct snd_soc_pcm_runtime *rtd)
  {
  	int rc;
@@@ -1659,6 -2242,10 +2648,13 @@@
  	if (rc)
  		pr_err("%s: Could not add Compr Audio Effects Control\n",
  			__func__);
++<<<<<<< HEAD
++=======
+ 	rc = msm_compr_add_dec_runtime_params_control(rtd);
+ 	if (rc)
+ 		pr_err("%s: Could not add Compr Dec runtime params Control\n",
+ 			__func__);
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -1681,6 -2268,7 +2677,10 @@@ static struct snd_soc_platform_driver m
  	.pcm_new	= msm_compr_new,
  	.controls       = msm_compr_gapless_controls,
  	.num_controls   = ARRAY_SIZE(msm_compr_gapless_controls),
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> FETCH_HEAD
  };
  
  static __devinit int msm_compr_dev_probe(struct platform_device *pdev)
diff --cc sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c
index c07519e,c861b8c..0000000
--- a/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c
@@@ -57,6 -57,7 +57,10 @@@ enum 
  
  struct msm_dai_q6_dai_data {
  	DECLARE_BITMAP(status_mask, STATUS_MAX);
++<<<<<<< HEAD
++=======
+ 	DECLARE_BITMAP(hwfree_status, STATUS_MAX);
++>>>>>>> FETCH_HEAD
  	u32 rate;
  	u32 channels;
  	u32 bitwidth;
@@@ -1511,6 -1512,11 +1515,14 @@@ static int msm_dai_q6_mi2s_prepare(stru
  			set_bit(STATUS_PORT_STARTED,
  				dai_data->status_mask);
  	}
++<<<<<<< HEAD
++=======
+ 	if (!test_bit(STATUS_PORT_STARTED, dai_data->hwfree_status)) {
+ 		set_bit(STATUS_PORT_STARTED, dai_data->hwfree_status);
+ 		dev_dbg(dai->dev, "%s: set hwfree_status to started\n",
+ 				__func__);
+ 	}
++>>>>>>> FETCH_HEAD
  	return rc;
  }
  
@@@ -1526,7 -1532,6 +1538,10 @@@ static int msm_dai_q6_mi2s_hw_params(st
  	struct msm_dai_q6_dai_data *dai_data = &mi2s_dai_config->mi2s_dai_data;
  	struct afe_param_id_i2s_cfg *i2s = &dai_data->port_config.i2s;
  
++<<<<<<< HEAD
 +
++=======
++>>>>>>> FETCH_HEAD
  	dai_data->channels = params_channels(params);
  	switch (dai_data->channels) {
  	case 8:
@@@ -1603,10 -1608,14 +1618,21 @@@
  	dai_data->port_config.i2s.i2s_cfg_minor_version =
  			AFE_API_VERSION_I2S_CONFIG;
  	dai_data->port_config.i2s.sample_rate = dai_data->rate;
++<<<<<<< HEAD
 +	if (test_bit(STATUS_PORT_STARTED,
 +	    mi2s_dai_data->rx_dai.mi2s_dai_data.status_mask) ||
 +	    test_bit(STATUS_PORT_STARTED,
 +	    mi2s_dai_data->tx_dai.mi2s_dai_data.status_mask)) {
++=======
+ 	if ((test_bit(STATUS_PORT_STARTED,
+ 	    mi2s_dai_data->rx_dai.mi2s_dai_data.status_mask) &&
+ 	    test_bit(STATUS_PORT_STARTED,
+ 	    mi2s_dai_data->rx_dai.mi2s_dai_data.hwfree_status)) ||
+ 	    (test_bit(STATUS_PORT_STARTED,
+ 	    mi2s_dai_data->tx_dai.mi2s_dai_data.status_mask) &&
+ 	    test_bit(STATUS_PORT_STARTED,
+ 	    mi2s_dai_data->tx_dai.mi2s_dai_data.hwfree_status))) {
++>>>>>>> FETCH_HEAD
  		if ((mi2s_dai_data->tx_dai.mi2s_dai_data.rate !=
  		    mi2s_dai_data->rx_dai.mi2s_dai_data.rate) ||
  		   (mi2s_dai_data->rx_dai.mi2s_dai_data.bitwidth !=
@@@ -1670,6 -1679,23 +1696,26 @@@ static int msm_dai_q6_mi2s_set_fmt(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_dai_q6_mi2s_hw_free(struct snd_pcm_substream *substream,
+ 		struct snd_soc_dai *dai)
+ {
+ 	struct msm_dai_q6_mi2s_dai_data *mi2s_dai_data =
+ 			dev_get_drvdata(dai->dev);
+ 	struct msm_dai_q6_dai_data *dai_data =
+ 		(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+ 		 &mi2s_dai_data->rx_dai.mi2s_dai_data :
+ 		 &mi2s_dai_data->tx_dai.mi2s_dai_data);
+ 
+ 	if (test_bit(STATUS_PORT_STARTED, dai_data->hwfree_status)) {
+ 		clear_bit(STATUS_PORT_STARTED, dai_data->hwfree_status);
+ 		dev_dbg(dai->dev, "%s: clear hwfree_status\n", __func__);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static void msm_dai_q6_mi2s_shutdown(struct snd_pcm_substream *substream,
  				     struct snd_soc_dai *dai)
  {
@@@ -1697,12 -1723,15 +1743,21 @@@
  			dev_err(dai->dev, "fail to close AFE port\n");
  		clear_bit(STATUS_PORT_STARTED, dai_data->status_mask);
  	}
++<<<<<<< HEAD
++=======
+ 	if (test_bit(STATUS_PORT_STARTED, dai_data->hwfree_status))
+ 		clear_bit(STATUS_PORT_STARTED, dai_data->hwfree_status);
++>>>>>>> FETCH_HEAD
  }
  
  static struct snd_soc_dai_ops msm_dai_q6_mi2s_ops = {
  	.startup	= msm_dai_q6_mi2s_startup,
  	.prepare	= msm_dai_q6_mi2s_prepare,
  	.hw_params	= msm_dai_q6_mi2s_hw_params,
++<<<<<<< HEAD
++=======
+ 	.hw_free	= msm_dai_q6_mi2s_hw_free,
++>>>>>>> FETCH_HEAD
  	.set_fmt	= msm_dai_q6_mi2s_set_fmt,
  	.shutdown	= msm_dai_q6_mi2s_shutdown,
  };
diff --cc sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
index 307d63e,161904c..0000000
--- a/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
+++ b/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.c
@@@ -179,13 -179,13 +179,21 @@@ const struct dolby_dap_endp_params_
  		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
  		{-320, -320, 144}
  	},
++<<<<<<< HEAD
 +	{REMOTE_SUBMIX,	2, DOLBY_ENDP_EXT_SPEAKERS,
++=======
+ 	{REMOTE_SUBMIX,	2, DOLBY_ENDP_HDMI,
++>>>>>>> FETCH_HEAD
  		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
  		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
  		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
  		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
  		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
++<<<<<<< HEAD
 +		{-320, -320, 144}
++=======
+ 		{-496, -496, 0}
++>>>>>>> FETCH_HEAD
  	},
  	{ANC_HEADSET, 2, DOLBY_ENDP_HEADPHONES,
  		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
@@@ -211,7 -211,7 +219,11 @@@
  		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
  		{-320, -320, 144}
  	},
++<<<<<<< HEAD
 +	{FM, 2, DOLBY_ENDP_EXT_SPEAKERS,
++=======
+ 	{PROXY,	6, DOLBY_ENDP_EXT_SPEAKERS,
++>>>>>>> FETCH_HEAD
  		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
  		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
  		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
@@@ -219,6 -219,14 +231,17 @@@
  		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
  		{-320, -320, 144}
  	},
++<<<<<<< HEAD
++=======
+ 	{FM, 2, DOLBY_ENDP_HDMI,
+ 		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
+ 		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
+ 		 DOLBY_ENDDEP_PARAM_VMB_LENGTH},
+ 		{DOLBY_ENDDEP_PARAM_DVLO_OFFSET, DOLBY_ENDDEP_PARAM_DVLI_OFFSET,
+ 		 DOLBY_ENDDEP_PARAM_VMB_OFFSET},
+ 		{-496, -496, 0}
+ 	},
++>>>>>>> FETCH_HEAD
  	{FM_TX,	2, DOLBY_ENDP_EXT_SPEAKERS,
  		{DOLBY_PARAM_ID_DVLO, DOLBY_PARAM_ID_DVLI, DOLBY_PARAM_ID_VMB},
  		{DOLBY_ENDDEP_PARAM_DVLO_LENGTH, DOLBY_ENDDEP_PARAM_DVLI_LENGTH,
@@@ -409,7 -417,8 +432,12 @@@ static int dolby_dap_send_enddep_params
  	for (idx = 0; idx < NUM_DOLBY_ENDP_DEVICE; idx++) {
  		if (dolby_dap_endp_params[idx].device ==
  			dolby_dap_params_states.device) {
++<<<<<<< HEAD
 +			if (dolby_dap_params_states.device == AUX_DIGITAL) {
++=======
+ 			if (dolby_dap_params_states.device == AUX_DIGITAL ||
+ 			    dolby_dap_params_states.device == PROXY) {
++>>>>>>> FETCH_HEAD
  				if (dolby_dap_endp_params[idx].device_ch_caps ==
  					device_channels)
  					break;
diff --cc sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h
index 4544fea,14586f4..0000000
--- a/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h
+++ b/sound/soc/msm/qdsp6v2/msm-dolby-dap-config.h
@@@ -249,7 -249,7 +249,11 @@@
  #define DOLBY_AUTO_ENDDEP_IDX			(MAX_DOLBY_PARAMS+4)
  
  #define TOTAL_LENGTH_DOLBY_PARAM		745
++<<<<<<< HEAD
 +#define NUM_DOLBY_ENDP_DEVICE			23
++=======
+ #define NUM_DOLBY_ENDP_DEVICE			24
++>>>>>>> FETCH_HEAD
  #define DOLBY_VIS_PARAM_HEADER_SIZE		 25
  
  #define DOLBY_INVALID_PORT_ID			-1
diff --cc sound/soc/msm/qdsp6v2/msm-lsm-client.c
index 3f57078,ff82299..0000000
--- a/sound/soc/msm/qdsp6v2/msm-lsm-client.c
+++ b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
@@@ -170,6 -170,9 +170,12 @@@ static int msm_lsm_ioctl(struct snd_pcm
  				 */
  				rc = -EFAULT;
  			} else {
++<<<<<<< HEAD
++=======
+ 				if (!access_ok(VERIFY_READ, user,
+ 					sizeof(struct snd_lsm_event_status)))
+ 					rc = -EFAULT;
++>>>>>>> FETCH_HEAD
  				if (user->payload_size <
  				    event_status->payload_size) {
  					pr_debug("%s: provided %dbytes isn't enough, needs %dbytes\n",
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
index d80ca19,35278cd..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
@@@ -30,13 -30,12 +30,21 @@@
  #include <sound/control.h>
  #include <sound/q6adm-v2.h>
  #include <asm/dma.h>
++<<<<<<< HEAD
 +#include <linux/memory_alloc.h>
++=======
++>>>>>>> FETCH_HEAD
  #include "msm-pcm-afe-v2.h"
  
  #define MIN_PLAYBACK_PERIOD_SIZE (128 * 2)
  #define MAX_PLAYBACK_PERIOD_SIZE (128 * 2 * 2 * 6)
++<<<<<<< HEAD
 +#define MIN_PLAYBACK_NUM_PERIODS (64)
 +#define MAX_PLAYBACK_NUM_PERIODS (768)
++=======
+ #define MIN_PLAYBACK_NUM_PERIODS (32)
+ #define MAX_PLAYBACK_NUM_PERIODS (384)
++>>>>>>> FETCH_HEAD
  
  #define MIN_CAPTURE_PERIOD_SIZE (128 * 2 * 4)
  #define MAX_CAPTURE_PERIOD_SIZE (128 * 2 * 2 * 6 * 4)
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c
index c80d2a3,7e1f2c5..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -220,6 -220,12 +224,15 @@@ static void event_handler(uint32_t opco
  		}
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 	case RESET_EVENTS:
+ 		pr_debug("%s RESET_EVENTS\n", __func__);
+ 		prtd->cmd_ack = 1;
+ 		prtd->reset_event = true;
+ 		wake_up(&the_locks.eos_wait);
+ 		break;
++>>>>>>> FETCH_HEAD
  	default:
  		pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
  		break;
@@@ -388,6 -394,7 +401,10 @@@ static int msm_pcm_open(struct snd_pcm_
  	}
  	runtime->hw = msm_pcm_hardware;
  	prtd->substream = substream;
++<<<<<<< HEAD
++=======
+ 	prtd->reset_event = false;
++>>>>>>> FETCH_HEAD
  	runtime->render_flag = SNDRV_DMA_MODE;
  	prtd->audio_client = q6asm_audio_client_alloc(
  				(app_cb)event_handler, prtd);
@@@ -595,7 -602,6 +612,10 @@@ static int msm_pcm_hw_params(struct snd
  		prtd->audio_client->perf_mode,
  		prtd->session_id, substream->stream);
  
++<<<<<<< HEAD
 +	lpa_set_volume(prtd, 0);
++=======
++>>>>>>> FETCH_HEAD
  	ret = q6asm_set_softpause(prtd->audio_client, &softpause);
  	if (ret < 0)
  		pr_err("%s: Send SoftPause Param failed ret=%d\n",
@@@ -676,8 -682,13 +696,18 @@@ static int msm_pcm_ioctl(struct snd_pcm
  		rc = q6asm_cmd(prtd->audio_client, CMD_FLUSH);
  		if (rc < 0)
  			pr_err("%s: flush cmd failed rc=%d\n", __func__, rc);
++<<<<<<< HEAD
 +		rc = wait_event_timeout(the_locks.eos_wait,
 +			prtd->cmd_ack, 5 * HZ);
++=======
+ 		if (prtd->reset_event == true) {
+ 			prtd->cmd_ack = 1;
+ 			prtd->reset_event = false;
+ 			return -ENETRESET;
+ 		}
+ 		rc = wait_event_timeout(the_locks.eos_wait,
+ 			!prtd->reset_event && prtd->cmd_ack, 5 * HZ);
++>>>>>>> FETCH_HEAD
  		if (!rc)
  			pr_err("Flush cmd timeout\n");
  		prtd->pcm_irq_pos = 0;
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
index 65fa0ea,08945d6..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -25,11 -25,14 +29,20 @@@
  #include <sound/pcm.h>
  #include <sound/initval.h>
  #include <sound/control.h>
++<<<<<<< HEAD
++=======
+ #include <sound/q6audio-v2.h>
+ #include <sound/timer.h>
++>>>>>>> FETCH_HEAD
  #include <asm/dma.h>
  #include <linux/dma-mapping.h>
  #include <linux/msm_audio_ion.h>
  
  #include <linux/of_device.h>
++<<<<<<< HEAD
++=======
+ #include <sound/tlv.h>
++>>>>>>> FETCH_HEAD
  #include <sound/pcm_params.h>
  
  #include "msm-pcm-q6-v2.h"
@@@ -37,6 -40,10 +50,13 @@@
  
  static struct audio_locks the_locks;
  
++<<<<<<< HEAD
++=======
+ #define PCM_MASTER_VOL_MAX_STEPS	0x2000
+ static const DECLARE_TLV_DB_LINEAR(msm_pcm_vol_gain, 0,
+ 				PCM_MASTER_VOL_MAX_STEPS);
+ 
++>>>>>>> FETCH_HEAD
  struct snd_msm {
  	struct snd_card *card;
  	struct snd_pcm *pcm;
@@@ -44,12 -51,14 +64,21 @@@
  
  #define PLAYBACK_MIN_NUM_PERIODS    2
  #define PLAYBACK_MAX_NUM_PERIODS    8
++<<<<<<< HEAD
 +#define PLAYBACK_MAX_PERIOD_SIZE    30720
++=======
+ #define PLAYBACK_MAX_PERIOD_SIZE    12288
++>>>>>>> FETCH_HEAD
  #define PLAYBACK_MIN_PERIOD_SIZE    128
  #define CAPTURE_MIN_NUM_PERIODS     2
  #define CAPTURE_MAX_NUM_PERIODS     8
  #define CAPTURE_MAX_PERIOD_SIZE     4096
  #define CAPTURE_MIN_PERIOD_SIZE     320
++<<<<<<< HEAD
++=======
+ #define CMD_EOS_MIN_TIMEOUT_LENGTH  50
+ #define CMD_EOS_TIMEOUT_MULTIPLIER  (HZ * 50)
++>>>>>>> FETCH_HEAD
  
  static struct snd_pcm_hardware msm_pcm_hardware_capture = {
  	.info =                 (SNDRV_PCM_INFO_MMAP |
@@@ -98,7 -107,7 +127,11 @@@ static struct snd_pcm_hardware msm_pcm_
  /* Conventional and unconventional sample rate supported */
  static unsigned int supported_sample_rates[] = {
  	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
++<<<<<<< HEAD
 +	96000, 192000
++=======
+ 	88200, 96000, 176400, 192000
++>>>>>>> FETCH_HEAD
  };
  
  static uint32_t in_frame_info[CAPTURE_MAX_NUM_PERIODS][2];
@@@ -109,6 -118,25 +142,28 @@@ static struct snd_pcm_hw_constraint_lis
  	.mask = 0,
  };
  
++<<<<<<< HEAD
++=======
+ static void msm_pcm_route_event_handler(enum msm_pcm_routing_event event,
+ 					void *priv_data)
+ {
+ 	struct msm_audio *prtd = priv_data;
+ 
+ 	BUG_ON(!prtd);
+ 
+ 	pr_debug("%s: event %x\n", __func__, event);
+ 
+ 	switch (event) {
+ 	case MSM_PCM_RT_EVT_BUF_RECFG:
+ 		q6asm_cmd(prtd->audio_client, CMD_PAUSE);
+ 		q6asm_cmd(prtd->audio_client, CMD_FLUSH);
+ 		q6asm_run(prtd->audio_client, 0, 0, 0);
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> FETCH_HEAD
  static void event_handler(uint32_t opcode,
  		uint32_t token, uint32_t *payload, void *priv)
  {
@@@ -151,18 -179,34 +206,49 @@@
  		pr_debug("token = 0x%08x\n", token);
  		in_frame_info[token][0] = payload[4];
  		in_frame_info[token][1] = payload[5];
++<<<<<<< HEAD
 +		prtd->pcm_irq_pos += in_frame_info[token][0];
 +		pr_debug("pcm_irq_pos=%d\n", prtd->pcm_irq_pos);
 +		if (atomic_read(&prtd->start))
 +			snd_pcm_period_elapsed(substream);
 +		if (atomic_read(&prtd->in_count) <= prtd->periods)
 +			atomic_inc(&prtd->in_count);
 +		wake_up(&the_locks.read_wait);
 +		if (prtd->mmap_flag
 +			&& q6asm_is_cpu_buf_avail_nolock(OUT,
 +				prtd->audio_client,
 +				&size, &idx))
 +			q6asm_read_nolock(prtd->audio_client);
++=======
+ 		/* assume data size = 0 during flushing */
+ 		if (in_frame_info[token][0]) {
+ 			prtd->pcm_irq_pos += in_frame_info[token][0];
+ 			pr_debug("pcm_irq_pos=%d\n", prtd->pcm_irq_pos);
+ 			if (atomic_read(&prtd->start))
+ 				snd_pcm_period_elapsed(substream);
+ 			if (atomic_read(&prtd->in_count) <= prtd->periods)
+ 				atomic_inc(&prtd->in_count);
+ 			wake_up(&the_locks.read_wait);
+ 			if (prtd->mmap_flag &&
+ 			    q6asm_is_cpu_buf_avail_nolock(OUT,
+ 				prtd->audio_client,
+ 				&size, &idx) &&
+ 				(substream->runtime->status->state ==
+ 				 SNDRV_PCM_STATE_RUNNING))
+ 				q6asm_read_nolock(prtd->audio_client);
+ 		} else {
+ 			pr_debug("%s: reclaim flushed buf in_count %x\n",
+ 				__func__, atomic_read(&prtd->in_count));
+ 			prtd->pcm_irq_pos += prtd->pcm_count;
+ 			atomic_inc(&prtd->in_count);
+ 			if (atomic_read(&prtd->in_count) == prtd->periods) {
+ 				pr_info("%s: reclaimed all bufs\n", __func__);
+ 				if (atomic_read(&prtd->start))
+ 					snd_pcm_period_elapsed(substream);
+ 				wake_up(&the_locks.read_wait);
+ 			}
+ 		}
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	case APR_BASIC_RSP_RESULT: {
@@@ -201,6 -245,18 +287,21 @@@
  		}
  	}
  	break;
++<<<<<<< HEAD
++=======
+ 	case RESET_EVENTS:
+ 		pr_debug("%s RESET_EVENTS\n", __func__);
+ 		prtd->pcm_irq_pos += prtd->pcm_count;
+ 		atomic_inc(&prtd->out_count);
+ 		atomic_inc(&prtd->in_count);
+ 		prtd->reset_event = true;
+ 		if (atomic_read(&prtd->start))
+ 			snd_pcm_period_elapsed(substream);
+ 		wake_up(&the_locks.eos_wait);
+ 		wake_up(&the_locks.write_wait);
+ 		wake_up(&the_locks.read_wait);
+ 		break;
++>>>>>>> FETCH_HEAD
  	default:
  		pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
  		break;
@@@ -210,10 -266,21 +311,28 @@@
  static int msm_pcm_playback_prepare(struct snd_pcm_substream *substream)
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
++<<<<<<< HEAD
 +	struct msm_audio *prtd = runtime->private_data;
 +	int ret;
 +	uint16_t bits_per_sample = 16;
 +
++=======
+ 	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+ 	struct msm_audio *prtd = runtime->private_data;
+ 	struct msm_plat_data *pdata;
+ 	struct snd_pcm_hw_params *params;
+ 	int ret;
+ 	uint16_t bits_per_sample = 16;
+ 
+ 	pdata = (struct msm_plat_data *)
+ 		dev_get_drvdata(soc_prtd->platform->dev);
+ 	if (!pdata) {
+ 		pr_err("%s: platform data not populated\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 	params = &soc_prtd->dpcm[substream->stream].hw_params;
+ 
++>>>>>>> FETCH_HEAD
  	pr_debug("%s\n", __func__);
  	prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
  	prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
@@@ -224,6 -291,28 +343,31 @@@
  	if (prtd->enabled)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	prtd->audio_client->perf_mode = pdata->perf_mode;
+ 	pr_debug("%s: perf: %x\n", __func__, pdata->perf_mode);
+ 
+ 	if (params_format(params) == SNDRV_PCM_FORMAT_S24_LE)
+ 		bits_per_sample = 24;
+ 
+ 	ret = q6asm_open_write_v2(prtd->audio_client,
+ 			FORMAT_LINEAR_PCM, bits_per_sample);
+ 	if (ret < 0) {
+ 		pr_err("%s: q6asm_open_write_v2 failed\n", __func__);
+ 		q6asm_audio_client_free(prtd->audio_client);
+ 		prtd->audio_client = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pr_debug("%s: session ID %d\n", __func__,
+ 			prtd->audio_client->session);
+ 	prtd->session_id = prtd->audio_client->session;
+ 	msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
+ 			prtd->audio_client->perf_mode,
+ 			prtd->session_id, substream->stream);
+ 
++>>>>>>> FETCH_HEAD
  	switch (runtime->format) {
  	case SNDRV_PCM_FORMAT_S16_LE:
  		bits_per_sample = 16;
@@@ -253,11 -342,40 +397,46 @@@ static int msm_pcm_capture_prepare(stru
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
  	struct msm_audio *prtd = runtime->private_data;
++<<<<<<< HEAD
++=======
+ 	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
+ 	struct snd_pcm_hw_params *params;
+ 	struct msm_pcm_routing_evt event;
++>>>>>>> FETCH_HEAD
  	int ret = 0;
  	int i = 0;
  	uint16_t bits_per_sample = 16;
  
  	pr_debug("%s\n", __func__);
++<<<<<<< HEAD
++=======
+ 	params = &soc_prtd->dpcm[substream->stream].hw_params;
+ 	if (params_format(params) == SNDRV_PCM_FORMAT_S24_LE)
+ 		bits_per_sample = 24;
+ 
+ 	pr_debug("%s Opening %d-ch PCM read stream\n",
+ 			__func__, params_channels(params));
+ 	ret = q6asm_open_read_v2(prtd->audio_client, FORMAT_LINEAR_PCM,
+ 			bits_per_sample);
+ 	if (ret < 0) {
+ 		pr_err("%s: q6asm_open_read failed\n", __func__);
+ 		q6asm_audio_client_free(prtd->audio_client);
+ 		prtd->audio_client = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pr_debug("%s: session ID %d\n",
+ 			__func__, prtd->audio_client->session);
+ 	prtd->session_id = prtd->audio_client->session;
+ 	event.event_func = msm_pcm_route_event_handler;
+ 	event.priv_data = (void *) prtd;
+ 	msm_pcm_routing_reg_phy_stream_v2(
+ 			soc_prtd->dai_link->be_id,
+ 			prtd->audio_client->perf_mode,
+ 			prtd->session_id, substream->stream,
+ 			event);
+ 
++>>>>>>> FETCH_HEAD
  	prtd->pcm_size = snd_pcm_lib_buffer_bytes(substream);
  	prtd->pcm_count = snd_pcm_lib_period_bytes(substream);
  	prtd->pcm_irq_pos = 0;
@@@ -411,6 -529,7 +590,10 @@@ static int msm_pcm_open(struct snd_pcm_
  
  	prtd->dsp_cnt = 0;
  	prtd->set_channel_map = false;
++<<<<<<< HEAD
++=======
+ 	prtd->reset_event = false;
++>>>>>>> FETCH_HEAD
  	runtime->private_data = prtd;
  
  	return 0;
@@@ -433,6 -552,12 +616,15 @@@ static int msm_pcm_playback_copy(struc
  	fbytes = frames_to_bytes(runtime, frames);
  	pr_debug("%s: prtd->out_count = %d\n",
  				__func__, atomic_read(&prtd->out_count));
++<<<<<<< HEAD
++=======
+ 
+ 	if (prtd->reset_event) {
+ 		pr_err("%s: In SSR return ENETRESET before wait\n", __func__);
+ 		return -ENETRESET;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	ret = wait_event_timeout(the_locks.write_wait,
  			(atomic_read(&prtd->out_count)), 5 * HZ);
  	if (!ret) {
@@@ -440,6 -565,11 +632,14 @@@
  		goto fail;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (prtd->reset_event) {
+ 		pr_err("%s: In SSR return ENETRESET after wait\n", __func__);
+ 		return -ENETRESET;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	if (!atomic_read(&prtd->out_count)) {
  		pr_err("%s: pcm stopped out_count 0\n", __func__);
  		return 0;
@@@ -483,6 -613,7 +683,10 @@@ static int msm_pcm_playback_close(struc
  	struct snd_pcm_runtime *runtime = substream->runtime;
  	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
  	struct msm_audio *prtd = runtime->private_data;
++<<<<<<< HEAD
++=======
+ 	uint32_t timeout;
++>>>>>>> FETCH_HEAD
  	int dir = 0;
  	int ret = 0;
  
@@@ -490,9 -621,23 +694,29 @@@
  
  	if (prtd->audio_client) {
  		dir = IN;
++<<<<<<< HEAD
 +		ret = wait_event_timeout(the_locks.eos_wait,
 +					 !test_bit(CMD_EOS, &prtd->cmd_pending),
 +					 5 * HZ);
++=======
+ 
+ 		/* determine timeout length */
+ 		if (runtime->frame_bits == 0 || runtime->rate == 0) {
+ 			timeout = CMD_EOS_MIN_TIMEOUT_LENGTH;
+ 		} else {
+ 			timeout = (runtime->period_size *
+ 					CMD_EOS_TIMEOUT_MULTIPLIER) /
+ 					((runtime->frame_bits / 8) *
+ 					 runtime->rate);
+ 			if (timeout < CMD_EOS_MIN_TIMEOUT_LENGTH)
+ 				timeout = CMD_EOS_MIN_TIMEOUT_LENGTH;
+ 		}
+ 		pr_debug("%s: CMD_EOS timeout is %d\n", __func__, timeout);
+ 
+ 		ret = wait_event_timeout(the_locks.eos_wait,
+ 					 !test_bit(CMD_EOS, &prtd->cmd_pending),
+ 					 timeout);
++>>>>>>> FETCH_HEAD
  		if (!ret)
  			pr_err("%s: CMD_EOS failed, cmd_pending 0x%lx\n",
  			       __func__, prtd->cmd_pending);
@@@ -530,12 -675,20 +754,26 @@@ static int msm_pcm_capture_copy(struct 
  	pr_debug("hw_ptr %d\n", (int)runtime->status->hw_ptr);
  	pr_debug("avail_min %d\n", (int)runtime->control->avail_min);
  
++<<<<<<< HEAD
++=======
+ 	if (prtd->reset_event) {
+ 		pr_err("%s: In SSR return ENETRESET before wait\n", __func__);
+ 		return -ENETRESET;
+ 	}
++>>>>>>> FETCH_HEAD
  	ret = wait_event_timeout(the_locks.read_wait,
  			(atomic_read(&prtd->in_count)), 5 * HZ);
  	if (!ret) {
  		pr_debug("%s: wait_event_timeout failed\n", __func__);
  		goto fail;
  	}
++<<<<<<< HEAD
++=======
+ 	if (prtd->reset_event) {
+ 		pr_err("%s: In SSR return ENETRESET after wait\n", __func__);
+ 		return -ENETRESET;
+ 	}
++>>>>>>> FETCH_HEAD
  	if (!atomic_read(&prtd->in_count)) {
  		pr_debug("%s: pcm stopped in_count 0\n", __func__);
  		return 0;
@@@ -625,6 -778,7 +863,10 @@@ static int msm_pcm_close(struct snd_pcm
  		ret = msm_pcm_capture_close(substream);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> FETCH_HEAD
  static int msm_pcm_prepare(struct snd_pcm_substream *substream)
  {
  	int ret = 0;
@@@ -676,72 -830,14 +918,80 @@@ static int msm_pcm_hw_params(struct snd
  	struct snd_pcm_runtime *runtime = substream->runtime;
  	struct msm_audio *prtd = runtime->private_data;
  	struct snd_dma_buffer *dma_buf = &substream->dma_buffer;
++<<<<<<< HEAD
 +	struct snd_soc_pcm_runtime *soc_prtd = substream->private_data;
  	struct audio_buffer *buf;
  	int dir, ret;
 +	struct msm_plat_data *pdata;
 +	uint16_t bits_per_sample = 16;
 +
 +	pdata = (struct msm_plat_data *)
 +				dev_get_drvdata(soc_prtd->platform->dev);
 +	if (!pdata) {
 +		pr_err("%s: platform data not populated\n", __func__);
 +		return -EINVAL;
 +	}
++=======
++	struct audio_buffer *buf;
++	int dir, ret;
++>>>>>>> FETCH_HEAD
  
  	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
  		dir = IN;
  	else
  		dir = OUT;
  
++<<<<<<< HEAD
 +	prtd->audio_client->perf_mode = pdata->perf_mode;
 +	pr_debug("%s: perf: %x\n", __func__, pdata->perf_mode);
 +	/* Playback Path */
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 +		if (params_format(params) == SNDRV_PCM_FORMAT_S24_LE)
 +			bits_per_sample = 24;
 +
 +		ret = q6asm_open_write_v2(prtd->audio_client,
 +				FORMAT_LINEAR_PCM, bits_per_sample);
 +		if (ret < 0) {
 +			pr_err("%s: q6asm_open_write_v2 failed\n", __func__);
 +			q6asm_audio_client_free(prtd->audio_client);
 +			prtd->audio_client = NULL;
 +			return -ENOMEM;
 +		}
 +
 +		pr_debug("%s: session ID %d\n", __func__,
 +			prtd->audio_client->session);
 +		prtd->session_id = prtd->audio_client->session;
 +		msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
 +				prtd->audio_client->perf_mode,
 +				prtd->session_id, substream->stream);
 +	}
 +
 +	/* Capture Path */
 +	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 +		if (params_format(params) == SNDRV_PCM_FORMAT_S24_LE)
 +			bits_per_sample = 24;
 +
 +		pr_debug("%s Opening %d-ch PCM read stream\n",
 +			__func__, params_channels(params));
 +		ret = q6asm_open_read_v2(prtd->audio_client, FORMAT_LINEAR_PCM,
 +				bits_per_sample);
 +		if (ret < 0) {
 +			pr_err("%s: q6asm_open_read failed\n", __func__);
 +			q6asm_audio_client_free(prtd->audio_client);
 +			prtd->audio_client = NULL;
 +			return -ENOMEM;
 +		}
 +
 +		pr_debug("%s: session ID %d\n",
 +				__func__, prtd->audio_client->session);
 +		prtd->session_id = prtd->audio_client->session;
 +		msm_pcm_routing_reg_phy_stream(soc_prtd->dai_link->be_id,
 +				prtd->audio_client->perf_mode,
 +				prtd->session_id, substream->stream);
 +	}
 +
++=======
++>>>>>>> FETCH_HEAD
  	ret = q6asm_audio_client_buf_alloc_contiguous(dir,
  			prtd->audio_client,
  			(params_buffer_bytes(params) / params_periods(params)),
@@@ -781,6 -877,94 +1031,97 @@@ static struct snd_pcm_ops msm_pcm_ops 
  	.mmap		= msm_pcm_mmap,
  };
  
++<<<<<<< HEAD
++=======
+ static int msm_pcm_set_volume(struct msm_audio *prtd, uint32_t volume)
+ {
+ 	int rc = 0;
+ 
+ 	if (prtd && prtd->audio_client) {
+ 		pr_debug("%s: channels %d volume 0x%x\n", __func__,
+ 				prtd->channel_mode, volume);
+ 		rc = q6asm_set_volume(prtd->audio_client, volume);
+ 		if (rc < 0) {
+ 			pr_err("%s: Send Volume command failed rc=%d\n",
+ 					__func__, rc);
+ 		}
+ 	}
+ 	return rc;
+ }
+ 
+ static int msm_pcm_volume_ctl_get(struct snd_kcontrol *kcontrol,
+ 		      struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_pcm_volume *vol = snd_kcontrol_chip(kcontrol);
+ 	struct snd_pcm_substream *substream =
+ 		vol->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+ 	struct msm_audio *prtd;
+ 
+ 	pr_debug("%s\n", __func__);
+ 	if (!substream) {
+ 		pr_err("%s substream not found\n", __func__);
+ 		return -ENODEV;
+ 	}
+ 	if (!substream->runtime) {
+ 		pr_err("%s substream runtime not found\n", __func__);
+ 		return 0;
+ 	}
+ 	prtd = substream->runtime->private_data;
+ 	if (prtd)
+ 		ucontrol->value.integer.value[0] = prtd->volume;
+ 	return 0;
+ }
+ 
+ static int msm_pcm_volume_ctl_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	int rc = 0;
+ 	struct snd_pcm_volume *vol = snd_kcontrol_chip(kcontrol);
+ 	struct snd_pcm_substream *substream =
+ 		vol->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+ 	struct msm_audio *prtd;
+ 	int volume = ucontrol->value.integer.value[0];
+ 
+ 	pr_debug("%s: volume : 0x%x\n", __func__, volume);
+ 	if (!substream) {
+ 		pr_err("%s substream not found\n", __func__);
+ 		return -ENODEV;
+ 	}
+ 	if (!substream->runtime) {
+ 		pr_err("%s substream runtime not found\n", __func__);
+ 		return 0;
+ 	}
+ 	prtd = substream->runtime->private_data;
+ 	if (prtd) {
+ 		rc = msm_pcm_set_volume(prtd, volume);
+ 		prtd->volume = volume;
+ 	}
+ 	return rc;
+ }
+ 
+ static int msm_pcm_add_volume_control(struct snd_soc_pcm_runtime *rtd)
+ {
+ 	int ret = 0;
+ 	struct snd_pcm *pcm = rtd->pcm;
+ 	struct snd_pcm_volume *volume_info;
+ 	struct snd_kcontrol *kctl;
+ 
+ 	dev_dbg(rtd->dev, "%s, Volume control add\n", __func__);
+ 	ret = snd_pcm_add_volume_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+ 			NULL, 1, rtd->dai_link->be_id,
+ 			&volume_info);
+ 	if (ret < 0) {
+ 		pr_err("%s volume control failed ret %d\n", __func__, ret);
+ 		return ret;
+ 	}
+ 	kctl = volume_info->kctl;
+ 	kctl->put = msm_pcm_volume_ctl_put;
+ 	kctl->get = msm_pcm_volume_ctl_get;
+ 	kctl->tlv.p = msm_pcm_vol_gain;
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int msm_pcm_chmap_ctl_put(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_value *ucontrol)
  {
@@@ -867,6 -1051,10 +1208,13 @@@ static int msm_asoc_pcm_new(struct snd_
  		__func__, kctl->id.name);
  	kctl->put = msm_pcm_chmap_ctl_put;
  	kctl->get = msm_pcm_chmap_ctl_get;
++<<<<<<< HEAD
++=======
+ 	ret = msm_pcm_add_volume_control(rtd);
+ 	if (ret)
+ 		pr_err("%s: Could not add pcm Volume Control %d\n",
+ 			__func__, ret);
++>>>>>>> FETCH_HEAD
  	return ret;
  }
  
@@@ -880,6 -1068,7 +1228,10 @@@ static __devinit int msm_pcm_probe(stru
  	int rc;
  	int id;
  	struct msm_plat_data *pdata;
++<<<<<<< HEAD
++=======
+ 	const char *latency_level;
++>>>>>>> FETCH_HEAD
  
  	rc = of_property_read_u32(pdev->dev.of_node,
  				"qcom,msm-pcm-dsp-id", &id);
@@@ -896,10 -1085,17 +1248,24 @@@
  	}
  
  	if (of_property_read_bool(pdev->dev.of_node,
++<<<<<<< HEAD
 +				"qcom,msm-pcm-low-latency"))
 +		pdata->perf_mode = 1;
 +	else
 +		pdata->perf_mode = 0;
++=======
+ 				"qcom,msm-pcm-low-latency")) {
+ 
+ 		pdata->perf_mode = LOW_LATENCY_PCM_MODE;
+ 		rc = of_property_read_string(pdev->dev.of_node,
+ 			"qcom,latency-level", &latency_level);
+ 		if (!rc) {
+ 			if (!strcmp(latency_level, "ultra"))
+ 				pdata->perf_mode = ULTRA_LOW_LATENCY_PCM_MODE;
+ 		}
+ 	} else
+ 		pdata->perf_mode = LEGACY_PCM_MODE;
++>>>>>>> FETCH_HEAD
  
  	dev_set_drvdata(&pdev->dev, pdata);
  
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h
index 5d5c995,803a412..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h
@@@ -1,7 -1,7 +1,11 @@@
  /*
   * Copyright (C) 2008 Google, Inc.
   * Copyright (C) 2008 HTC Corporation
++<<<<<<< HEAD
 + * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
++=======
+  * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This software is licensed under the terms of the GNU General Public
   * License version 2, as published by the Free Software Foundation, and
@@@ -69,6 -69,7 +73,10 @@@ struct msm_audio 
  
  	int abort; /* set when error, like sample rate mismatch */
  
++<<<<<<< HEAD
++=======
+ 	bool reset_event;
++>>>>>>> FETCH_HEAD
  	int enabled;
  	int close_ack;
  	int cmd_ack;
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
index 94c9bc0,21316e7..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -55,10 -55,21 +59,27 @@@ struct msm_pcm_routing_bdai_data 
  	unsigned int  format;
  };
  
++<<<<<<< HEAD
++=======
+ struct msm_pcm_routing_fdai_data {
+ 	u16 be_srate; /* track prior backend sample rate for flushing purpose */
+ 	int strm_id; /* ASM stream ID */
+ 	struct msm_pcm_routing_evt event_info;
+ };
+ 
++>>>>>>> FETCH_HEAD
  #define INVALID_SESSION -1
  #define SESSION_TYPE_RX 0
  #define SESSION_TYPE_TX 1
  
++<<<<<<< HEAD
++=======
+ #define EC_PORT_ID_PRIMARY_MI2S_TX    1
+ #define EC_PORT_ID_SECONDARY_MI2S_TX  2
+ #define EC_PORT_ID_TERTIARY_MI2S_TX   3
+ #define EC_PORT_ID_QUATERNARY_MI2S_TX 4
+ 
++>>>>>>> FETCH_HEAD
  static struct mutex routing_lock;
  
  static int fm_switch_enable;
@@@ -66,8 -77,9 +87,14 @@@ static int fm_pcmrx_switch_enable
  static int srs_alsa_ctrl_ever_called;
  static int lsm_mux_slim_port;
  static int slim0_rx_aanc_fb_port;
++<<<<<<< HEAD
 +static int msm_route_ec_ref_rx = 3; /* NONE */
 +static uint32_t voc_session_id = ALL_SESSION_VSID;
++=======
+ static int msm_route_ec_ref_rx = 7; /* NONE */
+ static uint32_t voc_session_id = ALL_SESSION_VSID;
+ static int msm_route_ext_ec_ref = AFE_PORT_INVALID;
++>>>>>>> FETCH_HEAD
  
  enum {
  	MADNONE,
@@@ -288,35 -300,46 +315,75 @@@ static struct msm_pcm_routing_bdai_dat
  
  
  /* Track ASM playback & capture sessions of DAI */
++<<<<<<< HEAD
 +static int fe_dai_map[MSM_FRONTEND_DAI_MM_SIZE][2] = {
 +	/* MULTIMEDIA1 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA2 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA3 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA4 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA5 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA6 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA7 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA8 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +	/* MULTIMEDIA9 */
 +	{INVALID_SESSION, INVALID_SESSION},
 +#ifdef CONFIG_JACK_AUDIO	
 +	/* MULTIMEDIA10 */
 +	{INVALID_SESSION, INVALID_SESSION},	
++=======
+ static struct msm_pcm_routing_fdai_data
+ 	fe_dai_map[MSM_FRONTEND_DAI_MM_SIZE][2] = {
+ 	/* MULTIMEDIA1 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA2 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA3 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA4 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION,  {NULL, NULL} } },
+ 	/* MULTIMEDIA5 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA6 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA7*/
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA8 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ 	/* MULTIMEDIA9 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
+ #ifdef CONFIG_JACK_AUDIO	
+ 	/* MULTIMEDIA10 */
+ 	{{0, INVALID_SESSION, {NULL, NULL} },
+ 	{0, INVALID_SESSION, {NULL, NULL} } },
++>>>>>>> FETCH_HEAD
  #endif	
  };
  
  /* Track performance mode of all front-end multimedia sessions.
   * Performance mode is only valid when session is valid.
   */
++<<<<<<< HEAD
 +static bool fe_dai_perf_mode[MSM_FRONTEND_DAI_MM_SIZE][2];
++=======
+ static int fe_dai_perf_mode[MSM_FRONTEND_DAI_MM_SIZE][2];
++>>>>>>> FETCH_HEAD
  
  static uint8_t is_be_dai_extproc(int be_dai)
  {
@@@ -329,7 -352,7 +396,11 @@@
  }
  
  static void msm_pcm_routing_build_matrix(int fedai_id, int dspst_id,
++<<<<<<< HEAD
 +	int path_type, bool perf_mode)
++=======
+ 	int path_type, int perf_mode)
++>>>>>>> FETCH_HEAD
  {
  	int i, port_type;
  	struct route_payload payload;
@@@ -376,7 -399,7 +447,11 @@@ void msm_pcm_routing_reg_psthr_stream(i
  
  	mutex_lock(&routing_lock);
  
++<<<<<<< HEAD
 +	fe_dai_map[fedai_id][session_type] = dspst_id;
++=======
+ 	fe_dai_map[fedai_id][session_type].strm_id = dspst_id;
++>>>>>>> FETCH_HEAD
  	for (i = 0; i < MSM_BACKEND_DAI_MAX; i++) {
  		if (!is_be_dai_extproc(i) &&
  		    (afe_get_port_type(msm_bedais[i].port_id) == port_type) &&
@@@ -391,7 -414,7 +466,11 @@@
  	mutex_unlock(&routing_lock);
  }
  
++<<<<<<< HEAD
 +void msm_pcm_routing_reg_phy_stream(int fedai_id, bool perf_mode,
++=======
+ void msm_pcm_routing_reg_phy_stream(int fedai_id, int perf_mode,
++>>>>>>> FETCH_HEAD
  					int dspst_id, int stream_type)
  {
  	int i, session_type, path_type, port_type, port_id, topology;
@@@ -418,7 -441,7 +497,11 @@@
  	mutex_lock(&routing_lock);
  
  	payload.num_copps = 0; /* only RX needs to use payload */
++<<<<<<< HEAD
 +	fe_dai_map[fedai_id][session_type] = dspst_id;
++=======
+ 	fe_dai_map[fedai_id][session_type].strm_id = dspst_id;
++>>>>>>> FETCH_HEAD
  	fe_dai_perf_mode[fedai_id][session_type] = perf_mode;
  
  	/* re-enable EQ if active */
@@@ -455,7 -478,7 +538,11 @@@
  				path_type,
  				msm_bedais[i].sample_rate,
  				msm_bedais[i].channel,
++<<<<<<< HEAD
 +				topology, false,
++=======
+ 				topology, perf_mode,
++>>>>>>> FETCH_HEAD
  				bits_per_sample);
  
  			payload.copp_ids[payload.num_copps++] =
@@@ -463,7 -486,7 +550,11 @@@
  			port_id = srs_port_id = msm_bedais[i].port_id;
  			srs_send_params(srs_port_id, 1, 0);
  			if ((DOLBY_ADM_COPP_TOPOLOGY_ID == topology) &&
++<<<<<<< HEAD
 +			    (!perf_mode))
++=======
+ 			    (perf_mode == LEGACY_PCM_MODE))
++>>>>>>> FETCH_HEAD
  				if (dolby_dap_init(port_id,
  						msm_bedais[i].channel) < 0)
  					pr_err("%s: Err init dolby dap\n",
@@@ -477,6 -500,19 +568,22 @@@
  	mutex_unlock(&routing_lock);
  }
  
++<<<<<<< HEAD
++=======
+ void msm_pcm_routing_reg_phy_stream_v2(int fedai_id, bool perf_mode,
+ 				       int dspst_id, int stream_type,
+ 				       struct msm_pcm_routing_evt event_info)
+ {
+ 	msm_pcm_routing_reg_phy_stream(fedai_id, perf_mode, dspst_id,
+ 				       stream_type);
+ 
+ 	if (stream_type == SNDRV_PCM_STREAM_PLAYBACK)
+ 		fe_dai_map[fedai_id][SESSION_TYPE_RX].event_info = event_info;
+ 	else
+ 		fe_dai_map[fedai_id][SESSION_TYPE_TX].event_info = event_info;
+ }
+ 
++>>>>>>> FETCH_HEAD
  void msm_pcm_routing_dereg_phy_stream(int fedai_id, int stream_type)
  {
  	int i, port_type, session_type, path_type, topology;
@@@ -507,13 -543,14 +614,23 @@@
  			adm_close(msm_bedais[i].port_id,
  				  fe_dai_perf_mode[fedai_id][session_type]);
  			if ((DOLBY_ADM_COPP_TOPOLOGY_ID == topology) &&
++<<<<<<< HEAD
 +			    (fe_dai_perf_mode[fedai_id][session_type] == false))
++=======
+ 			    (fe_dai_perf_mode[fedai_id][session_type] ==
+ 							LEGACY_PCM_MODE))
++>>>>>>> FETCH_HEAD
  				dolby_dap_deinit(msm_bedais[i].port_id);
  		}
  	}
  
++<<<<<<< HEAD
 +	fe_dai_map[fedai_id][session_type] = INVALID_SESSION;
 +
++=======
+ 	fe_dai_map[fedai_id][session_type].strm_id = INVALID_SESSION;
+ 	fe_dai_map[fedai_id][session_type].be_srate = 0;
++>>>>>>> FETCH_HEAD
  	mutex_unlock(&routing_lock);
  }
  
@@@ -539,6 -576,7 +656,10 @@@ static void msm_pcm_routing_process_aud
  	int session_type, path_type, port_id, topology;
  	u32 channels;
  	uint16_t bits_per_sample = 16;
++<<<<<<< HEAD
++=======
+ 	struct msm_pcm_routing_fdai_data *fdai;
++>>>>>>> FETCH_HEAD
  
  	pr_debug("%s: reg %x val %x set %x\n", __func__, reg, val, set);
  
@@@ -565,10 -603,23 +686,30 @@@
  			(msm_bedais[reg].port_id == VOICE2_PLAYBACK_TX)))
  			voc_start_playback(set, msm_bedais[reg].port_id);
  		set_bit(val, &msm_bedais[reg].fe_sessions);
++<<<<<<< HEAD
 +		if (msm_bedais[reg].active && fe_dai_map[val][session_type] !=
 +			INVALID_SESSION) {
 +
 +			channels = msm_bedais[reg].channel;
++=======
+ 		fdai = &fe_dai_map[val][session_type];
+ 		if (msm_bedais[reg].active && fdai->strm_id !=
+ 			INVALID_SESSION) {
+ 
+ 			channels = msm_bedais[reg].channel;
+ 			if (session_type == SESSION_TYPE_TX &&
+ 			    fdai->be_srate &&
+ 			    (fdai->be_srate != msm_bedais[reg].sample_rate)) {
+ 				pr_debug("%s: flush strm %d diff BE rates\n",
+ 					__func__, fdai->strm_id);
+ 
+ 				if (fdai->event_info.event_func)
+ 					fdai->event_info.event_func(
+ 						MSM_PCM_RT_EVT_BUF_RECFG,
+ 						fdai->event_info.priv_data);
+ 				fdai->be_srate = 0; /* might not need it */
+ 			}
++>>>>>>> FETCH_HEAD
  			if (msm_bedais[reg].format == SNDRV_PCM_FORMAT_S24_LE)
  				bits_per_sample = 24;
  
@@@ -591,13 -642,20 +732,29 @@@
  				msm_bedais[reg].sample_rate, channels,
  				topology, false, bits_per_sample);
  
++<<<<<<< HEAD
 +			msm_pcm_routing_build_matrix(val,
 +				fe_dai_map[val][session_type], path_type,
++=======
+ 			if (session_type == SESSION_TYPE_RX &&
+ 			    fdai->event_info.event_func)
+ 				fdai->event_info.event_func(
+ 					MSM_PCM_RT_EVT_DEVSWITCH,
+ 					fdai->event_info.priv_data);
+ 
+ 			msm_pcm_routing_build_matrix(val,
+ 				fdai->strm_id, path_type,
++>>>>>>> FETCH_HEAD
  				fe_dai_perf_mode[val][session_type]);
  			port_id = srs_port_id = msm_bedais[reg].port_id;
  			srs_send_params(srs_port_id, 1, 0);
  			if ((DOLBY_ADM_COPP_TOPOLOGY_ID == topology) &&
++<<<<<<< HEAD
 +			    (fe_dai_perf_mode[val][session_type] == false))
++=======
+ 			    (fe_dai_perf_mode[val][session_type] ==
+ 							LEGACY_PCM_MODE))
++>>>>>>> FETCH_HEAD
  				if (dolby_dap_init(port_id, channels) < 0)
  					pr_err("%s: Err init dolby dap\n",
  						__func__);
@@@ -608,15 -666,17 +765,28 @@@
  			(msm_bedais[reg].port_id == VOICE2_PLAYBACK_TX)))
  			voc_start_playback(set, msm_bedais[reg].port_id);
  		clear_bit(val, &msm_bedais[reg].fe_sessions);
++<<<<<<< HEAD
 +		if (msm_bedais[reg].active && fe_dai_map[val][session_type] !=
++=======
+ 		fdai = &fe_dai_map[val][session_type];
+ 		if (msm_bedais[reg].active && fdai->strm_id !=
++>>>>>>> FETCH_HEAD
  			INVALID_SESSION) {
  			adm_close(msm_bedais[reg].port_id,
  				  fe_dai_perf_mode[val][session_type]);
  			if ((DOLBY_ADM_COPP_TOPOLOGY_ID == topology) &&
++<<<<<<< HEAD
 +			    (fe_dai_perf_mode[val][session_type] == false))
 +				dolby_dap_deinit(msm_bedais[reg].port_id);
 +			msm_pcm_routing_build_matrix(val,
 +				fe_dai_map[val][session_type], path_type,
++=======
+ 			    (fe_dai_perf_mode[val][session_type] ==
+ 							LEGACY_PCM_MODE))
+ 				dolby_dap_deinit(msm_bedais[reg].port_id);
+ 			msm_pcm_routing_build_matrix(val,
+ 				fdai->strm_id, path_type,
++>>>>>>> FETCH_HEAD
  				fe_dai_perf_mode[val][session_type]);
  		}
  	}
@@@ -1245,12 -1305,12 +1415,21 @@@ static int msm_routing_set_srs_trumedia
  static void msm_send_eq_values(int eq_idx)
  {
  	int result;
++<<<<<<< HEAD
 +	struct audio_client *ac =
 +		q6asm_get_audio_client(fe_dai_map[eq_idx][SESSION_TYPE_RX]);
 +
 +	if (ac == NULL) {
 +		pr_err("%s: Could not get audio client for session: %d\n",
 +		      __func__, fe_dai_map[eq_idx][SESSION_TYPE_RX]);
++=======
+ 	struct audio_client *ac = q6asm_get_audio_client(
+ 				  fe_dai_map[eq_idx][SESSION_TYPE_RX].strm_id);
+ 
+ 	if (ac == NULL) {
+ 		pr_err("%s: Could not get audio client for session: %d\n",
+ 		      __func__, fe_dai_map[eq_idx][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  		goto done;
  	}
  
@@@ -1395,7 -1455,7 +1574,11 @@@ static int msm_sec_sa_ep_get(struct snd
  {
  	struct audio_client *ac;
  	mutex_lock(&routing_lock);
++<<<<<<< HEAD
 +	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX]);
++=======
+ 	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  	pr_info("%s: sa_ep  ret=%d score=%d", __func__, q6asm_get_sa_ep(ac), score);
  	ucontrol->value.integer.value[0] = score;
  	mutex_unlock(&routing_lock);
@@@ -1414,7 -1474,7 +1597,11 @@@ static int msm_sec_sa_put(struct snd_kc
  	int ret = 0;
  	struct audio_client *ac;
  	mutex_lock(&routing_lock);
++<<<<<<< HEAD
 +	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX]);
++=======
+ 	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  	ret = q6asm_set_sa(ac,(int*)ucontrol->value.integer.value);
  	mutex_unlock(&routing_lock);	
  	return ret;
@@@ -1426,7 -1486,7 +1613,11 @@@ static int msm_sec_vsp_put(struct snd_k
  	int ret = 0;
  	struct audio_client *ac;
  	mutex_lock(&routing_lock);
++<<<<<<< HEAD
 +	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX]);
++=======
+ 	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  	ret = q6asm_set_vsp(ac,(int*)ucontrol->value.integer.value);
  	mutex_unlock(&routing_lock);	
  	return ret;
@@@ -1439,7 -1499,7 +1630,11 @@@ static int msm_sec_dha_put(struct snd_k
  	int ret = 0;
  	struct audio_client *ac;
  	mutex_lock(&routing_lock);
++<<<<<<< HEAD
 +	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX]);
++=======
+ 	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  	ret = q6asm_set_dha(ac,(int*)ucontrol->value.integer.value);
  	mutex_unlock(&routing_lock);	
  	return ret;		
@@@ -1451,7 -1511,7 +1646,11 @@@ static int msm_sec_lrsm_put(struct snd_
  	int ret = 0;
  	struct audio_client *ac;
  	mutex_lock(&routing_lock);
++<<<<<<< HEAD
 +	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX]);
++=======
+ 	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  	ret = q6asm_set_lrsm(ac,(int*)ucontrol->value.integer.value);
  	mutex_unlock(&routing_lock);	
  	return ret;		
@@@ -1463,7 -1523,7 +1662,11 @@@ static int msm_sec_sa_ep_put(struct snd
  	int ret = 0;
  	struct audio_client *ac;
  	mutex_lock(&routing_lock);
++<<<<<<< HEAD
 +	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX]);
++=======
+ 	ac = q6asm_get_audio_client(fe_dai_map[3][SESSION_TYPE_RX].strm_id);
++>>>>>>> FETCH_HEAD
  	ret = q6asm_set_sa_ep(ac,(int*)ucontrol->value.integer.value);
  	mutex_unlock(&routing_lock);	
  	return ret;	
@@@ -1481,39 -1541,168 +1684,200 @@@ static int msm_routing_ec_ref_rx_put(st
  				struct snd_ctl_elem_value *ucontrol)
  {
  	int ec_ref_port_id;
++<<<<<<< HEAD
++=======
+ 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+ 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+ 	int mux = ucontrol->value.enumerated.item[0];
+ 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+ 
++>>>>>>> FETCH_HEAD
  	mutex_lock(&routing_lock);
  	switch (ucontrol->value.integer.value[0]) {
  	case 0:
  		msm_route_ec_ref_rx = 0;
++<<<<<<< HEAD
 +		ec_ref_port_id = SLIMBUS_0_RX;
 +		break;
 +	case 1:
 +		msm_route_ec_ref_rx = 1;
 +		ec_ref_port_id = AFE_PORT_ID_PRIMARY_MI2S_RX;
 +		break;
 +	default:
 +		msm_route_ec_ref_rx = 3; /* NONE */
 +		ec_ref_port_id = -1;
++=======
+ 		ec_ref_port_id = AFE_PORT_INVALID;
+ 		break;
+ 	case 1:
+ 		msm_route_ec_ref_rx = 1;
+ 		ec_ref_port_id = SLIMBUS_0_RX;
+ 		break;
+ 	case 2:
+ 		msm_route_ec_ref_rx = 2;
+ 		ec_ref_port_id = AFE_PORT_ID_PRIMARY_MI2S_RX;
+ 		break;
+ 	case 3:
+ 		msm_route_ec_ref_rx = 3;
+ 		ec_ref_port_id = AFE_PORT_ID_PRIMARY_MI2S_TX;
+ 		break;
+ 	case 4:
+ 		msm_route_ec_ref_rx = 4;
+ 		ec_ref_port_id = AFE_PORT_ID_SECONDARY_MI2S_TX;
+ 		break;
+ 	case 5:
+ 		msm_route_ec_ref_rx = 5;
+ 		ec_ref_port_id = AFE_PORT_ID_TERTIARY_MI2S_TX;
+ 		break;
+ 	case 6:
+ 		msm_route_ec_ref_rx = 6;
+ 		ec_ref_port_id = AFE_PORT_ID_QUATERNARY_MI2S_TX;
+ 		break;
+ 	default:
+ 		msm_route_ec_ref_rx = 0; /* NONE */
+ 		pr_err("%s EC ref rx %ld not valid\n",
+ 			__func__, ucontrol->value.integer.value[0]);
+ 		ec_ref_port_id = AFE_PORT_INVALID;
++>>>>>>> FETCH_HEAD
  		break;
  	}
  	adm_ec_ref_rx_id(ec_ref_port_id);
  	pr_debug("%s: msm_route_ec_ref_rx = %d\n",
  	    __func__, msm_route_ec_ref_rx);
  	mutex_unlock(&routing_lock);
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +static const char *const ec_ref_rx[] = { "SLIM_RX", "I2S_RX", "PROXY_RX",
 +	"NONE" };
 +static const struct soc_enum msm_route_ec_ref_rx_enum[] = {
 +	SOC_ENUM_SINGLE_EXT(4, ec_ref_rx),
 +};
 +
 +static const struct snd_kcontrol_new ec_ref_rx_mixer_controls[] = {
 +	SOC_ENUM_EXT("EC_REF_RX", msm_route_ec_ref_rx_enum[0],
 +		     msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put),
 +};
 +
++=======
+ 	snd_soc_dapm_mux_update_power(widget, kcontrol, 1, mux, e);
+ 	return 0;
+ }
+ 
+ static const char *const ec_ref_rx[] = { "None", "SLIM_RX", "I2S_RX",
+ 	"PRI_MI2S_TX",
+ 	"SEC_MI2S_TX", "TERT_MI2S_TX", "QUAT_MI2S_TX", "PROXY_RX"};
+ static const struct soc_enum msm_route_ec_ref_rx_enum[] = {
+ 	SOC_ENUM_SINGLE_EXT(8, ec_ref_rx),
+ };
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul1 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL1 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul2 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL2 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul4 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL4 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul5 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL5 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul6 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL6 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul8 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL8 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static const struct snd_kcontrol_new ext_ec_ref_mux_ul9 =
+ 	SOC_DAPM_ENUM_EXT("AUDIO_REF_EC_UL9 MUX Mux",
+ 		msm_route_ec_ref_rx_enum[0],
+ 		msm_routing_ec_ref_rx_get, msm_routing_ec_ref_rx_put);
+ 
+ static int msm_routing_ext_ec_get(struct snd_kcontrol *kcontrol,
+ 				  struct snd_ctl_elem_value *ucontrol)
+ {
+ 	pr_debug("%s: ext_ec_ref_rx  = %x\n", __func__, msm_route_ext_ec_ref);
+ 
+ 	mutex_lock(&routing_lock);
+ 	ucontrol->value.integer.value[0] = msm_route_ext_ec_ref;
+ 	mutex_unlock(&routing_lock);
+ 	return 0;
+ }
+ 
+ static int msm_routing_ext_ec_put(struct snd_kcontrol *kcontrol,
+ 				  struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+ 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+ 	int mux = ucontrol->value.enumerated.item[0];
+ 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+ 	int ret = 0;
+ 	bool state = false;
+ 
+ 	pr_debug("%s: msm_route_ec_ref_rx = %d value = %ld\n",
+ 		 __func__, msm_route_ext_ec_ref,
+ 		 ucontrol->value.integer.value[0]);
+ 
+ 	mutex_lock(&routing_lock);
+ 	switch (ucontrol->value.integer.value[0]) {
+ 	case EC_PORT_ID_PRIMARY_MI2S_TX:
+ 		msm_route_ext_ec_ref = AFE_PORT_ID_PRIMARY_MI2S_TX;
+ 		state = true;
+ 		break;
+ 	case EC_PORT_ID_SECONDARY_MI2S_TX:
+ 		msm_route_ext_ec_ref = AFE_PORT_ID_SECONDARY_MI2S_TX;
+ 		state = true;
+ 		break;
+ 	case EC_PORT_ID_TERTIARY_MI2S_TX:
+ 		msm_route_ext_ec_ref = AFE_PORT_ID_TERTIARY_MI2S_TX;
+ 		state = true;
+ 		break;
+ 	case EC_PORT_ID_QUATERNARY_MI2S_TX:
+ 		msm_route_ext_ec_ref = AFE_PORT_ID_QUATERNARY_MI2S_TX;
+ 		state = true;
+ 		break;
+ 	default:
+ 		msm_route_ext_ec_ref = AFE_PORT_INVALID;
+ 		break;
+ 	}
+ 	if (!voc_set_ext_ec_ref(msm_route_ext_ec_ref, state)) {
+ 		mutex_unlock(&routing_lock);
+ 		snd_soc_dapm_mux_update_power(widget, kcontrol, 1, mux, e);
+ 	} else {
+ 		ret = -EINVAL;
+ 		mutex_unlock(&routing_lock);
+ 	}
+ 	return ret;
+ }
+ 
+ static const char * const ext_ec_ref_rx[] = {"NONE", "PRI_MI2S_TX",
+ 					     "SEC_MI2S_TX", "TERT_MI2S_TX",
+ 					     "QUAT_MI2S_TX"};
+ 
+ static const struct soc_enum msm_route_ext_ec_ref_rx_enum[] = {
+ 	SOC_ENUM_SINGLE_EXT(5, ext_ec_ref_rx),
+ };
+ 
+ static const struct snd_kcontrol_new voc_ext_ec_mux =
+ 	SOC_DAPM_ENUM_EXT("VOC_EXT_EC MUX Mux", msm_route_ext_ec_ref_rx_enum[0],
+ 			  msm_routing_ext_ec_get, msm_routing_ext_ec_put);
+ 
+ 
++>>>>>>> FETCH_HEAD
  static const struct snd_kcontrol_new pri_i2s_rx_mixer_controls[] = {
  	SOC_SINGLE_EXT("MultiMedia1", MSM_BACKEND_DAI_PRI_I2S_RX ,
  	MSM_FRONTEND_DAI_MULTIMEDIA1, 1, 0, msm_routing_get_audio_mixer,
@@@ -2124,6 -2313,15 +2488,18 @@@ static const struct snd_kcontrol_new mm
  };
  
  
++<<<<<<< HEAD
++=======
+ static const struct snd_kcontrol_new mmul6_mixer_controls[] = {
+ 	SOC_SINGLE_EXT("INTERNAL_FM_TX", MSM_BACKEND_DAI_INT_FM_TX,
+ 	MSM_FRONTEND_DAI_MULTIMEDIA6, 1, 0, msm_routing_get_audio_mixer,
+ 	msm_routing_put_audio_mixer),
+ 	SOC_SINGLE_EXT("SLIM_0_TX", MSM_BACKEND_DAI_SLIMBUS_0_TX,
+ 	MSM_FRONTEND_DAI_MULTIMEDIA6, 1, 0, msm_routing_get_audio_mixer,
+ 	msm_routing_put_audio_mixer),
+ };
+ 
++>>>>>>> FETCH_HEAD
  static const struct snd_kcontrol_new pri_rx_voice_mixer_controls[] = {
  	SOC_SINGLE_EXT("CSVoice", MSM_BACKEND_DAI_PRI_I2S_RX,
  	MSM_FRONTEND_DAI_CS_VOICE, 1, 0, msm_routing_get_voice_mixer,
@@@ -2824,6 -3022,7 +3200,10 @@@ static const struct snd_kcontrol_new do
  int msm_routing_get_rms_value_control(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_value *ucontrol) {
  	int rc = 0;
++<<<<<<< HEAD
++=======
+ 	int be_idx = 0;
++>>>>>>> FETCH_HEAD
  	char *param_value;
  	int *update_param_value;
  	uint32_t param_length = sizeof(uint32_t);
@@@ -2833,21 -3032,26 +3213,44 @@@
  		pr_err("%s, param memory alloc failed\n", __func__);
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
 +	rc = adm_get_params(SLIMBUS_0_TX,
 +			RMS_MODULEID_APPI_PASSTHRU,
 +			RMS_PARAM_FIRST_SAMPLE,
 +			param_length + param_payload_len,
 +			param_value);
 +	if (rc) {
 +		pr_err("%s: get parameters failed\n", __func__);
 +		kfree(param_value);
 +		return -EINVAL;
 +	}
 +	update_param_value = (int *)param_value;
 +	ucontrol->value.integer.value[0] = update_param_value[0];
 +
 +	pr_debug("%s: FROM DSP value[0] 0x%x\n",
 +		__func__, update_param_value[0]);
++=======
+ 	for (be_idx = 0; be_idx < MSM_BACKEND_DAI_MAX; be_idx++)
+ 		if (msm_bedais[be_idx].port_id == SLIMBUS_0_TX)
+ 			break;
+ 	if ((be_idx < MSM_BACKEND_DAI_MAX) && msm_bedais[be_idx].active) {
+ 		rc = adm_get_params(SLIMBUS_0_TX,
+ 				RMS_MODULEID_APPI_PASSTHRU,
+ 				RMS_PARAM_FIRST_SAMPLE,
+ 				param_length + param_payload_len,
+ 				param_value);
+ 		if (rc) {
+ 			pr_err("%s: get parameters failed\n", __func__);
+ 			kfree(param_value);
+ 			return -EINVAL;
+ 		}
+ 		update_param_value = (int *)param_value;
+ 		ucontrol->value.integer.value[0] = update_param_value[0];
+ 
+ 		pr_debug("%s: FROM DSP value[0] 0x%x\n",
+ 			  __func__, update_param_value[0]);
+ 	}
++>>>>>>> FETCH_HEAD
  	kfree(param_value);
  	return 0;
  }
@@@ -3158,6 -3362,7 +3561,10 @@@ static const struct snd_soc_dapm_widge
  	SND_SOC_DAPM_AIF_OUT("MM_UL4", "MultiMedia4 Capture", 0, 0, 0, 0),
  	SND_SOC_DAPM_AIF_OUT("MM_UL5", "MultiMedia5 Capture", 0, 0, 0, 0),
  	SND_SOC_DAPM_AIF_OUT("MM_UL8", "MultiMedia8 Capture", 0, 0, 0, 0),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_AIF_OUT("MM_UL6", "MultiMedia6 Capture", 0, 0, 0, 0),
++>>>>>>> FETCH_HEAD
  	SND_SOC_DAPM_AIF_OUT("MM_UL9", "MultiMedia9 Capture", 0, 0, 0, 0),
  #ifdef CONFIG_JACK_AUDIO	
  	SND_SOC_DAPM_AIF_OUT("MM_UL10", "MultiMedia10 Capture", 0, 0, 0, 0),
@@@ -3189,6 -3394,10 +3596,13 @@@
  		0, 0, 0, 0),
  	SND_SOC_DAPM_AIF_OUT("INTFM_UL_HL", "INT_FM_HOSTLESS Capture",
  		0, 0, 0, 0),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_AIF_IN("INTHFP_DL_HL", "INT_HFP_BT_HOSTLESS Playback",
+ 		0, 0, 0, 0),
+ 	SND_SOC_DAPM_AIF_OUT("INTHFP_UL_HL", "INT_HFP_BT_HOSTLESS Capture",
+ 		0, 0, 0, 0),
++>>>>>>> FETCH_HEAD
  	SND_SOC_DAPM_AIF_IN("HDMI_DL_HL", "HDMI_HOSTLESS Playback", 0, 0, 0, 0),
  	SND_SOC_DAPM_AIF_IN("SEC_I2S_DL_HL", "SEC_I2S_RX_HOSTLESS Playback",
  		0, 0, 0, 0),
@@@ -3337,6 -3546,8 +3751,11 @@@
  	mmul4_mixer_controls, ARRAY_SIZE(mmul4_mixer_controls)),
  	SND_SOC_DAPM_MIXER("MultiMedia5 Mixer", SND_SOC_NOPM, 0, 0,
  	mmul5_mixer_controls, ARRAY_SIZE(mmul5_mixer_controls)),
++<<<<<<< HEAD
++=======
+ 	SND_SOC_DAPM_MIXER("MultiMedia6 Mixer", SND_SOC_NOPM, 0, 0,
+ 	mmul6_mixer_controls, ARRAY_SIZE(mmul6_mixer_controls)),
++>>>>>>> FETCH_HEAD
  	SND_SOC_DAPM_MIXER("MultiMedia8 Mixer", SND_SOC_NOPM, 0, 0,
  	mmul8_mixer_controls, ARRAY_SIZE(mmul8_mixer_controls)),
  #ifdef CONFIG_JACK_AUDIO	
@@@ -3464,7 -3675,22 +3883,26 @@@
  
  	SND_SOC_DAPM_MUX("SLIM0_RX_VI_FB_LCH_MUX", SND_SOC_NOPM, 0, 0,
  				&slim0_rx_vi_fb_lch_mux),
- 
++<<<<<<< HEAD
++
++=======
+ 	SND_SOC_DAPM_MUX("VOC_EXT_EC MUX", SND_SOC_NOPM, 0, 0,
+ 			 &voc_ext_ec_mux),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL1 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul1),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL2 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul2),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL4 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul4),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL5 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul5),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL6 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul6),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL8 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul8),
+ 	SND_SOC_DAPM_MUX("AUDIO_REF_EC_UL9 MUX", SND_SOC_NOPM, 0, 0,
+ 		&ext_ec_ref_mux_ul9),
++>>>>>>> FETCH_HEAD
  };
  
  static const struct snd_soc_dapm_route intercon[] = {
@@@ -3606,6 -3832,7 +4044,10 @@@
  	{"MultiMedia2 Mixer", "SLIM_0_TX", "SLIMBUS_0_TX"},
  	{"MultiMedia1 Mixer", "SEC_MI2S_TX", "SEC_MI2S_TX"},
  	{"MultiMedia1 Mixer", "PRI_MI2S_TX", "PRI_MI2S_TX"},
++<<<<<<< HEAD
++=======
+ 	{"MultiMedia6 Mixer", "SLIM_0_TX", "SLIMBUS_0_TX"},
++>>>>>>> FETCH_HEAD
  
  	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
  	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia2", "MM_DL2"},
@@@ -3616,6 -3843,7 +4058,10 @@@
  	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia7", "MM_DL7"},
  	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia8", "MM_DL8"},
  	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia9", "MM_DL9"},
++<<<<<<< HEAD
++=======
+ 	{"INTERNAL_BT_SCO_RX Audio Mixer", "MultiMedia6", "MM_UL6"},
++>>>>>>> FETCH_HEAD
  	{"INT_BT_SCO_RX", NULL, "INTERNAL_BT_SCO_RX Audio Mixer"},
  
  	{"INTERNAL_FM_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
@@@ -3648,6 -3876,7 +4094,10 @@@
  	{"MultiMedia4 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
  	{"MultiMedia5 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
  	{"MultiMedia8 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
++<<<<<<< HEAD
++=======
+ 	{"MultiMedia6 Mixer", "INTERNAL_FM_TX", "INT_FM_TX"},
++>>>>>>> FETCH_HEAD
  
  	{"MultiMedia1 Mixer", "AFE_PCM_TX", "PCM_TX"},
  	{"MultiMedia4 Mixer", "AFE_PCM_TX", "PCM_TX"},
@@@ -3658,10 -3887,12 +4108,18 @@@
  	{"MM_UL2", NULL, "MultiMedia2 Mixer"},
  	{"MM_UL4", NULL, "MultiMedia4 Mixer"},
  	{"MM_UL5", NULL, "MultiMedia5 Mixer"},
++<<<<<<< HEAD
++=======
+ 	{"MM_UL6", NULL, "MultiMedia6 Mixer"},
++>>>>>>> FETCH_HEAD
  	{"MM_UL8", NULL, "MultiMedia8 Mixer"},
  #ifdef CONFIG_JACK_AUDIO
  	{"MM_UL10", NULL, "MultiMedia10 Mixer"},
  #endif	
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> FETCH_HEAD
  	{"AUX_PCM_RX Audio Mixer", "MultiMedia1", "MM_DL1"},
  	{"AUX_PCM_RX Audio Mixer", "MultiMedia2", "MM_DL2"},
  	{"AUX_PCM_RX Audio Mixer", "MultiMedia3", "MM_DL3"},
@@@ -3784,6 -4015,55 +4242,58 @@@
  	{"MI2S_RX_Voice Mixer", "QCHAT", "QCHAT_DL"},
  	{"MI2S_RX", NULL, "MI2S_RX_Voice Mixer"},
  
++<<<<<<< HEAD
++=======
+ 	{"VOC_EXT_EC MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"VOC_EXT_EC MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"VOC_EXT_EC MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"VOC_EXT_EC MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 	{"CS-VOICE_UL1", NULL, "VOC_EXT_EC MUX"},
+ 
+ 	{"AUDIO_REF_EC_UL1 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL1 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL1 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL1 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"AUDIO_REF_EC_UL2 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL2 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL2 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL2 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"AUDIO_REF_EC_UL4 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL4 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL4 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL4 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"AUDIO_REF_EC_UL5 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL5 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL5 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL5 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"AUDIO_REF_EC_UL6 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL6 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL6 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL6 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"AUDIO_REF_EC_UL8 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL8 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL8 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL8 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"AUDIO_REF_EC_UL9 MUX", "PRI_MI2S_TX" , "PRI_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL9 MUX", "SEC_MI2S_TX" , "SEC_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL9 MUX", "TERT_MI2S_TX" , "TERT_MI2S_TX"},
+ 	{"AUDIO_REF_EC_UL9 MUX", "QUAT_MI2S_TX" , "QUAT_MI2S_TX"},
+ 
+ 	{"MM_UL1", NULL, "AUDIO_REF_EC_UL1 MUX"},
+ 	{"MM_UL2", NULL, "AUDIO_REF_EC_UL2 MUX"},
+ 	{"MM_UL4", NULL, "AUDIO_REF_EC_UL4 MUX"},
+ 	{"MM_UL5", NULL, "AUDIO_REF_EC_UL5 MUX"},
+ 	{"MM_UL6", NULL, "AUDIO_REF_EC_UL6 MUX"},
+ 	{"MM_UL8", NULL, "AUDIO_REF_EC_UL8 MUX"},
+ 	{"MM_UL9", NULL, "AUDIO_REF_EC_UL9 MUX"},
+ 
++>>>>>>> FETCH_HEAD
  	{"Voice_Tx Mixer", "PRI_TX_Voice", "PRI_I2S_TX"},
  	{"Voice_Tx Mixer", "PRI_MI2S_TX_Voice", "PRI_MI2S_TX"},
  	{"Voice_Tx Mixer", "MI2S_TX_Voice", "MI2S_TX"},
@@@ -3853,6 -4133,8 +4363,11 @@@
  
  	{"INT_FM_RX", NULL, "INTFM_DL_HL"},
  	{"INTFM_UL_HL", NULL, "INT_FM_TX"},
++<<<<<<< HEAD
++=======
+ 	{"INTHFP_UL_HL", NULL, "INT_BT_SCO_TX"},
+ 	{"INT_BT_SCO_RX", NULL, "MM_DL6"},
++>>>>>>> FETCH_HEAD
  	{"AUX_PCM_RX", NULL, "AUXPCM_DL_HL"},
  	{"AUXPCM_UL_HL", NULL, "AUX_PCM_TX"},
  	{"MI2S_RX", NULL, "MI2S_DL_HL"},
@@@ -4030,12 -4312,15 +4545,23 @@@ static int msm_pcm_routing_close(struc
  	mutex_lock(&routing_lock);
  	topology = get_topology(path_type);
  	for_each_set_bit(i, &bedai->fe_sessions, MSM_FRONTEND_DAI_MM_SIZE) {
++<<<<<<< HEAD
 +		if (fe_dai_map[i][session_type] != INVALID_SESSION) {
++=======
+ 		if (fe_dai_map[i][session_type].strm_id != INVALID_SESSION) {
+ 			fe_dai_map[i][session_type].be_srate =
+ 				bedai->sample_rate;
++>>>>>>> FETCH_HEAD
  			adm_close(bedai->port_id,
  				  fe_dai_perf_mode[i][session_type]);
  			srs_port_id = -1;
  			if ((DOLBY_ADM_COPP_TOPOLOGY_ID == topology) &&
++<<<<<<< HEAD
 +			    (fe_dai_perf_mode[i][session_type] == false))
++=======
+ 			    (fe_dai_perf_mode[i][session_type] ==
+ 							LEGACY_PCM_MODE))
++>>>>>>> FETCH_HEAD
  				dolby_dap_deinit(bedai->port_id);
  		}
  	}
@@@ -4057,6 -4342,7 +4583,10 @@@ static int msm_pcm_routing_prepare(stru
  	u32 channels;
  	bool playback, capture;
  	uint16_t bits_per_sample = 16;
++<<<<<<< HEAD
++=======
+ 	struct msm_pcm_routing_fdai_data *fdai;
++>>>>>>> FETCH_HEAD
  
  	if (be_id >= MSM_BACKEND_DAI_MAX) {
  		pr_err("%s: unexpected be_id %d\n", __func__, be_id);
@@@ -4088,8 -4374,21 +4618,26 @@@
  	capture = substream->stream == SNDRV_PCM_STREAM_CAPTURE;
  
  	for_each_set_bit(i, &bedai->fe_sessions, MSM_FRONTEND_DAI_MM_SIZE) {
++<<<<<<< HEAD
 +		if (fe_dai_map[i][session_type] != INVALID_SESSION) {
 +
++=======
+ 		fdai = &fe_dai_map[i][session_type];
+ 		if (fdai->strm_id != INVALID_SESSION) {
+ 			if (session_type == SESSION_TYPE_TX &&
+ 			    fdai->be_srate &&
+ 			    (fdai->be_srate != bedai->sample_rate)) {
+ 				pr_debug("%s: flush strm %d diff BE rates\n",
+ 					__func__,
+ 					fdai->strm_id);
+ 
+ 				if (fdai->event_info.event_func)
+ 					fdai->event_info.event_func(
+ 						MSM_PCM_RT_EVT_BUF_RECFG,
+ 						fdai->event_info.priv_data);
+ 				fdai->be_srate = 0; /* might not need it */
+ 			}
++>>>>>>> FETCH_HEAD
  			channels = bedai->channel;
  			if (bedai->format == SNDRV_PCM_FORMAT_S24_LE)
  				bits_per_sample = 24;
@@@ -4111,17 -4410,18 +4659,30 @@@
  				path_type,
  				bedai->sample_rate,
  				channels,
++<<<<<<< HEAD
 +				topology, false,
++=======
+ 				topology, fe_dai_perf_mode[i][session_type],
++>>>>>>> FETCH_HEAD
  				bits_per_sample);
  			}
  
  			msm_pcm_routing_build_matrix(i,
++<<<<<<< HEAD
 +				fe_dai_map[i][session_type], path_type,
++=======
+ 				fdai->strm_id, path_type,
++>>>>>>> FETCH_HEAD
  				fe_dai_perf_mode[i][session_type]);
  			port_id = srs_port_id = bedai->port_id;
  			srs_send_params(srs_port_id, 1, 0);
  			if ((DOLBY_ADM_COPP_TOPOLOGY_ID == topology) &&
++<<<<<<< HEAD
 +			    (fe_dai_perf_mode[i][session_type] == false))
++=======
+ 			    (fe_dai_perf_mode[i][session_type] ==
+ 							LEGACY_PCM_MODE))
++>>>>>>> FETCH_HEAD
  				if (dolby_dap_init(port_id, channels) < 0)
  					pr_err("%s: Err init dolby dap\n",
  						__func__);
@@@ -4237,10 -4537,6 +4798,13 @@@ static int msm_routing_probe(struct snd
  			ARRAY_SIZE(dolby_dap_param_end_point_controls));
  
  	snd_soc_add_platform_controls(platform,
++<<<<<<< HEAD
 +				ec_ref_rx_mixer_controls,
 +			ARRAY_SIZE(ec_ref_rx_mixer_controls));
 +
 +	snd_soc_add_platform_controls(platform,
++=======
++>>>>>>> FETCH_HEAD
  				get_rms_controls,
  			ARRAY_SIZE(get_rms_controls));
  
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h
index 64f1686,3f98802..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h
@@@ -146,15 -146,30 +146,40 @@@ enum 
  	MSM_BACKEND_DAI_MAX,
  };
  
++<<<<<<< HEAD
++=======
+ enum msm_pcm_routing_event {
+ 	MSM_PCM_RT_EVT_BUF_RECFG,
+ 	MSM_PCM_RT_EVT_DEVSWITCH,
+ 	MSM_PCM_RT_EVT_MAX,
+ };
+ 
++>>>>>>> FETCH_HEAD
  /* dai_id: front-end ID,
   * dspst_id:  DSP audio stream ID
   * stream_type: playback or capture
   */
++<<<<<<< HEAD
 +void msm_pcm_routing_reg_phy_stream(int fedai_id, bool perf_mode, int dspst_id,
++=======
+ void msm_pcm_routing_reg_phy_stream(int fedai_id, int perf_mode, int dspst_id,
++>>>>>>> FETCH_HEAD
  	int stream_type);
  void msm_pcm_routing_reg_psthr_stream(int fedai_id, int dspst_id,
  		int stream_type);
  
++<<<<<<< HEAD
++=======
+ struct msm_pcm_routing_evt {
+ 	void (*event_func)(enum msm_pcm_routing_event, void *);
+ 	void *priv_data;
+ };
+ 
+ void msm_pcm_routing_reg_phy_stream_v2(int fedai_id, bool perf_mode,
+ 				       int dspst_id, int stream_type,
+ 				       struct msm_pcm_routing_evt event_info);
+ 
++>>>>>>> FETCH_HEAD
  void msm_pcm_routing_dereg_phy_stream(int fedai_id, int stream_type);
  
  int msm_routing_check_backend_enabled(int fedai_id);
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c
index 1f91ce3,4da9553..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c
@@@ -424,12 -424,37 +424,44 @@@ static int msm_voice_mute_put(struct sn
  	pr_debug("%s: mute=%d session_id=%#x ramp_duration=%d\n", __func__,
  		mute, session_id, ramp_duration);
  
++<<<<<<< HEAD
 +	voc_set_tx_mute(session_id, TX_PATH, mute, ramp_duration);
++=======
+ 	ret = voc_set_tx_mute(session_id, TX_PATH, mute, ramp_duration);
++>>>>>>> FETCH_HEAD
  
  done:
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int msm_voice_tx_device_mute_put(struct snd_kcontrol *kcontrol,
+ 					struct snd_ctl_elem_value *ucontrol)
+ {
+ 	int ret = 0;
+ 	int mute = ucontrol->value.integer.value[0];
+ 	uint32_t session_id = ucontrol->value.integer.value[1];
+ 	int ramp_duration = ucontrol->value.integer.value[2];
+ 
+ 	if ((mute < 0) || (mute > 1) || (ramp_duration < 0) ||
+ 	    (ramp_duration > MAX_RAMP_DURATION)) {
+ 		pr_err(" %s Invalid arguments", __func__);
+ 
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+ 
+ 	pr_debug("%s: mute=%d session_id=%#x ramp_duration=%d\n", __func__,
+ 		 mute, session_id, ramp_duration);
+ 
+ 	ret = voc_set_device_mute(session_id, VSS_IVOLUME_DIRECTION_TX,
+ 				  mute, ramp_duration);
+ 
+ done:
+ 	return ret;
+ }
++>>>>>>> FETCH_HEAD
  
  static int msm_voice_rx_device_mute_put(struct snd_kcontrol *kcontrol,
  					struct snd_ctl_elem_value *ucontrol)
@@@ -439,8 -464,8 +471,13 @@@
  	uint32_t session_id = ucontrol->value.integer.value[1];
  	int ramp_duration = ucontrol->value.integer.value[2];
  
++<<<<<<< HEAD
 +	if ((mute < 0) || (mute > 1) || (ramp_duration < 0)
 +		|| (ramp_duration > MAX_RAMP_DURATION)) {
++=======
+ 	if ((mute < 0) || (mute > 1) || (ramp_duration < 0) ||
+ 	    (ramp_duration > MAX_RAMP_DURATION)) {
++>>>>>>> FETCH_HEAD
  		pr_err(" %s Invalid arguments", __func__);
  
  		ret = -EINVAL;
@@@ -448,9 -473,10 +485,16 @@@
  	}
  
  	pr_debug("%s: mute=%d session_id=%#x ramp_duration=%d\n", __func__,
++<<<<<<< HEAD
 +		mute, session_id, ramp_duration);
 +
 +	voc_set_rx_device_mute(session_id, mute, ramp_duration);
++=======
+ 		 mute, session_id, ramp_duration);
+ 
+ 	voc_set_device_mute(session_id, VSS_IVOLUME_DIRECTION_RX,
+ 			    mute, ramp_duration);
++>>>>>>> FETCH_HEAD
  
  done:
  	return ret;
@@@ -553,6 -579,8 +597,11 @@@ static int msm_voice_slowtalk_get(struc
  static struct snd_kcontrol_new msm_voice_controls[] = {
  	SOC_SINGLE_MULTI_EXT("Voice Rx Device Mute", SND_SOC_NOPM, 0, VSID_MAX,
  				0, 3, NULL, msm_voice_rx_device_mute_put),
++<<<<<<< HEAD
++=======
+ 	SOC_SINGLE_MULTI_EXT("Voice Tx Device Mute", SND_SOC_NOPM, 0, VSID_MAX,
+ 				0, 3, NULL, msm_voice_tx_device_mute_put),
++>>>>>>> FETCH_HEAD
  	SOC_SINGLE_MULTI_EXT("Voice Tx Mute", SND_SOC_NOPM, 0, VSID_MAX,
  				0, 3, NULL, msm_voice_mute_put),
  	SOC_SINGLE_MULTI_EXT("Voice Rx Gain", SND_SOC_NOPM, 0, VSID_MAX, 0, 3,
@@@ -567,6 -595,8 +616,11 @@@
  #endif	/* CONFIG_SEC_DHA_SOL_MAL */
  	SOC_SINGLE_EXT("Loopback Enable", SND_SOC_NOPM, 0, 1, 0,
  				msm_loopback_get, msm_loopback_put),
++<<<<<<< HEAD
++=======
+ 	// Dummy control to expose stereo recording support in kernel to user-space
+ 	SOC_SINGLE_EXT("Stereo Recording", SND_SOC_NOPM, 0, VSID_MAX, 0, NULL, NULL),
++>>>>>>> FETCH_HEAD
  };
  
  static struct snd_pcm_ops msm_pcm_ops = {
diff --cc sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c
index 92cdffc,b506484..0000000
--- a/sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -33,12 -33,7 +37,16 @@@
  #include "audio_ocmem.h"
  
  #define SHARED_MEM_BUF 2
++<<<<<<< HEAD
 +#if defined(CONFIG_SEC_H_PROJECT)
 +#define VOIP_MIN_Q_LEN 2
 +#define VOIP_MAX_Q_LEN 10
 +#else
  #define VOIP_MAX_Q_LEN 2
 +#endif
++=======
++#define VOIP_MAX_Q_LEN 2
++>>>>>>> FETCH_HEAD
  #define VOIP_MAX_VOC_PKT_SIZE 4096
  #define VOIP_MIN_VOC_PKT_SIZE 320
  
@@@ -52,8 -47,27 +60,32 @@@
  #define MODE_AMR_WB		0xD
  #define MODE_PCM		0xC
  #define MODE_4GV_NW		0xE
++<<<<<<< HEAD
 +
 +#define VOIP_MODE_MAX		MODE_4GV_NW
++=======
+ #define MODE_G711		0xA
+ #define MODE_G711A		0xF
+ 
+ enum msm_audio_g711a_frame_type {
+ 	MVS_G711A_SPEECH_GOOD,
+ 	MVS_G711A_SID,
+ 	MVS_G711A_NO_DATA,
+ 	MVS_G711A_ERASURE
+ };
+ 
+ enum msm_audio_g711a_mode {
+ 	MVS_G711A_MODE_MULAW,
+ 	MVS_G711A_MODE_ALAW
+ };
+ 
+ enum msm_audio_g711_mode {
+ 	MVS_G711_MODE_MULAW,
+ 	MVS_G711_MODE_ALAW
+ };
+ 
+ #define VOIP_MODE_MAX		MODE_G711A
++>>>>>>> FETCH_HEAD
  #define VOIP_RATE_MAX		23850
  
  enum format {
@@@ -91,6 -105,10 +123,13 @@@ enum voip_state 
  struct voip_frame_hdr {
  	uint32_t timestamp;
  	union {
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * Bits 0-15: Frame type
+ 		 * Bits 16-31: Frame rate
+ 		 */
++>>>>>>> FETCH_HEAD
  		uint32_t frame_type;
  		uint32_t packet_rate;
  	};
@@@ -154,7 -172,7 +193,11 @@@ struct voip_drv_info 
  	uint32_t evrc_max_rate;
  };
  
++<<<<<<< HEAD
 +static int voip_get_media_type(uint32_t mode,
++=======
+ static int voip_get_media_type(uint32_t mode, uint32_t rate_type,
++>>>>>>> FETCH_HEAD
  				unsigned int samp_rate,
  				unsigned int *media_type);
  static int voip_get_rate_type(uint32_t mode,
@@@ -167,8 -185,6 +210,11 @@@ static int msm_voip_mode_config_get(str
  				    struct snd_ctl_elem_value *ucontrol);
  static int msm_voip_rate_config_put(struct snd_kcontrol *kcontrol,
  				    struct snd_ctl_elem_value *ucontrol);
++<<<<<<< HEAD
 +static int msm_voip_rate_config_get(struct snd_kcontrol *kcontrol,
 +				    struct snd_ctl_elem_value *ucontrol);
++=======
++>>>>>>> FETCH_HEAD
  static int msm_voip_evrc_min_max_rate_config_put(struct snd_kcontrol *kcontrol,
  					 struct snd_ctl_elem_value *ucontrol);
  static int msm_voip_evrc_min_max_rate_config_get(struct snd_kcontrol *kcontrol,
@@@ -188,20 -204,11 +234,28 @@@ static struct snd_pcm_hardware msm_pcm_
  	.rate_max =             16000,
  	.channels_min =         1,
  	.channels_max =         1,
++<<<<<<< HEAD
 +#if defined(CONFIG_SEC_H_PROJECT)
 +	.buffer_bytes_max =	sizeof(struct voip_buf_node) * VOIP_MIN_Q_LEN,
 +#else
 +	.buffer_bytes_max =	sizeof(struct voip_buf_node) * VOIP_MAX_Q_LEN,
 +#endif
 +	.period_bytes_min =	VOIP_MIN_VOC_PKT_SIZE,
 +	.period_bytes_max =	VOIP_MAX_VOC_PKT_SIZE,
 +#if defined(CONFIG_SEC_H_PROJECT)
 +	.periods_min =		VOIP_MIN_Q_LEN,
 +	.periods_max =		VOIP_MAX_Q_LEN,
 +#else
 +	.periods_min =		VOIP_MAX_Q_LEN,
 +	.periods_max =		VOIP_MAX_Q_LEN,
 +#endif
++=======
+ 	.buffer_bytes_max =	sizeof(struct voip_buf_node) * VOIP_MAX_Q_LEN,
+ 	.period_bytes_min =	VOIP_MIN_VOC_PKT_SIZE,
+ 	.period_bytes_max =	VOIP_MAX_VOC_PKT_SIZE,
+ 	.periods_min =		VOIP_MAX_Q_LEN,
+ 	.periods_max =		VOIP_MAX_Q_LEN,
++>>>>>>> FETCH_HEAD
  	.fifo_size =            0,
  };
  
@@@ -291,7 -298,7 +345,11 @@@ static struct snd_kcontrol_new msm_voip
  	SOC_SINGLE_EXT("Voip Mode Config", SND_SOC_NOPM, 0, VOIP_MODE_MAX, 0,
  		       msm_voip_mode_config_get, msm_voip_mode_config_put),
  	SOC_SINGLE_EXT("Voip Rate Config", SND_SOC_NOPM, 0, VOIP_RATE_MAX, 0,
++<<<<<<< HEAD
 +		       msm_voip_rate_config_get, msm_voip_rate_config_put),
++=======
+ 		       NULL, msm_voip_rate_config_put),
++>>>>>>> FETCH_HEAD
  	SOC_SINGLE_MULTI_EXT("Voip Evrc Min Max Rate Config", SND_SOC_NOPM,
  			     0, VOC_1_RATE, 0, 2, msm_voip_evrc_min_max_rate_config_get,
  			     msm_voip_evrc_min_max_rate_config_put),
@@@ -370,6 -377,81 +428,84 @@@ static void voip_process_ul_pkt(uint8_
  			list_add_tail(&buf_node->list, &prtd->out_queue);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		case MODE_G711:
+ 		case MODE_G711A:{
+ 			/* G711 frames are 10ms each, but the DSP works with
+ 			 * 20ms frames and sends two 10ms frames per buffer.
+ 			 * Extract the two frames and put them in separate
+ 			 * buffers.
+ 			 */
+ 			/* Remove the first DSP frame info header.
+ 			 * Header format: G711A
+ 			 * Bits 0-1: Frame type
+ 			 * Bits 2-3: Frame rate
+ 			 *
+ 			 * Header format: G711
+ 			 * Bits 2-3: Frame rate
+ 			 */
+ 			if (prtd->mode == MODE_G711A)
+ 				buf_node->frame.frm_hdr.frame_type =
+ 							(*voc_pkt) & 0x03;
+ 			buf_node->frame.frm_hdr.timestamp = timestamp;
+ 			voc_pkt = voc_pkt + DSP_FRAME_HDR_LEN;
+ 
+ 			/* There are two frames in the buffer. Length of the
+ 			 * first frame:
+ 			 */
+ 			buf_node->frame.pktlen = (pkt_len -
+ 						  2 * DSP_FRAME_HDR_LEN) / 2;
+ 
+ 			memcpy(&buf_node->frame.voc_pkt[0],
+ 			       voc_pkt,
+ 			       buf_node->frame.pktlen);
+ 			voc_pkt = voc_pkt + buf_node->frame.pktlen;
+ 
+ 			list_add_tail(&buf_node->list, &prtd->out_queue);
+ 
+ 			/* Get another buffer from the free Q and fill in the
+ 			 * second frame.
+ 			 */
+ 			if (!list_empty(&prtd->free_out_queue)) {
+ 				buf_node =
+ 					list_first_entry(&prtd->free_out_queue,
+ 							 struct voip_buf_node,
+ 							 list);
+ 				list_del(&buf_node->list);
+ 
+ 				/* Remove the second DSP frame info header.
+ 				 * Header format:
+ 				 * Bits 0-1: Frame type
+ 				 * Bits 2-3: Frame rate
+ 				 */
+ 
+ 				if (prtd->mode == MODE_G711A)
+ 					buf_node->frame.frm_hdr.frame_type =
+ 							(*voc_pkt) & 0x03;
+ 				buf_node->frame.frm_hdr.timestamp = timestamp;
+ 				voc_pkt = voc_pkt + DSP_FRAME_HDR_LEN;
+ 
+ 				/* There are two frames in the buffer. Length
+ 				 * of the second frame:
+ 				 */
+ 				buf_node->frame.pktlen = (pkt_len -
+ 						2 * DSP_FRAME_HDR_LEN) / 2;
+ 
+ 				memcpy(&buf_node->frame.voc_pkt[0],
+ 				       voc_pkt,
+ 				       buf_node->frame.pktlen);
+ 
+ 				list_add_tail(&buf_node->list,
+ 					      &prtd->out_queue);
+ 			} else {
+ 				/* Drop the second frame */
+ 				pr_err("%s: UL data dropped, read is slow\n",
+ 				       __func__);
+ 			}
+ 			break;
+ 		}
++>>>>>>> FETCH_HEAD
  		default: {
  			buf_node->frame.frm_hdr.timestamp = timestamp;
  			buf_node->frame.pktlen = pkt_len;
@@@ -399,6 -481,10 +535,13 @@@ static void voip_process_dl_pkt(uint8_
  	struct voip_buf_node *buf_node = NULL;
  	struct voip_drv_info *prtd = private_data;
  	unsigned long dsp_flags;
++<<<<<<< HEAD
++=======
+ 	uint32_t rate_type;
+ 	uint32_t frame_rate;
+ 	u32 pkt_len;
+ 	u8 *voc_addr = NULL;
++>>>>>>> FETCH_HEAD
  
  	if (prtd->playback_substream == NULL)
  		return;
@@@ -422,7 -508,19 +565,23 @@@
  			 * Bits 4-7: Frame type
  			 */
  			*voc_pkt = ((buf_node->frame.frm_hdr.frame_type &
++<<<<<<< HEAD
 +					0x0F) << 4) | (prtd->rate_type & 0x0F);
++=======
+ 				   0x0F) << 4);
+ 			frame_rate = (buf_node->frame.frm_hdr.frame_type &
+ 				     0xFFFF0000) >> 16;
+ 			if (frame_rate) {
+ 				if (voip_get_rate_type(prtd->mode, frame_rate,
+ 						       &rate_type)) {
+ 					pr_err("%s(): fail at getting rate_type \n",
+ 						__func__);
+ 				} else
+ 					prtd->rate_type = rate_type;
+ 			}
+ 			*voc_pkt |= prtd->rate_type & 0x0F;
+ 
++>>>>>>> FETCH_HEAD
  			voc_pkt = voc_pkt + DSP_FRAME_HDR_LEN;
  			memcpy(voc_pkt,
  				&buf_node->frame.voc_pkt[0],
@@@ -452,6 -550,70 +611,73 @@@
  			list_add_tail(&buf_node->list, &prtd->free_in_queue);
  			break;
  		}
++<<<<<<< HEAD
++=======
+ 		case MODE_G711:
+ 		case MODE_G711A:{
+ 			/* G711 frames are 10ms each but the DSP expects 20ms
+ 			 * worth of data, so send two 10ms frames per buffer.
+ 			 */
+ 			/* Add the first DSP frame info header. Header format:
+ 			 * Bits 0-1: Frame type
+ 			 * Bits 2-3: Frame rate
+ 			 */
+ 			voc_addr = voc_pkt;
+ 			voc_pkt = voc_pkt + sizeof(uint32_t);
+ 
+ 			*voc_pkt = ((prtd->rate_type  & 0x0F) << 2) |
+ 				    (buf_node->frame.frm_hdr.frame_type & 0x03);
+ 			voc_pkt = voc_pkt + DSP_FRAME_HDR_LEN;
+ 
+ 			pkt_len = buf_node->frame.pktlen + DSP_FRAME_HDR_LEN;
+ 
+ 			memcpy(voc_pkt,
+ 			       &buf_node->frame.voc_pkt[0],
+ 			       buf_node->frame.pktlen);
+ 			voc_pkt = voc_pkt + buf_node->frame.pktlen;
+ 
+ 			list_add_tail(&buf_node->list, &prtd->free_in_queue);
+ 
+ 			if (!list_empty(&prtd->in_queue)) {
+ 				/* Get the second buffer. */
+ 				buf_node = list_first_entry(&prtd->in_queue,
+ 							struct voip_buf_node,
+ 							list);
+ 				list_del(&buf_node->list);
+ 
+ 				/* Add the second DSP frame info header.
+ 				 * Header format:
+ 				 * Bits 0-1: Frame type
+ 				 * Bits 2-3: Frame rate
+ 				 */
+ 				*voc_pkt = ((prtd->rate_type & 0x0F) << 2) |
+ 				(buf_node->frame.frm_hdr.frame_type & 0x03);
+ 				voc_pkt = voc_pkt + DSP_FRAME_HDR_LEN;
+ 
+ 				pkt_len = pkt_len + buf_node->frame.pktlen +
+ 					   DSP_FRAME_HDR_LEN;
+ 
+ 				memcpy(voc_pkt,
+ 				       &buf_node->frame.voc_pkt[0],
+ 				       buf_node->frame.pktlen);
+ 
+ 				list_add_tail(&buf_node->list,
+ 					      &prtd->free_in_queue);
+ 			} else {
+ 				/* Only 10ms worth of data is available, signal
+ 				 * erasure frame.
+ 				 */
+ 				*voc_pkt = ((prtd->rate_type & 0x0F) << 2) |
+ 					    (MVS_G711A_ERASURE & 0x03);
+ 
+ 				pkt_len = pkt_len + DSP_FRAME_HDR_LEN;
+ 				pr_debug("%s, Only 10ms read, erase 2nd frame\n",
+ 					 __func__);
+ 			}
+ 			*((uint32_t *)voc_addr) = pkt_len;
+ 			break;
+ 		}
++>>>>>>> FETCH_HEAD
  		default: {
  			*((uint32_t *)voc_pkt) = buf_node->frame.pktlen;
  			voc_pkt = voc_pkt + sizeof(uint32_t);
@@@ -827,10 -989,12 +1053,19 @@@ static int voip_config_vocoder(struct s
          pr_info("%s(): mode=%d, playback sample rate=%d, capture sample rate=%d\n",
                    __func__, prtd->mode, prtd->play_samp_rate, prtd->cap_samp_rate);
  
++<<<<<<< HEAD
 +	if ((runtime->format != FORMAT_S16_LE) && ((prtd->mode == MODE_PCM) ||
 +	    (prtd->mode == MODE_AMR) || (prtd->mode == MODE_AMR_WB) ||
 +	    (prtd->mode == MODE_IS127) || (prtd->mode == MODE_4GV_NB) ||
 +	    (prtd->mode == MODE_4GV_WB) || (prtd->mode == MODE_4GV_NW))) {
++=======
+ 	if ((runtime->format != FORMAT_S16_LE &&
+ 	     runtime->format != FORMAT_SPECIAL) &&
+ 	    ((prtd->mode == MODE_AMR) || (prtd->mode == MODE_AMR_WB) ||
+ 	    (prtd->mode == MODE_IS127) || (prtd->mode == MODE_4GV_NB) ||
+ 	    (prtd->mode == MODE_4GV_WB) || (prtd->mode == MODE_4GV_NW) ||
+ 	    (prtd->mode == MODE_G711) || (prtd->mode == MODE_G711A))) {
++>>>>>>> FETCH_HEAD
  		pr_err("%s(): mode:%d and format:%u are not matched\n",
  			__func__, prtd->mode, (uint32_t)runtime->format);
  
@@@ -838,21 -1002,19 +1073,37 @@@
  		goto done;
  	}
  
++<<<<<<< HEAD
 +	ret = voip_get_media_type(prtd->mode,
 +				  prtd->play_samp_rate,
 +				  &media_type);
 +	if (ret < 0) {
 +		pr_err("%s(): fail at getting media_type, ret=%d\n",
 +			__func__, ret);
 +
 +		ret = -EINVAL;
 +		goto done;
 +	}
 +	pr_debug("%s(): media_type=%d\n", __func__, media_type);
 +
 +	if ((prtd->mode == MODE_PCM) ||
 +	    (prtd->mode == MODE_AMR) ||
 +	    (prtd->mode == MODE_AMR_WB)) {
++=======
+ 	if (runtime->format != FORMAT_S16_LE && (prtd->mode == MODE_PCM)) {
+ 		pr_err("%s(): mode:%d and format:%u are not matched\n",
+ 		       __func__, prtd->mode, runtime->format);
+ 
+ 		ret =  -EINVAL;
+ 		goto done;
+ 	}
+ 
+ 	if ((prtd->mode == MODE_PCM) ||
+ 	    (prtd->mode == MODE_AMR) ||
+ 	    (prtd->mode == MODE_AMR_WB) ||
+ 	    (prtd->mode == MODE_G711) ||
+ 	    (prtd->mode == MODE_G711A)) {
++>>>>>>> FETCH_HEAD
  		ret = voip_get_rate_type(prtd->mode,
  					 prtd->rate,
  					 &rate_type);
@@@ -907,6 -1069,19 +1158,22 @@@
  		pr_debug("%s(): min rate=%d, max rate=%d\n",
  			  __func__, evrc_min_rate_type, evrc_max_rate_type);
  	}
++<<<<<<< HEAD
++=======
+ 	ret = voip_get_media_type(prtd->mode,
+ 				  prtd->rate_type,
+ 				  prtd->play_samp_rate,
+ 				  &media_type);
+ 	if (ret < 0) {
+ 		pr_err("%s(): fail at getting media_type, ret=%d\n",
+ 		       __func__, ret);
+ 
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+ 	pr_debug("%s(): media_type=%d\n", __func__, media_type);
+ 
++>>>>>>> FETCH_HEAD
  	if ((prtd->play_samp_rate == 8000) &&
  	    (prtd->cap_samp_rate == 8000))
  		voc_config_vocoder(media_type, rate_type,
@@@ -1034,18 -1209,11 +1301,25 @@@ static int msm_pcm_hw_params(struct snd
  	struct snd_dma_buffer *dma_buf = &substream->dma_buffer;
  	struct voip_buf_node *buf_node = NULL;
  	int i = 0, offset = 0;
++<<<<<<< HEAD
 +#if defined(CONFIG_SEC_H_PROJECT)
 +	int periods = VOIP_MIN_Q_LEN;
 +#endif
++=======
+ 
++>>>>>>> FETCH_HEAD
  	pr_debug("%s: voip\n", __func__);
  
  	mutex_lock(&voip_info.lock);
  
++<<<<<<< HEAD
 +#if defined(CONFIG_SEC_H_PROJECT)
 +	periods = params_periods(params);
 +	pr_info("%s: periods = %d\n", __func__, periods);
 +	runtime->hw.buffer_bytes_max = sizeof(struct voip_buf_node) * periods;
 +#endif
++=======
++>>>>>>> FETCH_HEAD
  	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
  	dma_buf->dev.dev = substream->pcm->card->dev;
  	dma_buf->private_data = NULL;
@@@ -1063,11 -1231,7 +1337,15 @@@
  	memset(dma_buf->area, 0, runtime->hw.buffer_bytes_max);
  
  	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
++<<<<<<< HEAD
 +#if defined(CONFIG_SEC_H_PROJECT)
 +		for (i = 0; i < periods; i++) {
 +#else
  		for (i = 0; i < VOIP_MAX_Q_LEN; i++) {
 +#endif
++=======
++		for (i = 0; i < VOIP_MAX_Q_LEN; i++) {
++>>>>>>> FETCH_HEAD
  			buf_node = (void *)dma_buf->area + offset;
  
  			list_add_tail(&buf_node->list,
@@@ -1075,11 -1239,7 +1353,15 @@@
  			offset = offset + sizeof(struct voip_buf_node);
  		}
  	} else {
++<<<<<<< HEAD
 +#if defined(CONFIG_SEC_H_PROJECT)
 +		for (i = 0; i < periods; i++) {
 +#else
 +		for (i = 0; i < VOIP_MAX_Q_LEN; i++) {
 +#endif
++=======
+ 		for (i = 0; i < VOIP_MAX_Q_LEN; i++) {
++>>>>>>> FETCH_HEAD
  			buf_node = (void *) dma_buf->area + offset;
  			list_add_tail(&buf_node->list,
  					&voip_info.free_out_queue);
@@@ -1120,30 -1280,43 +1402,70 @@@ static int msm_voip_mode_config_put(str
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int msm_voip_rate_config_get(struct snd_kcontrol *kcontrol,
 +				    struct snd_ctl_elem_value *ucontrol)
 +{
 +	mutex_lock(&voip_info.lock);
 +
 +	ucontrol->value.integer.value[0] = voip_info.rate;
 +
 +	mutex_unlock(&voip_info.lock);
 +
 +	return 0;
 +}
 +
 +static int msm_voip_rate_config_put(struct snd_kcontrol *kcontrol,
 +				    struct snd_ctl_elem_value *ucontrol)
 +{
 +	mutex_lock(&voip_info.lock);
 +
 +	voip_info.rate = ucontrol->value.integer.value[0];
 +
 +	pr_debug("%s: rate=%d\n", __func__, voip_info.rate);
 +
 +	mutex_unlock(&voip_info.lock);
 +
 +	return 0;
++=======
+ static int msm_voip_rate_config_put(struct snd_kcontrol *kcontrol,
+ 				    struct snd_ctl_elem_value *ucontrol)
+ {
+ 	int ret = 0;
+ 	int rate = ucontrol->value.integer.value[0];
+ 
+ 	mutex_lock(&voip_info.lock);
+ 
+ 	if (voip_info.rate != rate) {
+ 		voip_info.rate = rate;
+ 		pr_debug("%s: rate=%d\n", __func__, voip_info.rate);
+ 
+ 		if (voip_info.state == VOIP_STARTED &&
+ 		   (voip_info.mode == MODE_AMR ||
+ 		    voip_info.mode == MODE_AMR_WB)) {
+ 			ret = voip_config_vocoder(
+ 					voip_info.capture_substream);
+ 			if (ret) {
+ 				pr_err("%s:Failed to configure vocoder, ret=%d\n",
+ 					__func__, ret);
+ 
+ 				goto done;
+ 			}
+ 
+ 			ret = voc_update_amr_vocoder_rate(
+ 					voc_get_session_id(VOIP_SESSION_NAME));
+ 			if (ret) {
+ 				pr_err("%s:Failed to update AMR rate, ret=%d\n",
+ 					__func__, ret);
+ 			}
+ 		}
+ 	}
+ 
+ done:
+ 	mutex_unlock(&voip_info.lock);
+ 
+ 	return ret;
++>>>>>>> FETCH_HEAD
  }
  
  static int msm_voip_evrc_min_max_rate_config_get(struct snd_kcontrol *kcontrol,
@@@ -1289,6 -1462,10 +1611,13 @@@ static int voip_get_rate_type(uint32_t 
  		}
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 	case MODE_G711:
+ 	case MODE_G711A:
+ 		*rate_type = rate;
+ 		break;
++>>>>>>> FETCH_HEAD
  	default:
  		pr_err("wrong mode type.\n");
  		ret = -EINVAL;
@@@ -1298,9 -1475,9 +1627,15 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int voip_get_media_type(uint32_t mode,
 +				unsigned int samp_rate,
 +				unsigned int *media_type)
++=======
+ static int voip_get_media_type(uint32_t mode, uint32_t rate_type,
+ 			       unsigned int samp_rate,
+ 			       unsigned int *media_type)
++>>>>>>> FETCH_HEAD
  {
  	int ret = 0;
  
@@@ -1331,6 -1508,13 +1666,16 @@@
  	case MODE_4GV_NW: /* EVRC-NW */
  		*media_type = VSS_MEDIA_ID_4GV_NW_MODEM;
  		break;
++<<<<<<< HEAD
++=======
+ 	case MODE_G711:
+ 	case MODE_G711A:
+ 		if (rate_type == MVS_G711A_MODE_MULAW)
+ 			*media_type = VSS_MEDIA_ID_G711_MULAW;
+ 		else
+ 			*media_type = VSS_MEDIA_ID_G711_ALAW;
+ 		break;
++>>>>>>> FETCH_HEAD
  	default:
  		pr_debug(" input mode is not supported\n");
  		ret = -EINVAL;
diff --cc sound/soc/msm/qdsp6v2/q6adm.c
index 1eb7f3a,824965f..0000000
--- a/sound/soc/msm/qdsp6v2/q6adm.c
+++ b/sound/soc/msm/qdsp6v2/q6adm.c
@@@ -43,6 -43,7 +43,10 @@@
  /* 2 is to account for module & param ID in payload */
  #define ADM_GET_PARAMETER_LENGTH  (4096 - APR_HDR_SIZE - 2 * sizeof(uint32_t))
  
++<<<<<<< HEAD
++=======
+ #define ULL_SUPPORTED_BITS_PER_SAMPLE 16
++>>>>>>> FETCH_HEAD
  #define ULL_SUPPORTED_SAMPLE_RATE 48000
  #define ULL_MAX_SUPPORTED_CHANNEL 2
  enum {
@@@ -77,6 -78,9 +81,12 @@@ struct adm_ctl 
  	void *apr;
  	atomic_t copp_id[AFE_MAX_PORTS];
  	atomic_t copp_cnt[AFE_MAX_PORTS];
++<<<<<<< HEAD
++=======
+ 	atomic_t copp_low_latency_id[AFE_MAX_PORTS];
+ 	atomic_t copp_low_latency_cnt[AFE_MAX_PORTS];
+ 	atomic_t copp_perf_mode[AFE_MAX_PORTS];
++>>>>>>> FETCH_HEAD
  	atomic_t copp_stat[AFE_MAX_PORTS];
  	wait_queue_head_t wait[AFE_MAX_PORTS];
  
@@@ -116,6 -120,11 +126,14 @@@ int srs_trumedia_open(int port_id, int 
  		sz = sizeof(struct adm_cmd_set_pp_params_inband_v5) +
  			sizeof(struct srs_trumedia_params_GLOBAL);
  		adm_params = kzalloc(sz, GFP_KERNEL);
++<<<<<<< HEAD
++=======
+ 		if (!adm_params) {
+ 			pr_err("%s, adm params memory alloc failed\n",
+ 				__func__);
+ 			return -ENOMEM;
+ 		}
++>>>>>>> FETCH_HEAD
  		adm_params->payload_size =
  			sizeof(struct srs_trumedia_params_GLOBAL) +
  			sizeof(struct adm_param_data_v5);
@@@ -140,6 -149,11 +158,14 @@@
  		sz = sizeof(struct adm_cmd_set_pp_params_inband_v5) +
  			sizeof(struct srs_trumedia_params_WOWHD);
  		adm_params = kzalloc(sz, GFP_KERNEL);
++<<<<<<< HEAD
++=======
+ 		if (!adm_params) {
+ 			pr_err("%s, adm params memory alloc failed\n",
+ 				__func__);
+ 			return -ENOMEM;
+ 		}
++>>>>>>> FETCH_HEAD
  		adm_params->payload_size =
  			sizeof(struct srs_trumedia_params_WOWHD) +
  			sizeof(struct adm_param_data_v5);
@@@ -165,6 -179,11 +191,14 @@@
  		sz = sizeof(struct adm_cmd_set_pp_params_inband_v5) +
  			sizeof(struct srs_trumedia_params_CSHP);
  		adm_params = kzalloc(sz, GFP_KERNEL);
++<<<<<<< HEAD
++=======
+ 		if (!adm_params) {
+ 			pr_err("%s, adm params memory alloc failed\n",
+ 				__func__);
+ 			return -ENOMEM;
+ 		}
++>>>>>>> FETCH_HEAD
  		adm_params->payload_size =
  			sizeof(struct srs_trumedia_params_CSHP) +
  			sizeof(struct adm_param_data_v5);
@@@ -189,6 -208,11 +223,14 @@@
  		sz = sizeof(struct adm_cmd_set_pp_params_inband_v5) +
  			sizeof(struct srs_trumedia_params_HPF);
  		adm_params = kzalloc(sz, GFP_KERNEL);
++<<<<<<< HEAD
++=======
+ 		if (!adm_params) {
+ 			pr_err("%s, adm params memory alloc failed\n",
+ 				__func__);
+ 			return -ENOMEM;
+ 		}
++>>>>>>> FETCH_HEAD
  		adm_params->payload_size =
  			sizeof(struct srs_trumedia_params_HPF) +
  			sizeof(struct adm_param_data_v5);
@@@ -209,6 -233,11 +251,14 @@@
  		sz = sizeof(struct adm_cmd_set_pp_params_inband_v5) +
  			sizeof(struct srs_trumedia_params_PEQ);
  		adm_params = kzalloc(sz, GFP_KERNEL);
++<<<<<<< HEAD
++=======
+ 		if (!adm_params) {
+ 			pr_err("%s, adm params memory alloc failed\n",
+ 				__func__);
+ 			return -ENOMEM;
+ 		}
++>>>>>>> FETCH_HEAD
  		adm_params->payload_size =
  				sizeof(struct srs_trumedia_params_PEQ) +
  				sizeof(struct adm_param_data_v5);
@@@ -231,6 -260,11 +281,14 @@@
  		sz = sizeof(struct adm_cmd_set_pp_params_inband_v5) +
  			sizeof(struct srs_trumedia_params_HL);
  		adm_params = kzalloc(sz, GFP_KERNEL);
++<<<<<<< HEAD
++=======
+ 		if (!adm_params) {
+ 			pr_err("%s, adm params memory alloc failed\n",
+ 				__func__);
+ 			return -ENOMEM;
+ 		}
++>>>>>>> FETCH_HEAD
  		adm_params->payload_size =
  			sizeof(struct srs_trumedia_params_HL) +
  			sizeof(struct adm_param_data_v5);
@@@ -472,6 -506,12 +530,15 @@@ static int32_t adm_callback(struct apr_
  {
  	uint32_t *payload;
  	int i, index;
++<<<<<<< HEAD
++=======
+ 
+ 	if (data == NULL) {
+ 		pr_err("%s: data paramter is null\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	payload = data->payload;
  
  	if (data->opcode == RESET_EVENTS) {
@@@ -483,7 -523,12 +550,16 @@@
  			for (i = 0; i < AFE_MAX_PORTS; i++) {
  				atomic_set(&this_adm.copp_id[i],
  							RESET_COPP_ID);
++<<<<<<< HEAD
 +				atomic_set(&this_adm.copp_cnt[i], 0);
++=======
+ 				atomic_set(&this_adm.copp_low_latency_id[i],
+ 							RESET_COPP_ID);
+ 				atomic_set(&this_adm.copp_cnt[i], 0);
+ 				atomic_set(&this_adm.copp_low_latency_cnt[i],
+ 						0);
+ 				atomic_set(&this_adm.copp_perf_mode[i], 0);
++>>>>>>> FETCH_HEAD
  				atomic_set(&this_adm.copp_stat[i], 0);
  			}
  			this_adm.apr = NULL;
@@@ -587,7 -632,13 +663,17 @@@
  				wake_up(&this_adm.wait[index]);
  				break;
  			}
++<<<<<<< HEAD
 +			atomic_set(&this_adm.copp_id[index], open->copp_id);
++=======
+ 			if (atomic_read(&this_adm.copp_perf_mode[index])) {
+ 				atomic_set(&this_adm.copp_low_latency_id[index],
+ 						open->copp_id);
+ 			} else {
+ 				atomic_set(&this_adm.copp_id[index],
+ 					open->copp_id);
+ 			}
++>>>>>>> FETCH_HEAD
  			atomic_set(&this_adm.copp_stat[index], 1);
  			pr_debug("%s: coppid rxed=%d\n", __func__,
  							open->copp_id);
@@@ -714,7 -765,8 +800,12 @@@ done
  	return;
  }
  
++<<<<<<< HEAD
 +static int send_adm_cal_block(int port_id, struct acdb_cal_block *aud_cal)
++=======
+ static int send_adm_cal_block(int port_id, struct acdb_cal_block *aud_cal,
+ 			      int perf_mode)
++>>>>>>> FETCH_HEAD
  {
  	s32				result = 0;
  	struct adm_cmd_set_pp_params_v5	adm_params;
@@@ -743,7 -795,14 +834,18 @@@
  	adm_params.hdr.src_port = port_id;
  	adm_params.hdr.dest_svc = APR_SVC_ADM;
  	adm_params.hdr.dest_domain = APR_DOMAIN_ADSP;
++<<<<<<< HEAD
 +	adm_params.hdr.dest_port = atomic_read(&this_adm.copp_id[index]);
++=======
+ 
+ 	if (perf_mode == LEGACY_PCM_MODE)
+ 		adm_params.hdr.dest_port =
+ 			atomic_read(&this_adm.copp_id[index]);
+ 	else
+ 		adm_params.hdr.dest_port =
+ 			atomic_read(&this_adm.copp_low_latency_id[index]);
+ 
++>>>>>>> FETCH_HEAD
  	adm_params.hdr.token = port_id;
  	adm_params.hdr.opcode = ADM_CMD_SET_PP_PARAMS_V5;
  	adm_params.payload_addr_lsw = aud_cal->cal_paddr;
@@@ -779,7 -838,7 +881,11 @@@ done
  	return result;
  }
  
++<<<<<<< HEAD
 +static void send_adm_cal(int port_id, int path)
++=======
+ static void send_adm_cal(int port_id, int path, int perf_mode)
++>>>>>>> FETCH_HEAD
  {
  	int			result = 0;
  	s32			acdb_path;
@@@ -820,7 -879,7 +926,11 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!send_adm_cal_block(port_id, &aud_cal))
++=======
+ 	if (!send_adm_cal_block(port_id, &aud_cal, perf_mode))
++>>>>>>> FETCH_HEAD
  		pr_debug("%s: Audproc cal sent for port id: %#x, path %d\n",
  			__func__, port_id, acdb_path);
  	else
@@@ -854,7 -913,7 +964,11 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!send_adm_cal_block(port_id, &aud_cal))
++=======
+ 	if (!send_adm_cal_block(port_id, &aud_cal, perf_mode))
++>>>>>>> FETCH_HEAD
  		pr_debug("%s: Audvol cal sent for port id: %#x, path %d\n",
  			__func__, port_id, acdb_path);
  	else
@@@ -1060,7 -1119,7 +1174,11 @@@ fail_cmd
  }
  
  int adm_open(int port_id, int path, int rate, int channel_mode, int topology,
++<<<<<<< HEAD
 +			bool perf_mode, uint16_t bits_per_sample)
++=======
+ 			int perf_mode, uint16_t bits_per_sample)
++>>>>>>> FETCH_HEAD
  {
  	struct adm_cmd_device_open_v5	open;
  	int ret = 0;
@@@ -1091,11 -1150,20 +1209,28 @@@
  		rtac_set_adm_handle(this_adm.apr);
  	}
  
++<<<<<<< HEAD
 +	send_adm_custom_topology(port_id);
 +
 +	/* Create a COPP if port id are not enabled */
 +	if (atomic_read(&this_adm.copp_cnt[index]) == 0) {
 +
++=======
+ 	if (perf_mode == LEGACY_PCM_MODE) {
+ 		atomic_set(&this_adm.copp_perf_mode[index], 0);
+ 		send_adm_custom_topology(port_id);
+ 	} else {
+ 		atomic_set(&this_adm.copp_perf_mode[index], 1);
+ 	}
+ 
+ 	/* Create a COPP if port id are not enabled */
+ 	if ((perf_mode == LEGACY_PCM_MODE &&
+ 		(atomic_read(&this_adm.copp_cnt[index]) == 0)) ||
+ 		(perf_mode != LEGACY_PCM_MODE &&
+ 		(atomic_read(&this_adm.copp_low_latency_cnt[index]) == 0))) {
+ 		pr_debug("%s:opening ADM: perf_mode: %d\n", __func__,
+ 			perf_mode);
++>>>>>>> FETCH_HEAD
  		open.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
  				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
  		open.hdr.pkt_size = sizeof(open);
@@@ -1107,12 -1175,12 +1242,21 @@@
  		open.hdr.dest_port = tmp_port;
  		open.hdr.token = port_id;
  		open.hdr.opcode = ADM_CMD_DEVICE_OPEN_V5;
++<<<<<<< HEAD
 +		open.flags = 0x00;
 +		if (perf_mode) {
 +			open.flags |= ADM_LOW_LATENCY_DEVICE_SESSION;
 +		} else {
 +			open.flags |= ADM_LEGACY_DEVICE_SESSION;
 +		}
++=======
+ 		if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE)
+ 			open.flags = ADM_ULTRA_LOW_LATENCY_DEVICE_SESSION;
+ 		else if (perf_mode == LOW_LATENCY_PCM_MODE)
+ 			open.flags = ADM_LOW_LATENCY_DEVICE_SESSION;
+ 		else
+ 			open.flags = ADM_LEGACY_DEVICE_SESSION;
++>>>>>>> FETCH_HEAD
  
  		open.mode_of_operation = path;
  		open.endpoint_id_1 = tmp_port;
@@@ -1151,8 -1219,21 +1295,26 @@@
          pr_err("add topo flag value %d \n", add_topo_flag);
  #endif
  
++<<<<<<< HEAD
 +		open.dev_num_channel = channel_mode & 0x00FF;
 +		open.bit_width = bits_per_sample;
++=======
+ 		if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE) {
+ 			open.topology_id = NULL_COPP_TOPOLOGY;
+ 			rate = ULL_SUPPORTED_SAMPLE_RATE;
+ 			open.bit_width = ULL_SUPPORTED_BITS_PER_SAMPLE;
+ 			if(channel_mode > ULL_MAX_SUPPORTED_CHANNEL)
+ 				channel_mode = ULL_MAX_SUPPORTED_CHANNEL;
+ 		} else if (perf_mode == LOW_LATENCY_PCM_MODE) {
+ 			if ((open.topology_id == DOLBY_ADM_COPP_TOPOLOGY_ID) ||
+ 			    (open.topology_id == SRS_TRUMEDIA_TOPOLOGY_ID))
+ 				open.topology_id = DEFAULT_COPP_TOPOLOGY;
+ 		}
+ 		open.dev_num_channel = channel_mode & 0x00FF;
+ 		open.bit_width = bits_per_sample;
+ 		WARN_ON(perf_mode == ULTRA_LOW_LATENCY_PCM_MODE &&
+ 							(rate != 48000));
++>>>>>>> FETCH_HEAD
  		open.sample_rate  = rate;
  		memset(open.dev_channel_mapping, 0, 8);
  
@@@ -1177,12 -1258,12 +1339,21 @@@
  			open.dev_channel_mapping[3] = PCM_CHANNEL_LB;
  			open.dev_channel_mapping[4] = PCM_CHANNEL_RB;
  		} else if (channel_mode == 6) {
++<<<<<<< HEAD
 +			open.dev_channel_mapping[0] = PCM_CHANNEL_FC;
 +			open.dev_channel_mapping[1] = PCM_CHANNEL_FL;
 +			open.dev_channel_mapping[2] = PCM_CHANNEL_LB;
 +			open.dev_channel_mapping[3] = PCM_CHANNEL_FR;
 +			open.dev_channel_mapping[4] = PCM_CHANNEL_RB;
 +			open.dev_channel_mapping[5] = PCM_CHANNEL_LFE;
++=======
+ 			open.dev_channel_mapping[0] = PCM_CHANNEL_FL;
+ 			open.dev_channel_mapping[1] = PCM_CHANNEL_FR;
+ 			open.dev_channel_mapping[2] = PCM_CHANNEL_LFE;
+ 			open.dev_channel_mapping[3] = PCM_CHANNEL_FC;
+ 			open.dev_channel_mapping[4] = PCM_CHANNEL_LS;
+ 			open.dev_channel_mapping[5] = PCM_CHANNEL_RS;
++>>>>>>> FETCH_HEAD
  		} else if (channel_mode == 8) {
  			open.dev_channel_mapping[0] = PCM_CHANNEL_FL;
  			open.dev_channel_mapping[1] = PCM_CHANNEL_FR;
@@@ -1227,7 -1308,16 +1398,20 @@@
  			goto fail_cmd;
  		}
  	}
++<<<<<<< HEAD
 +	atomic_inc(&this_adm.copp_cnt[index]);
++=======
+ 	if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE ||
+ 			perf_mode == LOW_LATENCY_PCM_MODE) {
+ 		atomic_inc(&this_adm.copp_low_latency_cnt[index]);
+ 		pr_debug("%s: index: %d coppid: %d", __func__, index,
+ 			atomic_read(&this_adm.copp_low_latency_id[index]));
+ 	} else {
+ 		atomic_inc(&this_adm.copp_cnt[index]);
+ 		pr_debug("%s: index: %d coppid: %d", __func__, index,
+ 			atomic_read(&this_adm.copp_id[index]));
+ 	}
++>>>>>>> FETCH_HEAD
  	return 0;
  
  fail_cmd:
@@@ -1640,7 -1730,7 +1824,11 @@@ int q6adm_audio_client_buf_alloc(unsign
  } /* q6adm_audio_client_buf_alloc */
  #endif
  int adm_multi_ch_copp_open(int port_id, int path, int rate, int channel_mode,
++<<<<<<< HEAD
 +			int topology, bool perf_mode, uint16_t bits_per_sample)
++=======
+ 			int topology, int perf_mode, uint16_t bits_per_sample)
++>>>>>>> FETCH_HEAD
  {
  	int ret = 0;
  
@@@ -1651,7 -1741,7 +1839,11 @@@
  }
  
  int adm_matrix_map(int session_id, int path, int num_copps,
++<<<<<<< HEAD
 +			unsigned int *port_id, int copp_id, bool perf_mode)
++=======
+ 			unsigned int *port_id, int copp_id, int perf_mode)
++>>>>>>> FETCH_HEAD
  {
  	struct adm_cmd_matrix_map_routings_v5	*route;
  	struct adm_session_map_node_v5 *node;
@@@ -1690,7 -1780,13 +1882,17 @@@
  	route->hdr.src_port = copp_id;
  	route->hdr.dest_svc = APR_SVC_ADM;
  	route->hdr.dest_domain = APR_DOMAIN_ADSP;
++<<<<<<< HEAD
 +	route->hdr.dest_port = atomic_read(&this_adm.copp_id[index]);
++=======
+ 	if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE ||
+ 			perf_mode == LOW_LATENCY_PCM_MODE) {
+ 		route->hdr.dest_port =
+ 			atomic_read(&this_adm.copp_low_latency_id[index]);
+ 	} else {
+ 		route->hdr.dest_port = atomic_read(&this_adm.copp_id[index]);
+ 	}
++>>>>>>> FETCH_HEAD
  	route->hdr.token = copp_id;
  	route->hdr.opcode = ADM_CMD_MATRIX_MAP_ROUTINGS_V5;
  	route->num_sessions = 1;
@@@ -1722,14 -1818,19 +1924,30 @@@
  		tmp = q6audio_get_port_index(port_id[i]);
  
  
++<<<<<<< HEAD
 +		if (tmp >= 0 && tmp < AFE_MAX_PORTS)
 +			copps_list[i] =
 +					atomic_read(&this_adm.copp_id[tmp]);
 +		else
 +			continue;
 +		pr_debug("%s: port_id[%#x]: %d, index: %d act coppid[0x%x]\n",
 +			__func__, i, port_id[i], tmp,
 +			atomic_read(&this_adm.copp_id[tmp]));
++=======
+ 		if (tmp >= 0 && tmp < AFE_MAX_PORTS) {
+ 			if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE ||
+ 					perf_mode == LOW_LATENCY_PCM_MODE)
+ 				copps_list[i] =
+ 				atomic_read(&this_adm.copp_low_latency_id[tmp]);
+ 			else
+ 				copps_list[i] =
+ 					atomic_read(&this_adm.copp_id[tmp]);
+ 		}
+ 		else
+ 			continue;
+ 		pr_debug("%s: port_id[%#x]: %d, index: %d act coppid[0x%x]\n",
+ 			__func__, i, port_id[i], tmp, copps_list[i]);
++>>>>>>> FETCH_HEAD
  	}
  	atomic_set(&this_adm.copp_stat[index], 0);
  
@@@ -1749,19 -1850,29 +1967,45 @@@
  		ret = -EINVAL;
  		goto fail_cmd;
  	}
++<<<<<<< HEAD
 +	for (i = 0; i < num_copps; i++)
 +		send_adm_cal(port_id[i], path);
 +
 +	for (i = 0; i < num_copps; i++) {
 +		int tmp;
 +		tmp = afe_get_port_index(port_id[i]);
 +		if (tmp >= 0 && tmp < AFE_MAX_PORTS)
 +			rtac_add_adm_device(port_id[i],
 +				atomic_read(&this_adm.copp_id[tmp]),
 +				path, session_id);
 +		else
 +			pr_debug("%s: Invalid port index %d",
 +				__func__, tmp);
++=======
+ 
+ 	if (perf_mode != ULTRA_LOW_LATENCY_PCM_MODE) {
+ 		for (i = 0; i < num_copps; i++)
+ 			send_adm_cal(port_id[i], path, perf_mode);
+ 
+ 		for (i = 0; i < num_copps; i++) {
+ 			int tmp, copp_id;
+ 			tmp = afe_get_port_index(port_id[i]);
+ 			if (tmp >= 0 && tmp < AFE_MAX_PORTS) {
+ 				if (perf_mode == LEGACY_PCM_MODE)
+ 					copp_id = atomic_read(
+ 					&this_adm.copp_id[tmp]);
+ 				else
+ 					copp_id = atomic_read(
+ 					&this_adm.copp_low_latency_id[tmp]);
+ 				rtac_add_adm_device(port_id[i],
+ 						copp_id, path, session_id);
+ 				pr_debug("%s, copp_id: %d\n",
+ 							__func__, copp_id);
+ 			} else
+ 				pr_debug("%s: Invalid port index %d",
+ 							__func__, tmp);
+ 		}
++>>>>>>> FETCH_HEAD
  	}
  
  fail_cmd:
@@@ -1915,8 -2026,10 +2159,15 @@@ fail_cmd
  	return ret;
  }
  
++<<<<<<< HEAD
++int adm_get_copp_id(int port_index)
++{
++=======
+ #ifdef CONFIG_RTAC
  int adm_get_copp_id(int port_index)
  {
+ 	int copp_id;
++>>>>>>> FETCH_HEAD
  	pr_debug("%s\n", __func__);
  
  	if (port_index < 0) {
@@@ -1924,8 -2037,35 +2175,40 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	return atomic_read(&this_adm.copp_id[port_index]);
 +}
++=======
+ 	copp_id = atomic_read(&this_adm.copp_id[port_index]);
+ 	if (copp_id == RESET_COPP_ID)
+ 		copp_id = atomic_read(
+ 			&this_adm.copp_low_latency_id[port_index]);
+ 	return copp_id;
+ }
+ 
+ int adm_get_lowlatency_copp_id(int port_index)
+ {
+ 	pr_debug("%s\n", __func__);
+ 
+ 	if (port_index < 0) {
+ 		pr_err("%s: invalid port_id = %d\n", __func__, port_index);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return atomic_read(&this_adm.copp_low_latency_id[port_index]);
+ }
+ #else
+ int adm_get_copp_id(int port_index)
+ {
+ 	return -EINVAL;
+ }
+ 
+ int adm_get_lowlatency_copp_id(int port_index)
+ {
+ 	return -EINVAL;
+ }
+ #endif /* #ifdef CONFIG_RTAC */
++>>>>>>> FETCH_HEAD
  
  void adm_ec_ref_rx_id(int port_id)
  {
@@@ -1933,12 -2073,14 +2216,21 @@@
  	pr_debug("%s ec_ref_rx:%d", __func__, this_adm.ec_ref_rx);
  }
  
++<<<<<<< HEAD
 +int adm_close(int port_id, bool perf_mode)
++=======
+ int adm_close(int port_id, int perf_mode)
++>>>>>>> FETCH_HEAD
  {
  	struct apr_hdr close;
  
  	int ret = 0;
  	int index = 0;
++<<<<<<< HEAD
++=======
+ 	int copp_id = RESET_COPP_ID;
+ 
++>>>>>>> FETCH_HEAD
  	port_id = q6audio_convert_virtual_to_portid(port_id);
  
  	index = q6audio_get_port_index(port_id);
@@@ -1947,13 -2089,26 +2239,36 @@@
  
  	pr_debug("%s port_id=%#x index %d\n", __func__, port_id, index);
  
++<<<<<<< HEAD
 +	if (!(atomic_read(&this_adm.copp_cnt[index]))) {
 +		pr_err("%s: copp count for port[%#x]is 0\n", __func__, port_id);
 +
 +		goto fail_cmd;
 +	}
 +	atomic_dec(&this_adm.copp_cnt[index]);
 +	if (!(atomic_read(&this_adm.copp_cnt[index]))) {
++=======
+ 	if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE ||
+ 				perf_mode == LOW_LATENCY_PCM_MODE) {
+ 		if (!(atomic_read(&this_adm.copp_low_latency_cnt[index]))) {
+ 			pr_err("%s: copp count for port[%#x]is 0\n", __func__,
+ 				port_id);
+ 			goto fail_cmd;
+ 		}
+ 		atomic_dec(&this_adm.copp_low_latency_cnt[index]);
+ 	} else {
+ 		if (!(atomic_read(&this_adm.copp_cnt[index]))) {
+ 			pr_err("%s: copp count for port[%#x]is 0\n", __func__,
+ 				port_id);
+ 			goto fail_cmd;
+ 		}
+ 		atomic_dec(&this_adm.copp_cnt[index]);
+ 	}
+ 	if ((perf_mode == LEGACY_PCM_MODE &&
+ 		!(atomic_read(&this_adm.copp_cnt[index]))) ||
+ 		((perf_mode != LEGACY_PCM_MODE) &&
+ 		!(atomic_read(&this_adm.copp_low_latency_cnt[index])))) {
++>>>>>>> FETCH_HEAD
  
  		close.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
  			APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
@@@ -1963,20 -2118,39 +2278,56 @@@
  		close.src_port = port_id;
  		close.dest_svc = APR_SVC_ADM;
  		close.dest_domain = APR_DOMAIN_ADSP;
++<<<<<<< HEAD
 +		close.dest_port = atomic_read(&this_adm.copp_id[index]);
 +		close.token = port_id;
 +		close.opcode = ADM_CMD_DEVICE_CLOSE_V5;
 +
 +		atomic_set(&this_adm.copp_id[index], RESET_COPP_ID);
 +		atomic_set(&this_adm.copp_stat[index], 0);
 +
 +
 +		pr_debug("%s:coppid %d portid=%#x index=%d coppcnt=%d\n",
 +				__func__,
 +				atomic_read(&this_adm.copp_id[index]),
 +				port_id, index,
 +				atomic_read(&this_adm.copp_cnt[index]));
 +
++=======
+ 		if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE ||
+ 				perf_mode == LOW_LATENCY_PCM_MODE)
+ 			close.dest_port =
+ 			     atomic_read(&this_adm.copp_low_latency_id[index]);
+ 		else
+ 			close.dest_port = atomic_read(&this_adm.copp_id[index]);
+ 		close.token = port_id;
+ 		close.opcode = ADM_CMD_DEVICE_CLOSE_V5;
+ 
+ 		atomic_set(&this_adm.copp_stat[index], 0);
+ 
+ 		if (perf_mode == ULTRA_LOW_LATENCY_PCM_MODE ||
+ 				perf_mode == LOW_LATENCY_PCM_MODE) {
+ 			copp_id = atomic_read(
+ 				&this_adm.copp_low_latency_id[index]);
+ 			pr_debug("%s:coppid %d portid=%#x index=%d coppcnt=%d\n",
+ 				__func__,
+ 				copp_id,
+ 				port_id, index,
+ 				atomic_read(
+ 					&this_adm.copp_low_latency_cnt[index]));
+ 			atomic_set(&this_adm.copp_low_latency_id[index],
+ 				RESET_COPP_ID);
+ 		} else {
+ 			copp_id = atomic_read(&this_adm.copp_id[index]);
+ 			pr_debug("%s:coppid %d portid=%#x index=%d coppcnt=%d\n",
+ 				__func__,
+ 				copp_id,
+ 				port_id, index,
+ 				atomic_read(&this_adm.copp_cnt[index]));
+ 			atomic_set(&this_adm.copp_id[index],
+ 				RESET_COPP_ID);
+ 		}
++>>>>>>> FETCH_HEAD
  		ret = apr_send_pkt(this_adm.apr, (uint32_t *)&close);
  		if (ret < 0) {
  			pr_err("%s ADM close failed\n", __func__);
@@@ -1993,8 -2167,11 +2344,16 @@@
  			ret = -EINVAL;
  			goto fail_cmd;
  		}
++<<<<<<< HEAD
 +
 +		rtac_remove_adm_device(port_id);
++=======
+ 	}
+ 
+ 	if (perf_mode != ULTRA_LOW_LATENCY_PCM_MODE) {
+ 		pr_debug("%s: remove adm device from rtac\n", __func__);
+ 		rtac_remove_adm_device(port_id, copp_id);
++>>>>>>> FETCH_HEAD
  	}
  
  fail_cmd:
@@@ -2010,8 -2187,11 +2369,16 @@@ static int __init adm_init(void
  
  	for (i = 0; i < AFE_MAX_PORTS; i++) {
  		atomic_set(&this_adm.copp_id[i], RESET_COPP_ID);
++<<<<<<< HEAD
++		atomic_set(&this_adm.copp_cnt[i], 0);
++		atomic_set(&this_adm.copp_stat[i], 0);
++=======
+ 		atomic_set(&this_adm.copp_low_latency_id[i], RESET_COPP_ID);
  		atomic_set(&this_adm.copp_cnt[i], 0);
+ 		atomic_set(&this_adm.copp_low_latency_cnt[i], 0);
  		atomic_set(&this_adm.copp_stat[i], 0);
+ 		atomic_set(&this_adm.copp_perf_mode[i], 0);
++>>>>>>> FETCH_HEAD
  		init_waitqueue_head(&this_adm.wait[i]);
  	}
  	return 0;
diff --cc sound/soc/msm/qdsp6v2/q6afe.c
index acb8e70,d1cdab5..0000000
--- a/sound/soc/msm/qdsp6v2/q6afe.c
+++ b/sound/soc/msm/qdsp6v2/q6afe.c
@@@ -55,6 -55,7 +55,10 @@@ struct afe_ctl 
  	int vi_tx_port;
  	uint32_t afe_sample_rates[AFE_MAX_PORTS];
  	struct aanc_data aanc_info;
++<<<<<<< HEAD
++=======
+ 	struct mutex afe_cmd_lock;
++>>>>>>> FETCH_HEAD
  };
  
  static atomic_t afe_ports_mad_type[SLIMBUS_PORT_LAST - SLIMBUS_0_RX];
@@@ -436,8 -437,9 +440,14 @@@ static void afe_send_cal_block(int32_t 
  	}
  
  	index = q6audio_get_port_index(port_id);
++<<<<<<< HEAD
 +	if (index < 0) {
 +		pr_debug("%s: AFE port index invalid!\n", __func__);
++=======
+ 	if (index < 0 || index > AFE_MAX_PORTS) {
+ 		pr_debug("%s: AFE port index[%d] invalid!\n",
+ 				__func__, index);
++>>>>>>> FETCH_HEAD
  		goto done;
  	}
  
@@@ -652,8 -654,9 +662,14 @@@ static int afe_send_hw_delay(u16 port_i
  		goto fail_cmd;
  	}
  	index = q6audio_get_port_index(port_id);
++<<<<<<< HEAD
 +	if (index < 0) {
 +		pr_debug("%s: AFE port index invalid!\n", __func__);
++=======
+ 	if (index < 0 || index > AFE_MAX_PORTS) {
+ 		pr_debug("%s: AFE port index[%d] invalid!\n",
+ 				__func__, index);
++>>>>>>> FETCH_HEAD
  		goto fail_cmd;
  	}
  
@@@ -1312,6 -1315,7 +1328,10 @@@ int afe_port_start(u16 port_id, union a
  	if (IS_ERR_VALUE(ret))
  		return ret;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  	afe_send_cal(port_id);
  	afe_send_hw_delay(port_id, rate);
  
@@@ -1321,16 -1325,17 +1341,28 @@@
  		 mad_type);
  	if (mad_type != MAD_HW_NONE && mad_type != MAD_SW_AUDIO) {
  		if (!afe_has_config(AFE_CDC_REGISTERS_CONFIG) ||
++<<<<<<< HEAD
 +		    !afe_has_config(AFE_SLIMBUS_SLAVE_CONFIG)) {
 +			pr_err("%s: AFE isn't configured yet for HW MAD\n",
 +			       __func__);
 +			return -EINVAL;
++=======
+ 			!afe_has_config(AFE_SLIMBUS_SLAVE_CONFIG)) {
+ 				pr_err("%s: AFE isn't configured yet for\n"
+ 					   "HW MAD try Again\n", __func__);
+ 				ret = -EAGAIN;
+ 				goto fail_cmd;
++>>>>>>> FETCH_HEAD
  		}
  		ret = afe_turn_onoff_hw_mad(mad_type, true);
  		if (ret) {
  			pr_err("%s: afe_turn_onoff_hw_mad failed %d\n",
  			       __func__, ret);
++<<<<<<< HEAD
 +			return ret;
++=======
+ 			goto fail_cmd;
++>>>>>>> FETCH_HEAD
  		}
  	}
  
@@@ -1448,9 -1453,10 +1480,16 @@@
  		ret = -EINVAL;
  		goto fail_cmd;
  	}
++<<<<<<< HEAD
 +	return afe_send_cmd_port_start(port_id);
 +
 +fail_cmd:
++=======
+ 	ret = afe_send_cmd_port_start(port_id);
+ 
+ fail_cmd:
+ 	mutex_unlock(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  	return ret;
  }
  
@@@ -1549,12 -1555,13 +1588,22 @@@ int afe_open(u16 port_id
  	if (ret != 0)
  		return ret;
  
++<<<<<<< HEAD
 +	if (q6audio_validate_port(port_id) < 0) {
 +		pr_err("%s: Failed : Invalid Port id = %d\n", __func__,
 +				port_id);
 +		ret = -EINVAL;
 +		goto fail_cmd;
 +	}
++=======
+ 	ret = q6audio_validate_port(port_id);
+ 	if (ret < 0) {
+ 		pr_err("%s: Failed : Invalid Port id = 0x%x ret %d\n",
+ 			__func__, port_id, ret);
+ 		return -EINVAL;
+ 	}
+ 	mutex_lock(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  
  	config.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
  				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
@@@ -1646,6 -1653,7 +1695,10 @@@
  	}
  
  fail_cmd:
++<<<<<<< HEAD
++=======
+ 	mutex_unlock(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  	return ret;
  }
  
@@@ -2015,13 -2023,19 +2068,29 @@@ int afe_memory_map(u32 dma_addr_p, u32 
  {
  	int ret = 0;
  
++<<<<<<< HEAD
 +	ac->mem_map_handle = 0;
 +	ret = afe_cmd_memory_map(dma_addr_p, dma_buf_sz);
 +	if (ret < 0) {
 +		pr_err("%s: afe_cmd_memory_map failed\n", __func__);
 +		return ret;
 +	}
 +	ac->mem_map_handle = this_afe.mmap_handle;
++=======
+ 	mutex_lock(&this_afe.afe_cmd_lock);
+ 	ac->mem_map_handle = 0;
+ 	ret = afe_cmd_memory_map(dma_addr_p, dma_buf_sz);
+ 	if (ret < 0) {
+ 		pr_err("%s: afe_cmd_memory_map failed. error = %d\n",
+ 		       __func__, ret);
+ 
+ 		mutex_unlock(&this_afe.afe_cmd_lock);
+ 		return ret;
+ 	}
+ 	ac->mem_map_handle = this_afe.mmap_handle;
+ 	mutex_unlock(&this_afe.afe_cmd_lock);
+ 
++>>>>>>> FETCH_HEAD
  	return ret;
  }
  
@@@ -3069,6 -3083,7 +3138,10 @@@ int afe_set_lpass_internal_digital_code
  	if (ret != 0)
  		return ret;
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  	clk_cfg.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
  				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
  	clk_cfg.hdr.pkt_size = sizeof(clk_cfg);
@@@ -3088,8 -3103,8 +3161,13 @@@
  	clk_cfg.pdata.param_size =  sizeof(clk_cfg.clk_cfg);
  	clk_cfg.clk_cfg = *cfg;
  
++<<<<<<< HEAD
 +	pr_debug("%s: Minor version =%x clk val = %d\n"
 +		 "clk root = %x resrv = %x port id = %x\n",
++=======
+ 	pr_debug("%s: Minor version =0x%x clk val = %d\n"
+ 		 "clk root = 0x%x resrv = 0x%x port id = 0x%x\n",
++>>>>>>> FETCH_HEAD
  		 __func__, cfg->i2s_cfg_minor_version,
  		 cfg->clk_val, cfg->clk_root, cfg->reserved,
  		 q6audio_get_port_id(port_id));
@@@ -3260,6 -3275,7 +3338,10 @@@ static int __init afe_init(void
  	this_afe.dtmf_gen_rx_portid = -1;
  	this_afe.mmap_handle = 0;
  	this_afe.vi_tx_port = -1;
++<<<<<<< HEAD
++=======
+ 	mutex_init(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  	for (i = 0; i < AFE_MAX_PORTS; i++)
  		init_waitqueue_head(&this_afe.wait[i]);
  
@@@ -3280,6 -3296,7 +3362,10 @@@ static void __exit afe_exit(void
  		if (handle != 0)
  			afe_cmd_memory_unmap_nowait(handle);
  	}
++<<<<<<< HEAD
++=======
+ 	mutex_destroy(&this_afe.afe_cmd_lock);
++>>>>>>> FETCH_HEAD
  }
  
  device_initcall(afe_init);
diff --cc sound/soc/msm/qdsp6v2/q6asm.c
index 0f7e165,73b458e..0000000
--- a/sound/soc/msm/qdsp6v2/q6asm.c
+++ b/sound/soc/msm/qdsp6v2/q6asm.c
@@@ -1,5 -1,5 +1,9 @@@
  /*
++<<<<<<< HEAD
 + * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+  * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   * Author: Brian Swetland <swetland@google.com>
   *
   * This software is licensed under the terms of the GNU General Public
@@@ -25,7 -25,6 +29,10 @@@
  #include <linux/slab.h>
  #include <linux/msm_audio.h>
  
++<<<<<<< HEAD
 +#include <linux/memory_alloc.h>
++=======
++>>>>>>> FETCH_HEAD
  #include <linux/debugfs.h>
  #include <linux/time.h>
  #include <linux/atomic.h>
@@@ -39,6 -38,7 +46,10 @@@
  
  #include <sound/apr_audio-v2.h>
  #include <sound/q6asm-v2.h>
++<<<<<<< HEAD
++=======
+ #include <sound/q6audio-v2.h>
++>>>>>>> FETCH_HEAD
  
  #include "audio_acdb.h"
  
@@@ -80,6 -80,7 +91,10 @@@ static void q6asm_reset_buf_state(struc
  static int q6asm_map_channels(u8 *channel_mapping, uint32_t channels);
  void *q6asm_mmap_apr_reg(void);
  
++<<<<<<< HEAD
++=======
+ static int q6asm_is_valid_session(struct apr_client_data *data, void *priv);
++>>>>>>> FETCH_HEAD
  
  /* for ASM custom topology */
  static struct audio_buffer common_buf[2];
@@@ -131,6 -132,10 +146,13 @@@ static int audio_output_latency_dbgfs_o
  static ssize_t audio_output_latency_dbgfs_read(struct file *file,
  				char __user *buf, size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
++=======
+ 	if (out_buffer == NULL) {
+ 		pr_err("%s: out_buffer is null\n", __func__);
+ 		return 0;
+ 	}
++>>>>>>> FETCH_HEAD
  	snprintf(out_buffer, OUT_BUFFER_SIZE, "%ld,%ld,%ld,%ld,%ld,%ld,",\
  		out_cold_tv.tv_sec, out_cold_tv.tv_usec, out_warm_tv.tv_sec,\
  		out_warm_tv.tv_usec, out_cont_tv.tv_sec, out_cont_tv.tv_usec);
@@@ -176,6 -181,10 +198,13 @@@ static int audio_input_latency_dbgfs_op
  static ssize_t audio_input_latency_dbgfs_read(struct file *file,
  				char __user *buf, size_t count, loff_t *ppos)
  {
++<<<<<<< HEAD
++=======
+ 	if (in_buffer == NULL) {
+ 		pr_err("%s: in_buffer is null\n", __func__);
+ 		return 0;
+ 	}
++>>>>>>> FETCH_HEAD
  	snprintf(in_buffer, IN_BUFFER_SIZE, "%ld,%ld,",\
  				in_cont_tv.tv_sec, in_cont_tv.tv_usec);
  	return  simple_read_from_buffer(buf, IN_BUFFER_SIZE, ppos,
@@@ -291,17 -300,38 +320,52 @@@ static void config_debug_fs_write(struc
  static void config_debug_fs_init(void)
  {
  	out_buffer = kmalloc(OUT_BUFFER_SIZE, GFP_KERNEL);
++<<<<<<< HEAD
 +	out_dentry = debugfs_create_file("audio_out_latency_measurement_node",\
 +				S_IRUGO | S_IWUSR | S_IWGRP,\
 +				NULL, NULL, &audio_output_latency_debug_fops);
 +	if (IS_ERR(out_dentry))
 +		pr_err("debugfs_create_file failed\n");
 +	in_buffer = kmalloc(IN_BUFFER_SIZE, GFP_KERNEL);
 +	in_dentry = debugfs_create_file("audio_in_latency_measurement_node",\
 +				S_IRUGO | S_IWUSR | S_IWGRP,\
 +				NULL, NULL, &audio_input_latency_debug_fops);
 +	if (IS_ERR(in_dentry))
 +		pr_err("debugfs_create_file failed\n");
++=======
+ 	if (out_buffer == NULL) {
+ 		pr_err("%s: kmalloc() for out_buffer failed\n", __func__);
+ 		goto outbuf_fail;
+ 	}
+ 	in_buffer = kmalloc(IN_BUFFER_SIZE, GFP_KERNEL);
+ 	if (in_buffer == NULL) {
+ 		pr_err("%s: kmalloc() for in_buffer failed\n", __func__);
+ 		goto inbuf_fail;
+ 	}
+ 	out_dentry = debugfs_create_file("audio_out_latency_measurement_node",\
+ 				S_IRUGO | S_IWUSR | S_IWGRP,\
+ 				NULL, NULL, &audio_output_latency_debug_fops);
+ 	if (IS_ERR(out_dentry)) {
+ 		pr_err("%s: debugfs_create_file failed\n", __func__);
+ 		goto file_fail;
+ 	}
+ 	in_dentry = debugfs_create_file("audio_in_latency_measurement_node",\
+ 				S_IRUGO | S_IWUSR | S_IWGRP,\
+ 				NULL, NULL, &audio_input_latency_debug_fops);
+ 	if (IS_ERR(in_dentry)) {
+ 		pr_err("%s: debugfs_create_file failed\n", __func__);
+ 		goto file_fail;
+ 	}
+ 	return;
+ file_fail:
+ 	kfree(in_buffer);
+ inbuf_fail:
+ 	kfree(out_buffer);
+ outbuf_fail:
+ 	in_buffer = NULL;
+ 	out_buffer = NULL;
+ 	return;
++>>>>>>> FETCH_HEAD
  }
  #else
  static void config_debug_fs_write(struct audio_buffer *ab)
@@@ -334,7 -364,6 +398,8 @@@ static void config_debug_fs_init(void
  static int q6asm_session_alloc(struct audio_client *ac)
  {
  	int n;
++<<<<<<< HEAD
 +	mutex_lock(&session_lock);
  	for (n = 1; n <= SESSION_MAX; n++) {
  		if (!session[n]) {
  			session[n] = ac;
@@@ -342,7 -370,6 +407,15 @@@
  			return n;
  		}
  	}
 +	mutex_unlock(&session_lock);
++=======
++	for (n = 1; n <= SESSION_MAX; n++) {
++		if (!session[n]) {
++			session[n] = ac;
++			return n;
++		}
++	}
++>>>>>>> FETCH_HEAD
  	return -ENOMEM;
  }
  
@@@ -350,11 -377,9 +423,17 @@@ static void q6asm_session_free(struct a
  {
  	pr_debug("%s: sessionid[%d]\n", __func__, ac->session);
  	rtac_remove_popp_from_adm_devices(ac->session);
++<<<<<<< HEAD
 +	mutex_lock(&session_lock);
 +	session[ac->session] = 0;
 +	mutex_unlock(&session_lock);
 +	ac->session = 0;
 +	ac->perf_mode = 0;
++=======
+ 	session[ac->session] = 0;
+ 	ac->session = 0;
+ 	ac->perf_mode = LEGACY_PCM_MODE;
++>>>>>>> FETCH_HEAD
  	ac->fptr_cache_ops = NULL;
  	return;
  }
@@@ -367,67 -392,59 +446,120 @@@ void send_asm_custom_topology(struct au
  	struct list_head		*ptr, *next;
  	int				result;
  	int				size = 4096;
++<<<<<<< HEAD
 +	get_asm_custom_topology(&cal_block);
 +	if (cal_block.cal_size == 0) {
 +		pr_debug("%s: no cal to send addr= 0x%x\n",
 +				__func__, cal_block.cal_paddr);
 +		goto done;
 +	}
 +
 +	if (set_custom_topology) {
 +		if (common_client.mmap_apr == NULL) {
 +			common_client.mmap_apr = q6asm_mmap_apr_reg();
 +			common_client.apr = common_client.mmap_apr;
 +			if (common_client.mmap_apr == NULL) {
 +				pr_err("%s: q6asm_mmap_apr_reg failed\n",
 +					__func__);
 +				result = -EPERM;
 +				goto done;
 +			}
 +		}
 +		/* Only call this once */
 +		set_custom_topology = 0;
 +
 +		/* Use first asm buf to map memory */
 +		if (common_client.port[IN].buf == NULL) {
 +			pr_err("%s: common buf is NULL\n",
 +				__func__);
 +			goto done;
 +		}
 +		common_client.port[IN].buf->phys = cal_block.cal_paddr;
 +
 +		result = q6asm_memory_map_regions(&common_client,
 +							IN, size, 1, 1);
 +		if (result < 0) {
 +			pr_err("%s: mmap did not work! addr = 0x%x, size = %d\n",
 +				__func__, cal_block.cal_paddr,
 +				cal_block.cal_size);
 +			goto done;
 +		}
 +
 +		list_for_each_safe(ptr, next,
 +				&common_client.port[IN].mem_map_handle) {
 +			buf_node = list_entry(ptr, struct asm_buffer_node,
 +						list);
 +			if (buf_node->buf_addr_lsw == cal_block.cal_paddr) {
 +				topology_map_handle =  buf_node->mmap_hdl;
 +				break;
 +			}
 +		}
 +
 +		result = q6asm_mmap_apr_dereg();
 +		if (result < 0) {
 +			pr_err("%s: q6asm_mmap_apr_dereg failed, err %d\n",
 +				__func__, result);
 +		} else {
 +			common_client.mmap_apr = NULL;
++=======
+ 
+ 	if (!set_custom_topology)
+ 		return;
+ 
+ 	get_asm_custom_topology(&cal_block);
+ 	if (cal_block.cal_size == 0) {
+ 		pr_debug("%s: no cal to send addr= 0x%pa\n",
+ 				__func__, &cal_block.cal_paddr);
+ 		return;
+ 	}
+ 
+ 	common_client.mmap_apr = q6asm_mmap_apr_reg();
+ 	common_client.apr = common_client.mmap_apr;
+ 	if (common_client.mmap_apr == NULL) {
+ 		pr_err("%s: q6asm_mmap_apr_reg failed\n",
+ 			__func__);
+ 		result = -EPERM;
+ 		goto mmap_fail;
+ 	}
+ 	/* Only call this once */
+ 	set_custom_topology = 0;
+ 
+ 	/* Use first asm buf to map memory */
+ 	if (common_client.port[IN].buf == NULL) {
+ 		pr_err("%s: common buf is NULL\n",
+ 			__func__);
+ 		goto err_map;
+ 	}
+ 	common_client.port[IN].buf->phys = cal_block.cal_paddr;
+ 
+ 	result = q6asm_memory_map_regions(&common_client,
+ 						IN, size, 1, 1);
+ 	if (result < 0) {
+ 		pr_err("%s: mmap did not work! addr = 0x%pa, size = %zd\n",
+ 			__func__, &cal_block.cal_paddr,
+ 			cal_block.cal_size);
+ 		goto err_map;
+ 	}
+ 
+ 	list_for_each_safe(ptr, next,
+ 			&common_client.port[IN].mem_map_handle) {
+ 		buf_node = list_entry(ptr, struct asm_buffer_node,
+ 					list);
+ 		if (buf_node->buf_addr_lsw == cal_block.cal_paddr) {
+ 			topology_map_handle =  buf_node->mmap_hdl;
+ 			break;
++>>>>>>> FETCH_HEAD
  		}
  	}
  
  	q6asm_add_hdr_custom_topology(ac, &asm_top.hdr,
  				      APR_PKT_SIZE(APR_HDR_SIZE,
  					sizeof(asm_top)), TRUE);
++<<<<<<< HEAD
 +
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	asm_top.hdr.opcode = ASM_CMD_ADD_TOPOLOGIES;
  	asm_top.payload_addr_lsw = cal_block.cal_paddr;
  	asm_top.payload_addr_msw = 0;
@@@ -442,7 -459,7 +574,11 @@@
  	if (result < 0) {
  		pr_err("%s: Set topologies failed payload = 0x%x\n",
  			__func__, cal_block.cal_paddr);
++<<<<<<< HEAD
 +		goto done;
++=======
+ 		goto err_unmap;
++>>>>>>> FETCH_HEAD
  	}
  
  	result = wait_event_timeout(ac->cmd_wait,
@@@ -450,10 -467,15 +586,22 @@@
  	if (!result) {
  		pr_err("%s: Set topologies failed after timedout payload = 0x%x\n",
  			__func__, cal_block.cal_paddr);
++<<<<<<< HEAD
 +		goto done;
 +	}
 +
 +done:
++=======
+ 		goto err_unmap;
+ 	}
+ 	return;
+ err_unmap:
+ 	q6asm_memory_unmap_regions(ac, IN);
+ err_map:
+ 	q6asm_mmap_apr_dereg();
+ 	set_custom_topology = 1;
+ mmap_fail:
++>>>>>>> FETCH_HEAD
  	return;
  }
  
@@@ -653,8 -675,11 +801,16 @@@ int q6asm_audio_client_buf_free(unsigne
  
  		while (cnt >= 0) {
  			if (port->buf[cnt].data) {
++<<<<<<< HEAD
 +				msm_audio_ion_free(port->buf[cnt].client,
 +						   port->buf[cnt].handle);
++=======
+ 				if (!rc)
+ 					msm_audio_ion_free(
+ 						port->buf[cnt].client,
+ 						port->buf[cnt].handle);
+ 
++>>>>>>> FETCH_HEAD
  				port->buf[cnt].client = NULL;
  				port->buf[cnt].handle = NULL;
  				port->buf[cnt].data = NULL;
@@@ -700,7 -725,9 +856,13 @@@ int q6asm_audio_client_buf_free_contigu
  			(void *)&port->buf[0].phys,
  			(void *)port->buf[0].client,
  			(void *)port->buf[0].handle);
++<<<<<<< HEAD
 +		msm_audio_ion_free(port->buf[0].client, port->buf[0].handle);
++=======
+ 		if (!rc)
+ 			msm_audio_ion_free(port->buf[0].client,
+ 					   port->buf[0].handle);
++>>>>>>> FETCH_HEAD
  		port->buf[0].client = NULL;
  		port->buf[0].handle = NULL;
  	}
@@@ -723,6 -750,9 +885,12 @@@ void q6asm_audio_client_free(struct aud
  	struct audio_port_data *port;
  	if (!ac || !ac->session)
  		return;
++<<<<<<< HEAD
++=======
+ 
+ 	mutex_lock(&session_lock);
+ 
++>>>>>>> FETCH_HEAD
  	pr_debug("%s: Session id %d\n", __func__, ac->session);
  	if (ac->io_mode & SYNC_IO_MODE) {
  		for (loopcnt = 0; loopcnt <= OUT; loopcnt++) {
@@@ -739,6 -769,7 +907,10 @@@
  	apr_deregister(ac->apr);
  	ac->apr = NULL;
  	ac->mmap_apr = NULL;
++<<<<<<< HEAD
++=======
+ 	rtac_set_asm_handle(ac->session, ac->apr);
++>>>>>>> FETCH_HEAD
  	q6asm_session_free(ac);
  	q6asm_mmap_apr_dereg();
  
@@@ -747,6 -778,8 +919,11 @@@
  /*done:*/
  	kfree(ac);
  	ac = NULL;
++<<<<<<< HEAD
++=======
+ 	mutex_unlock(&session_lock);
+ 
++>>>>>>> FETCH_HEAD
  	return;
  }
  
@@@ -803,15 -836,21 +980,32 @@@ struct audio_client *q6asm_audio_client
  	ac = kzalloc(sizeof(struct audio_client), GFP_KERNEL);
  	if (!ac)
  		return NULL;
++<<<<<<< HEAD
 +	n = q6asm_session_alloc(ac);
 +	if (n <= 0)
 +		goto fail_session;
++=======
+ 
+ 	mutex_lock(&session_lock);
+ 	n = q6asm_session_alloc(ac);
+ 	if (n <= 0) {
+ 		mutex_unlock(&session_lock);
+ 		goto fail_session;
+ 	}
++>>>>>>> FETCH_HEAD
  	ac->session = n;
  	ac->cb = cb;
  	ac->priv = priv;
  	ac->io_mode = SYNC_IO_MODE;
++<<<<<<< HEAD
 +	ac->perf_mode = false;
 +	ac->fptr_cache_ops = NULL;
++=======
+ 	ac->perf_mode = LEGACY_PCM_MODE;
+ 	ac->fptr_cache_ops = NULL;
+ 	/* DSP expects stream id from 1 */
+ 	ac->stream_id = 1;
++>>>>>>> FETCH_HEAD
  	ac->apr = apr_register("ADSP", "ASM", \
  				(apr_fn)q6asm_callback,\
  				((ac->session) << 8 | 0x0001),\
@@@ -819,7 -858,8 +1013,12 @@@
  
  	if (ac->apr == NULL) {
  		pr_err("%s Registration with APR failed\n", __func__);
++<<<<<<< HEAD
 +			goto fail;
++=======
+ 		mutex_unlock(&session_lock);
+ 		goto fail_apr1;
++>>>>>>> FETCH_HEAD
  	}
  	ac->apr2 = apr_register("ADSP", "ASM", \
  				(apr_fn)q6asm_callback,\
@@@ -828,14 -868,18 +1027,28 @@@
  
  	if (ac->apr2 == NULL) {
  		pr_err("%s Registration with APR-2 failed\n", __func__);
++<<<<<<< HEAD
 +			goto fail;
 +	}
++=======
+ 		mutex_unlock(&session_lock);
+ 		goto fail_apr2;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	rtac_set_asm_handle(n, ac->apr);
  
  	pr_debug("%s Registering the common port with APR\n", __func__);
  	ac->mmap_apr = q6asm_mmap_apr_reg();
++<<<<<<< HEAD
 +	if (ac->mmap_apr == NULL)
 +		goto fail;
++=======
+ 	if (ac->mmap_apr == NULL) {
+ 		mutex_unlock(&session_lock);
+ 		goto fail_mmap;
+ 	}
++>>>>>>> FETCH_HEAD
  
  	init_waitqueue_head(&ac->cmd_wait);
  	init_waitqueue_head(&ac->time_wait);
@@@ -855,10 -899,15 +1068,22 @@@
  
  	pr_debug("%s: session[%d]\n", __func__, ac->session);
  
++<<<<<<< HEAD
 +	return ac;
 +fail:
 +	q6asm_audio_client_free(ac);
 +	return NULL;
++=======
+ 	mutex_unlock(&session_lock);
+ 
+ 	return ac;
+ fail_mmap:
+ 	apr_deregister(ac->apr2);
+ fail_apr2:
+ 	apr_deregister(ac->apr);
+ fail_apr1:
+ 	q6asm_session_free(ac);
++>>>>>>> FETCH_HEAD
  fail_session:
  	kfree(ac);
  	return NULL;
@@@ -1055,8 -1104,11 +1280,16 @@@ static int32_t q6asm_srvc_callback(stru
  {
  	uint32_t sid = 0;
  	uint32_t dir = 0;
++<<<<<<< HEAD
 +	uint32_t *payload;
 +	unsigned long dsp_flags;
++=======
+ 	uint32_t i = IN;
+ 	uint32_t *payload;
+ 	unsigned long dsp_flags;
+ 	struct asm_buffer_node *buf_node = NULL;
+ 	struct list_head *ptr, *next;
++>>>>>>> FETCH_HEAD
  
  	struct audio_client *ac = NULL;
  	struct audio_port_data *port;
@@@ -1069,13 -1121,48 +1302,56 @@@
  	payload = data->payload;
  
  	if (data->opcode == RESET_EVENTS) {
++<<<<<<< HEAD
++=======
+ 		struct audio_client *ac_mmap = (struct audio_client *)priv;
+ 		if (ac_mmap == NULL) {
+ 			pr_err("%s ac or priv NULL\n", __func__);
+ 			return -EINVAL;
+ 		}
++>>>>>>> FETCH_HEAD
  		pr_debug("%s: Reset event is received: %d %d apr[%p]\n",
  				__func__,
  				data->reset_event,
  				data->reset_proc,
  				this_mmap.apr);
++<<<<<<< HEAD
++		apr_reset(this_mmap.apr);
++		this_mmap.apr = NULL;
++=======
+ 		atomic_set(&this_mmap.ref_cnt, 0);
  		apr_reset(this_mmap.apr);
+ 		for (; i <= OUT; i++) {
+ 			list_for_each_safe(ptr, next,
+ 				&common_client.port[i].mem_map_handle) {
+ 				buf_node = list_entry(ptr,
+ 						struct asm_buffer_node,
+ 						list);
+ 				if (buf_node->buf_addr_lsw ==
+ 				common_client.port[i].buf->phys) {
+ 					list_del(&buf_node->list);
+ 					kfree(buf_node);
+ 				}
+ 			}
+ 			pr_debug("%s:Clearing custom topology\n", __func__);
+ 		}
  		this_mmap.apr = NULL;
+ 		ac_mmap->mmap_apr = NULL;
+ 		for (; i <= OUT; i++) {
+ 			list_for_each_safe(ptr, next,
+ 				&common_client.port[i].mem_map_handle) {
+ 				buf_node = list_entry(ptr,
+ 						struct asm_buffer_node,
+ 						list);
+ 				if (buf_node->buf_addr_lsw ==
+ 				common_client.port[i].buf->phys) {
+ 					list_del(&buf_node->list);
+ 					kfree(buf_node);
+ 				}
+ 			}
+ 			pr_debug("%s:Clearing custom topology\n", __func__);
+ 		}
++>>>>>>> FETCH_HEAD
  		reset_custom_topology_flags();
  		set_custom_topology = 1;
  		topology_map_handle = 0;
@@@ -1102,6 -1189,13 +1378,16 @@@
  			if (payload[1] != 0) {
  				pr_err("%s: cmd = 0x%x returned error = 0x%x sid:%d\n",
  					__func__, payload[0], payload[1], sid);
++<<<<<<< HEAD
++=======
+ 				if (payload[0] ==
+ 				    ASM_CMD_SHARED_MEM_UNMAP_REGIONS)
+ 					atomic_set(&ac->unmap_cb_success, 0);
+ 			} else {
+ 				if (payload[0] ==
+ 				    ASM_CMD_SHARED_MEM_UNMAP_REGIONS)
+ 					atomic_set(&ac->unmap_cb_success, 1);
++>>>>>>> FETCH_HEAD
  			}
  
  			if (atomic_read(&ac->cmd_state)) {
@@@ -1185,6 -1279,7 +1471,10 @@@ static int32_t q6asm_callback(struct ap
  	unsigned long dsp_flags;
  	uint32_t *payload;
  	uint32_t wakeup_flag = 1;
++<<<<<<< HEAD
++=======
+ 	int32_t  ret = 0;
++>>>>>>> FETCH_HEAD
  
  
  	if ((ac == NULL) || (data == NULL)) {
@@@ -1208,12 -1303,22 +1498,28 @@@
  	}
  
  	if (data->opcode == RESET_EVENTS) {
++<<<<<<< HEAD
++=======
+ 		if(ac->apr == NULL) {
+ 		    ac->apr = ac->apr2;
+ 		}
++>>>>>>> FETCH_HEAD
  		pr_debug("q6asm_callback: Reset event is received: %d %d apr[%p]\n",
  				data->reset_event, data->reset_proc, ac->apr);
  			if (ac->cb)
  				ac->cb(data->opcode, data->token,
  					(uint32_t *)data->payload, ac->priv);
  		apr_reset(ac->apr);
++<<<<<<< HEAD
++=======
+ 		if (ac->cb)
+ 			ac->cb(data->opcode, data->token,
+ 				data->payload, ac->priv);
+ 		atomic_set(&ac->time_flag, 0);
+ 		atomic_set(&ac->cmd_state, 0);
+ 		wake_up(&ac->time_wait);
+ 		wake_up(&ac->cmd_wait);
++>>>>>>> FETCH_HEAD
  		ac->apr = NULL;
  		return 0;
  	}
@@@ -1248,14 -1353,14 +1554,25 @@@
  		case ASM_SESSION_CMD_REGISTER_FORX_OVERFLOW_EVENTS:
  		case ASM_STREAM_CMD_FLUSH_READBUFS:
  		pr_debug("%s:Payload = [0x%x]\n", __func__, payload[0]);
++<<<<<<< HEAD
 +		if (token != ac->session) {
 +			pr_err("%s:Invalid session[%d] rxed expected[%d]",
 +					__func__, token, ac->session);
 +			return -EINVAL;
 +		}
 +		case ASM_STREAM_CMD_OPEN_READ_V3:
 +		case ASM_STREAM_CMD_OPEN_WRITE_V3:
 +		case ASM_STREAM_CMD_OPEN_READWRITE_V2:
++=======
+ 		ret = q6asm_is_valid_session(data, priv);
+ 		if (ret != 0)
+ 			return ret;
+ 
+ 		case ASM_STREAM_CMD_OPEN_READ_V3:
+ 		case ASM_STREAM_CMD_OPEN_WRITE_V3:
+ 		case ASM_STREAM_CMD_OPEN_READWRITE_V2:
+ 		case ASM_STREAM_CMD_OPEN_LOOPBACK_V2:
++>>>>>>> FETCH_HEAD
  		case ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2:
  		case ASM_STREAM_CMD_SET_ENCDEC_PARAM:
  		case ASM_CMD_ADD_TOPOLOGIES:
@@@ -1558,11 -1663,10 +1875,18 @@@ static void __q6asm_add_hdr(struct audi
  	hdr->src_domain = APR_DOMAIN_APPS;
  	hdr->dest_svc = APR_SVC_ASM;
  	hdr->dest_domain = APR_DOMAIN_ADSP;
++<<<<<<< HEAD
 +	hdr->src_port = ((ac->session << 8) & 0xFF00) | (stream_id+1);
 +	hdr->dest_port = ((ac->session << 8) & 0xFF00) | (stream_id+1);
 +	if (cmd_flg) {
 +		hdr->token = ac->session;
 +		atomic_set(&ac->cmd_state, 1);
++=======
+ 	hdr->src_port = ((ac->session << 8) & 0xFF00) | (stream_id);
+ 	hdr->dest_port = ((ac->session << 8) & 0xFF00) | (stream_id);
+ 	if (cmd_flg) {
+ 		hdr->token = ac->session;
++>>>>>>> FETCH_HEAD
  	}
  	hdr->pkt_size  = pkt_size;
  	mutex_unlock(&ac->cmd_lock);
@@@ -1599,11 -1703,10 +1923,18 @@@ static void __q6asm_add_hdr_async(struc
  	hdr->src_domain = APR_DOMAIN_APPS;
  	hdr->dest_svc = APR_SVC_ASM;
  	hdr->dest_domain = APR_DOMAIN_ADSP;
++<<<<<<< HEAD
 +	hdr->src_port = ((ac->session << 8) & 0xFF00) | (stream_id+1);
 +	hdr->dest_port = ((ac->session << 8) & 0xFF00) | (stream_id+1);
 +	if (cmd_flg) {
 +		hdr->token = ac->session;
 +		atomic_set(&ac->cmd_state, 1);
++=======
+ 	hdr->src_port = ((ac->session << 8) & 0xFF00) | (stream_id);
+ 	hdr->dest_port = ((ac->session << 8) & 0xFF00) | (stream_id);
+ 	if (cmd_flg) {
+ 		hdr->token = ac->session;
++>>>>>>> FETCH_HEAD
  	}
  	hdr->pkt_size  = pkt_size;
  	return;
@@@ -1647,7 -1750,6 +1978,10 @@@ static void q6asm_add_hdr_custom_topolo
  	hdr->dest_port = 0;
  	if (cmd_flg) {
  		hdr->token = ((ac->session << 8) | 0x0001) ;
++<<<<<<< HEAD
 +		atomic_set(&ac->cmd_state, 1);
++=======
++>>>>>>> FETCH_HEAD
  	}
  	hdr->pkt_size  = pkt_size;
  	mutex_unlock(&ac->cmd_lock);
@@@ -1664,7 -1766,6 +1998,10 @@@ static void q6asm_add_mmaphdr(struct au
  	hdr->dest_port = 0;
  	if (cmd_flg) {
  		hdr->token = token;
++<<<<<<< HEAD
 +		atomic_set(&ac->cmd_state, 1);
++=======
++>>>>>>> FETCH_HEAD
  	}
  	hdr->pkt_size  = pkt_size;
  	return;
@@@ -1684,6 -1785,7 +2021,10 @@@ static int __q6asm_open_read(struct aud
  	pr_debug("%s:session[%d]", __func__, ac->session);
  
  	q6asm_add_hdr(ac, &open.hdr, sizeof(open), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	open.hdr.opcode = ASM_STREAM_CMD_OPEN_READ_V3;
  	/* Stream prio : High, provide meta info with encoded frames */
  	open.src_endpointype = ASM_END_POINT_DEVICE_MATRIX;
@@@ -1694,10 -1796,13 +2035,20 @@@
  	open.bits_per_sample = bits_per_sample;
  	open.mode_flags = 0x0;
  
++<<<<<<< HEAD
 +	if (ac->perf_mode)
 +		open.mode_flags |= ASM_LOW_LATENCY_STREAM_SESSION;
 +	else
 +		open.mode_flags |= ASM_LEGACY_STREAM_SESSION;
++=======
+ 	if (ac->perf_mode == LOW_LATENCY_PCM_MODE) {
+ 		open.mode_flags |= ASM_LOW_LATENCY_STREAM_SESSION <<
+ 				ASM_SHIFT_STREAM_PERF_MODE_FLAG_IN_OPEN_READ;
+ 	} else {
+ 		open.mode_flags |= ASM_LEGACY_STREAM_SESSION <<
+ 				ASM_SHIFT_STREAM_PERF_MODE_FLAG_IN_OPEN_READ;
+ 	}
++>>>>>>> FETCH_HEAD
  
  	switch (format) {
  	case FORMAT_LINEAR_PCM:
@@@ -1741,6 -1846,7 +2092,10 @@@
  			rc);
  		goto fail_cmd;
  	}
++<<<<<<< HEAD
++=======
+ 	ac->io_mode |= TUN_READ_IO_MODE;
++>>>>>>> FETCH_HEAD
  	return 0;
  fail_cmd:
  	return -EINVAL;
@@@ -1773,10 -1879,23 +2128,30 @@@ static int __q6asm_open_write(struct au
  		format);
  
  	q6asm_stream_add_hdr(ac, &open.hdr, sizeof(open), TRUE, stream_id);
++<<<<<<< HEAD
 +
 +	open.hdr.opcode = ASM_STREAM_CMD_OPEN_WRITE_V3;
 +	open.mode_flags = 0x00;
 +	if (ac->perf_mode)
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	/*
+ 	 * Updated the token field with stream/session for compressed playback
+ 	 * Platform driver must know the the stream with which the command is
+ 	 * associated
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO)
+ 		open.hdr.token = ((ac->session << 8) & 0xFFFF00) |
+ 				 (stream_id & 0xFF);
+ 
+ 	pr_debug("%s: token = 0x%x, stream_id  %d, session 0x%x\n",
+ 		 __func__, open.hdr.token, stream_id, ac->session);
+ 	open.hdr.opcode = ASM_STREAM_CMD_OPEN_WRITE_V3;
+ 	open.mode_flags = 0x00;
+ 	if (ac->perf_mode == ULTRA_LOW_LATENCY_PCM_MODE)
+ 		open.mode_flags |= ASM_ULTRA_LOW_LATENCY_STREAM_SESSION;
+ 	else if (ac->perf_mode == LOW_LATENCY_PCM_MODE)
++>>>>>>> FETCH_HEAD
  		open.mode_flags |= ASM_LOW_LATENCY_STREAM_SESSION;
  	else {
  		open.mode_flags |= ASM_LEGACY_STREAM_SESSION;
@@@ -1818,6 -1937,12 +2193,15 @@@
  	case FORMAT_EAC3:
  		open.dec_fmt_id = ASM_MEDIA_FMT_EAC3_DEC;
  		break;
++<<<<<<< HEAD
++=======
+ 	case FORMAT_MP2:
+ 		open.dec_fmt_id = ASM_MEDIA_FMT_MP2;
+ 		break;
+ 	case FORMAT_FLAC:
+ 		open.dec_fmt_id = ASM_MEDIA_FMT_FLAC;
+ 		break;
++>>>>>>> FETCH_HEAD
  	default:
  		pr_err("%s: Invalid format[%d]\n", __func__, format);
  		goto fail_cmd;
@@@ -1835,6 -1960,7 +2219,10 @@@
  			rc);
  		goto fail_cmd;
  	}
++<<<<<<< HEAD
++=======
+ 	ac->io_mode |= TUN_WRITE_IO_MODE;
++>>>>>>> FETCH_HEAD
  	return 0;
  fail_cmd:
  	return -EINVAL;
@@@ -1878,6 -2004,7 +2266,10 @@@ int q6asm_open_read_write(struct audio_
  
  	ac->io_mode |= NT_MODE;
  	q6asm_add_hdr(ac, &open.hdr, sizeof(open), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	open.hdr.opcode = ASM_STREAM_CMD_OPEN_READWRITE_V2;
  
  	open.mode_flags = BUFFER_META_ENABLE;
@@@ -1975,6 -2102,50 +2367,53 @@@ fail_cmd
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ int q6asm_open_loopback_v2(struct audio_client *ac, uint16_t bits_per_sample)
+ {
+ 	int rc = 0x00;
+ 	struct asm_stream_cmd_open_loopback_v2 open;
+ 
+ 	if ((ac == NULL) || (ac->apr == NULL)) {
+ 		pr_err("%s APR handle NULL\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 	pr_debug("%s: session[%d]", __func__, ac->session);
+ 
+ 	q6asm_add_hdr(ac, &open.hdr, sizeof(open), TRUE);
+ 	atomic_set(&ac->cmd_state, 1);
+ 	open.hdr.opcode = ASM_STREAM_CMD_OPEN_LOOPBACK_V2;
+ 
+ 	open.mode_flags = 0;
+ 	open.src_endpointype = 0;
+ 	open.sink_endpointype = 0;
+ 	/* source endpoint : matrix */
+ 	open.postprocopo_id = get_asm_topology();
+ 	if (open.postprocopo_id == 0)
+ 		open.postprocopo_id = DEFAULT_POPP_TOPOLOGY;
+ 	open.bits_per_sample = bits_per_sample;
+ 	open.reserved = 0;
+ 
+ 	rc = apr_send_pkt(ac->apr, (uint32_t *) &open);
+ 	if (rc < 0) {
+ 		pr_err("%s open failed op[0x%x]rc[%d]\n", __func__,
+ 				open.hdr.opcode, rc);
+ 		goto fail_cmd;
+ 	}
+ 
+ 	rc = wait_event_timeout(ac->cmd_wait,
+ 			(atomic_read(&ac->cmd_state) == 0), 5*HZ);
+ 	if (!rc) {
+ 		pr_err("%s timeout. waited for open_loopback rc[%d]\n",
+ 				__func__, rc);
+ 		goto fail_cmd;
+ 	}
+ 	return 0;
+ fail_cmd:
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> FETCH_HEAD
  int q6asm_run(struct audio_client *ac, uint32_t flags,
  		uint32_t msw_ts, uint32_t lsw_ts)
  {
@@@ -1986,6 -2157,7 +2425,10 @@@
  	}
  	pr_debug("%s session[%d]", __func__, ac->session);
  	q6asm_add_hdr(ac, &run.hdr, sizeof(run), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	run.hdr.opcode = ASM_SESSION_CMD_RUN_V2;
  	run.flags    = flags;
@@@ -2023,7 -2195,7 +2466,11 @@@ static int __q6asm_run_nowait(struct au
  	}
  	pr_debug("session[%d]", ac->session);
  	q6asm_stream_add_hdr_async(ac, &run.hdr, sizeof(run), TRUE, stream_id);
++<<<<<<< HEAD
 +
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	run.hdr.opcode = ASM_SESSION_CMD_RUN_V2;
  	run.flags    = flags;
  	run.time_lsw = lsw_ts;
@@@ -2065,6 -2237,7 +2512,10 @@@ int q6asm_enc_cfg_blk_aac(struct audio_
  		sample_rate, channels, bit_rate, mode, format);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
@@@ -2105,6 -2278,7 +2556,10 @@@ int q6asm_set_encdec_chan_map(struct au
  	pr_debug("%s: Session %d, num_channels = %d\n",
  			 __func__, ac->session, num_channels);
  	q6asm_add_hdr(ac, &chan_map.hdr, sizeof(chan_map), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	chan_map.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	chan_map.encdec.param_id = ASM_PARAM_ID_DEC_OUTPUT_CHAN_MAP;
  	chan_map.encdec.param_size = sizeof(struct asm_dec_out_chan_map_param) -
@@@ -2149,6 -2323,7 +2604,10 @@@ static int __q6asm_enc_cfg_blk_pcm(stru
  			 ac->session, rate, channels);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
  	enc_cfg.encdec.param_size = sizeof(enc_cfg) - sizeof(enc_cfg.hdr) -
@@@ -2210,7 -2385,7 +2669,11 @@@ int q6asm_enc_cfg_blk_pcm_native(struc
  			 ac->session, rate, channels);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
 +
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
  	enc_cfg.encdec.param_size = sizeof(enc_cfg) - sizeof(enc_cfg.hdr) -
@@@ -2274,21 -2449,21 +2737,39 @@@ static int q6asm_map_channels(u8 *chann
  		lchannel_mapping[3] = PCM_CHANNEL_LB;
  		lchannel_mapping[4] = PCM_CHANNEL_RB;
  	} else if (channels == 6) {
++<<<<<<< HEAD
 +		lchannel_mapping[0] = PCM_CHANNEL_FC;
 +		lchannel_mapping[1] = PCM_CHANNEL_FL;
 +		lchannel_mapping[2] = PCM_CHANNEL_FR;
 +		lchannel_mapping[3] = PCM_CHANNEL_LB;
 +		lchannel_mapping[4] = PCM_CHANNEL_RB;
 +		lchannel_mapping[5] = PCM_CHANNEL_LFE;
 +	} else if (channels == 8) {
 +		lchannel_mapping[0] = PCM_CHANNEL_FL;
 +		lchannel_mapping[1] = PCM_CHANNEL_FR;
 +		lchannel_mapping[2] = PCM_CHANNEL_LFE;
 +		lchannel_mapping[3] = PCM_CHANNEL_FC;
 +		lchannel_mapping[4] = PCM_CHANNEL_LB;
 +		lchannel_mapping[5] = PCM_CHANNEL_RB;
 +		lchannel_mapping[6] = PCM_CHANNEL_RLC;
 +		lchannel_mapping[7] = PCM_CHANNEL_RRC;
++=======
+ 		lchannel_mapping[0] = PCM_CHANNEL_FL;
+ 		lchannel_mapping[1] = PCM_CHANNEL_FR;
+ 		lchannel_mapping[2] = PCM_CHANNEL_FC;
+ 		lchannel_mapping[3] = PCM_CHANNEL_LFE;
+ 		lchannel_mapping[4] = PCM_CHANNEL_LS;
+ 		lchannel_mapping[5] = PCM_CHANNEL_RS;
+ 	} else if (channels == 8) {
+ 		lchannel_mapping[0] = PCM_CHANNEL_FL;
+ 		lchannel_mapping[1] = PCM_CHANNEL_FR;
+ 		lchannel_mapping[2] = PCM_CHANNEL_FC;
+ 		lchannel_mapping[3] = PCM_CHANNEL_LFE;
+ 		lchannel_mapping[4] = PCM_CHANNEL_LB;
+ 		lchannel_mapping[5] = PCM_CHANNEL_RB;
+ 		lchannel_mapping[6] = PCM_CHANNEL_FLC;
+ 		lchannel_mapping[7] = PCM_CHANNEL_FRC;
++>>>>>>> FETCH_HEAD
  	} else {
  		pr_err("%s: ERROR.unsupported num_ch = %u\n",
  		 __func__, channels);
@@@ -2309,6 -2484,7 +2790,10 @@@ int q6asm_enable_sbrps(struct audio_cli
  	pr_debug("%s: Session %d\n", __func__, ac->session);
  
  	q6asm_add_hdr(ac, &sbrps.hdr, sizeof(sbrps), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	sbrps.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	sbrps.encdec.param_id = ASM_PARAM_ID_AAC_SBR_PS_FLAG;
@@@ -2350,6 -2526,7 +2835,10 @@@ int q6asm_cfg_dual_mono_aac(struct audi
  			 __func__, ac->session, sce_left, sce_right);
  
  	q6asm_add_hdr(ac, &dual_mono.hdr, sizeof(dual_mono), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	dual_mono.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	dual_mono.encdec.param_id = ASM_PARAM_ID_AAC_DUAL_MONO_MAPPING;
@@@ -2381,8 -2558,36 +2870,41 @@@ fail_cmd
  /* Support for selecting stereo mixing coefficients for B family not done */
  int q6asm_cfg_aac_sel_mix_coef(struct audio_client *ac, uint32_t mix_coeff)
  {
++<<<<<<< HEAD
 +	/* To Be Done */
 +	return 0;
++=======
+ 	struct asm_aac_stereo_mix_coeff_selection_param_v2 aac_mix_coeff;
+ 	int rc = 0;
+ 
+ 	q6asm_add_hdr(ac, &aac_mix_coeff.hdr, sizeof(aac_mix_coeff), TRUE);
+ 	atomic_set(&ac->cmd_state, 1);
+ 	aac_mix_coeff.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
+ 	aac_mix_coeff.param_id =
+ 		ASM_PARAM_ID_AAC_STEREO_MIX_COEFF_SELECTION_FLAG_V2;
+ 	aac_mix_coeff.param_size =
+ 		sizeof(struct asm_aac_stereo_mix_coeff_selection_param_v2);
+ 	aac_mix_coeff.aac_stereo_mix_coeff_flag = mix_coeff;
+ 	pr_debug("%s, mix_coeff = %u", __func__, mix_coeff);
+ 	rc = apr_send_pkt(ac->apr, (uint32_t *) &aac_mix_coeff);
+ 	if (rc < 0) {
+ 		pr_err("%s:Command opcode[0x%x]paramid[0x%x] failed\n",
+ 			__func__, ASM_STREAM_CMD_SET_ENCDEC_PARAM,
+ 			ASM_PARAM_ID_AAC_STEREO_MIX_COEFF_SELECTION_FLAG_V2);
+ 		rc = -EINVAL;
+ 		goto fail_cmd;
+ 	}
+ 	rc = wait_event_timeout(ac->cmd_wait,
+ 		(atomic_read(&ac->cmd_state) == 0), 5*HZ);
+ 	if (!rc) {
+ 		pr_err("%s:timeout opcode[0x%x]\n",
+ 			__func__, aac_mix_coeff.hdr.opcode);
+ 		goto fail_cmd;
+ 	}
+ 	return 0;
+ fail_cmd:
+ 	return -EINVAL;
++>>>>>>> FETCH_HEAD
  }
  
  int q6asm_enc_cfg_blk_qcelp(struct audio_client *ac, uint32_t frames_per_buf,
@@@ -2398,6 -2603,7 +2920,10 @@@
  		reduced_rate_level, rate_modulation_cmd);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
  	enc_cfg.encdec.param_size = sizeof(struct asm_v13k_enc_cfg) -
@@@ -2439,6 -2645,7 +2965,10 @@@ int q6asm_enc_cfg_blk_evrc(struct audio
  		frames_per_buf,	min_rate, max_rate, rate_modulation_cmd);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
  	enc_cfg.encdec.param_size = sizeof(struct asm_evrc_enc_cfg) -
@@@ -2478,6 -2685,7 +3008,10 @@@ int q6asm_enc_cfg_blk_amrnb(struct audi
  		__func__, ac->session, frames_per_buf, band_mode, dtx_enable);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
  	enc_cfg.encdec.param_size = sizeof(struct asm_amrnb_enc_cfg) -
@@@ -2515,6 -2723,7 +3049,10 @@@ int q6asm_enc_cfg_blk_amrwb(struct audi
  		__func__, ac->session, frames_per_buf, band_mode, dtx_enable);
  
  	q6asm_add_hdr(ac, &enc_cfg.hdr, sizeof(enc_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	enc_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	enc_cfg.encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;
  	enc_cfg.encdec.param_size = sizeof(struct asm_amrwb_enc_cfg) -
@@@ -2545,7 -2754,7 +3083,11 @@@ fail_cmd
  
  static int __q6asm_media_format_block_pcm(struct audio_client *ac,
  				uint32_t rate, uint32_t channels,
++<<<<<<< HEAD
 +				uint16_t bits_per_sample)
++=======
+ 				uint16_t bits_per_sample, int stream_id)
++>>>>>>> FETCH_HEAD
  {
  	struct asm_multi_channel_pcm_fmt_blk_v2 fmt;
  	u8 *channel_mapping;
@@@ -2554,7 -2763,19 +3096,23 @@@
  	pr_debug("%s:session[%d]rate[%d]ch[%d]\n", __func__, ac->session, rate,
  		channels);
  
++<<<<<<< HEAD
 +	q6asm_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE);
++=======
+ 	q6asm_stream_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE, stream_id);
+ 	atomic_set(&ac->cmd_state, 1);
+ 	/*
+ 	 * Updated the token field with stream/session for compressed playback
+ 	 * Platform driver must know the the stream with which the command is
+ 	 * associated
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO)
+ 		fmt.hdr.token = ((ac->session << 8) & 0xFFFF00) |
+ 				(stream_id & 0xFF);
+ 
+ 	pr_debug("%s: token = 0x%x, stream_id  %d, session 0x%x\n",
+ 		  __func__, fmt.hdr.token, stream_id, ac->session);
++>>>>>>> FETCH_HEAD
  
  	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
  	fmt.fmt_blk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
@@@ -2591,7 -2812,7 +3149,11 @@@ int q6asm_media_format_block_pcm(struc
  				uint32_t rate, uint32_t channels)
  {
  	return __q6asm_media_format_block_pcm(ac, rate,
++<<<<<<< HEAD
 +				channels, 16);
++=======
+ 				channels, 16, ac->stream_id);
++>>>>>>> FETCH_HEAD
  }
  
  int q6asm_media_format_block_pcm_format_support(struct audio_client *ac,
@@@ -2599,7 -2820,15 +3161,19 @@@
  				uint16_t bits_per_sample)
  {
  	return __q6asm_media_format_block_pcm(ac, rate,
++<<<<<<< HEAD
 +				channels, bits_per_sample);
++=======
+ 				channels, bits_per_sample, ac->stream_id);
+ }
+ 
+ int q6asm_media_format_block_pcm_format_support_v2(struct audio_client *ac,
+ 				uint32_t rate, uint32_t channels,
+ 				uint16_t bits_per_sample, int stream_id)
+ {
+ 	return __q6asm_media_format_block_pcm(ac, rate,
+ 				channels, bits_per_sample, stream_id);
++>>>>>>> FETCH_HEAD
  }
  
  static int __q6asm_media_format_block_multi_ch_pcm(struct audio_client *ac,
@@@ -2615,6 -2844,7 +3189,10 @@@
  		channels);
  
  	q6asm_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
  	fmt.fmt_blk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
@@@ -2683,7 -2913,18 +3261,22 @@@ static int __q6asm_media_format_block_m
  		cfg->sample_rate, cfg->ch_cfg);
  
  	q6asm_stream_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE, stream_id);
++<<<<<<< HEAD
++
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	/*
+ 	 * Updated the token field with stream/session for compressed playback
+ 	 * Platform driver must know the the stream with which the command is
+ 	 * associated
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO)
+ 		fmt.hdr.token = ((ac->session << 8) & 0xFFFF00) |
+ 				(stream_id & 0xFF);
  
+ 	pr_debug("%s: token = 0x%x, stream_id  %d, session 0x%x\n",
+ 		  __func__, fmt.hdr.token, stream_id, ac->session);
++>>>>>>> FETCH_HEAD
  	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
  	fmt.fmt_blk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
  					sizeof(fmt.fmt_blk);
@@@ -2748,6 -2989,7 +3341,10 @@@ int q6asm_media_format_block_wma(struc
  		wma_cfg->ch_mask, wma_cfg->encode_opt);
  
  	q6asm_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
  	fmt.fmtblk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
@@@ -2793,6 -3035,7 +3390,10 @@@ int q6asm_media_format_block_wmapro(str
  		wmapro_cfg->adv_encode_opt, wmapro_cfg->adv_encode_opt2);
  
  	q6asm_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
  	fmt.fmtblk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
@@@ -2840,6 -3083,7 +3441,10 @@@ int q6asm_media_format_block_amrwbplus(
  		cfg->num_channels);
  
  	q6asm_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
  	fmt.fmtblk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
@@@ -2862,6 -3106,49 +3467,52 @@@ fail_cmd
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ int q6asm_stream_media_format_block_flac(struct audio_client *ac,
+ 				struct asm_flac_cfg *cfg, int stream_id)
+ {
+ 	struct asm_flac_fmt_blk_v2 fmt;
+ 	int rc = 0;
+ 
+ 	pr_debug("%s :session[%d]rate[%d]ch[%d]size[%d]\n", __func__,
+ 		ac->session, cfg->sample_rate, cfg->ch_cfg, cfg->sample_size);
+ 
+ 	q6asm_add_hdr(ac, &fmt.hdr, sizeof(fmt), TRUE);
+ 	atomic_set(&ac->cmd_state, 1);
+ 
+ 	fmt.hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;
+ 	fmt.fmtblk.fmt_blk_size = sizeof(fmt) - sizeof(fmt.hdr) -
+ 						sizeof(fmt.fmtblk);
+ 
+ 	fmt.is_stream_info_present = cfg->stream_info_present;
+ 	fmt.num_channels = cfg->ch_cfg;
+ 	fmt.min_blk_size = cfg->min_blk_size;
+ 	fmt.max_blk_size = cfg->max_blk_size;
+ 	fmt.sample_rate = cfg->sample_rate;
+ 	fmt.min_frame_size = cfg->min_frame_size;
+ 	fmt.max_frame_size = cfg->max_frame_size;
+ 	fmt.sample_size = cfg->sample_size;
+ 
+ 	rc = apr_send_pkt(ac->apr, (uint32_t *) &fmt);
+ 	if (rc < 0) {
+ 		pr_err("%s :Comamnd media format update failed %d\n",
+ 				__func__, rc);
+ 		goto fail_cmd;
+ 	}
+ 	rc = wait_event_timeout(ac->cmd_wait,
+ 				(atomic_read(&ac->cmd_state) == 0), 5*HZ);
+ 	if (!rc) {
+ 		pr_err("%s :timeout. waited for FORMAT_UPDATE\n", __func__);
+ 		rc = -ETIMEDOUT;
+ 		goto fail_cmd;
+ 	}
+ 	return 0;
+ fail_cmd:
+ 	return rc;
+ }
+ 
++>>>>>>> FETCH_HEAD
  int q6asm_ds1_set_endp_params(struct audio_client *ac,
  				int param_id, int param_value)
  {
@@@ -2871,6 -3158,7 +3522,10 @@@
  	pr_debug("%s: session[%d]param_id[%d]param_value[%d]", __func__,
  			ac->session, param_id, param_value);
  	q6asm_add_hdr(ac, &ddp_cfg.hdr, sizeof(ddp_cfg), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	ddp_cfg.hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;
  	ddp_cfg.encdec.param_id = param_id;
  	ddp_cfg.encdec.param_size = sizeof(struct asm_dec_ddp_endp_param_v2) -
@@@ -2931,6 -3219,7 +3586,10 @@@ int q6asm_memory_map(struct audio_clien
  							mmap_region_cmd;
  	q6asm_add_mmaphdr(ac, &mmap_regions->hdr, cmd_size,
  			TRUE, ((ac->session << 8) | dir));
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	mmap_regions->hdr.opcode = ASM_CMD_SHARED_MEM_MAP_REGIONS;
  	mmap_regions->mem_pool_id = ADSP_MEMORY_MAP_SHMEM8_4K_POOL;
  	mmap_regions->num_regions = bufcnt & 0x00ff;
@@@ -2994,8 -3283,9 +3653,14 @@@ int q6asm_memory_unmap(struct audio_cli
  	q6asm_add_mmaphdr(ac, &mem_unmap.hdr,
  			sizeof(struct avs_cmd_shared_mem_unmap_regions),
  			TRUE, ((ac->session << 8) | dir));
++<<<<<<< HEAD
 +
 +	mem_unmap.hdr.opcode = ASM_CMD_SHARED_MEM_UNMAP_REGIONS;
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	mem_unmap.hdr.opcode = ASM_CMD_SHARED_MEM_UNMAP_REGIONS;
+ 	mem_unmap.mem_map_handle = 0;
++>>>>>>> FETCH_HEAD
  	list_for_each_safe(ptr, next, &ac->port[dir].mem_map_handle) {
  		buf_node = list_entry(ptr, struct asm_buffer_node,
  						list);
@@@ -3007,6 -3297,12 +3672,15 @@@
  	}
  	pr_debug("%s: mem_unmap-mem_map_handle: 0x%x",
  		__func__, mem_unmap.mem_map_handle);
++<<<<<<< HEAD
++=======
+ 
+ 	if (mem_unmap.mem_map_handle == 0) {
+ 		pr_err("%s Do not send null mem handle to DSP\n", __func__);
+ 		rc = 0;
+ 		goto fail_cmd;
+ 	}
++>>>>>>> FETCH_HEAD
  	rc = apr_send_pkt(ac->mmap_apr, (uint32_t *) &mem_unmap);
  	if (rc < 0) {
  		pr_err("mem_unmap op[0x%x]rc[%d]\n",
@@@ -3018,10 -3314,19 +3692,26 @@@
  	rc = wait_event_timeout(ac->cmd_wait,
  			(atomic_read(&ac->cmd_state) == 0), 5 * HZ);
  	if (!rc) {
++<<<<<<< HEAD
 +		pr_err("timeout. waited for memory_unmap\n");
 +		rc = -EINVAL;
 +		goto fail_cmd;
 +	}
++=======
+ 		pr_err("%s timeout. waited for memory_unmap of handle 0x%x\n",
+ 			__func__, mem_unmap.mem_map_handle);
+ 		rc = -ETIMEDOUT;
+ 		goto fail_cmd;
+ 	} else if (atomic_read(&ac->unmap_cb_success) == 0) {
+ 		pr_err("%s Error in mem unmap callback of handle 0x%x\n",
+ 			__func__, mem_unmap.mem_map_handle);
+ 		rc = -EINVAL;
+ 		goto fail_cmd;
+ 	}
+ 
+ 	rc = 0;
+ fail_cmd:
++>>>>>>> FETCH_HEAD
  	list_for_each_safe(ptr, next, &ac->port[dir].mem_map_handle) {
  		buf_node = list_entry(ptr, struct asm_buffer_node,
  						list);
@@@ -3031,9 -3336,6 +3721,12 @@@
  			break;
  		}
  	}
++<<<<<<< HEAD
 +
 +	rc = 0;
 +fail_cmd:
++=======
++>>>>>>> FETCH_HEAD
  	return rc;
  }
  
@@@ -3092,6 -3394,7 +3785,10 @@@ static int q6asm_memory_map_regions(str
  							mmap_region_cmd;
  	q6asm_add_mmaphdr(ac, &mmap_regions->hdr, cmd_size, TRUE,
  					((ac->session << 8) | dir));
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	pr_debug("mmap_region=0x%p token=0x%x\n",
  		mmap_regions, ((ac->session << 8) | dir));
  
@@@ -3173,9 -3476,11 +3870,17 @@@ static int q6asm_memory_unmap_regions(s
  	cmd_size = sizeof(struct avs_cmd_shared_mem_unmap_regions);
  	q6asm_add_mmaphdr(ac, &mem_unmap.hdr, cmd_size,
  			TRUE, ((ac->session << 8) | dir));
++<<<<<<< HEAD
 +	port = &ac->port[dir];
 +	buf_add = (uint32_t)port->buf->phys;
 +	mem_unmap.hdr.opcode = ASM_CMD_SHARED_MEM_UNMAP_REGIONS;
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	port = &ac->port[dir];
+ 	buf_add = (uint32_t)port->buf->phys;
+ 	mem_unmap.hdr.opcode = ASM_CMD_SHARED_MEM_UNMAP_REGIONS;
+ 	mem_unmap.mem_map_handle = 0;
++>>>>>>> FETCH_HEAD
  	list_for_each_safe(ptr, next, &ac->port[dir].mem_map_handle) {
  		buf_node = list_entry(ptr, struct asm_buffer_node,
  						list);
@@@ -3188,6 -3493,12 +3893,15 @@@
  
  	pr_debug("%s: mem_unmap-mem_map_handle: 0x%x",
  			__func__, mem_unmap.mem_map_handle);
++<<<<<<< HEAD
++=======
+ 
+ 	if (mem_unmap.mem_map_handle == 0) {
+ 		pr_err("%s Do not send null mem handle to DSP\n", __func__);
+ 		rc = 0;
+ 		goto fail_cmd;
+ 	}
++>>>>>>> FETCH_HEAD
  	rc = apr_send_pkt(ac->mmap_apr, (uint32_t *) &mem_unmap);
  	if (rc < 0) {
  		pr_err("mmap_regions op[0x%x]rc[%d]\n",
@@@ -3198,9 -3509,19 +3912,25 @@@
  	rc = wait_event_timeout(ac->cmd_wait,
  			(atomic_read(&ac->cmd_state) == 0), 5*HZ);
  	if (!rc) {
++<<<<<<< HEAD
 +		pr_err("timeout. waited for memory_unmap\n");
 +		goto fail_cmd;
 +	}
++=======
+ 		pr_err("%s timeout. waited for memory_unmap of handle 0x%x\n",
+ 			__func__, mem_unmap.mem_map_handle);
+ 		rc = -ETIMEDOUT;
+ 		goto fail_cmd;
+ 	} else if (atomic_read(&ac->unmap_cb_success) == 0) {
+ 		pr_err("%s Error in mem unmap callback of handle 0x%x\n",
+ 			__func__, mem_unmap.mem_map_handle);
+ 		rc = -EINVAL;
+ 		goto fail_cmd;
+ 	}
+ 	rc = 0;
+ 
+ fail_cmd:
++>>>>>>> FETCH_HEAD
  	list_for_each_safe(ptr, next, &ac->port[dir].mem_map_handle) {
  		buf_node = list_entry(ptr, struct asm_buffer_node,
  						list);
@@@ -3210,9 -3531,6 +3940,12 @@@
  			break;
  		}
  	}
++<<<<<<< HEAD
 +	rc = 0;
 +
 +fail_cmd:
++=======
++>>>>>>> FETCH_HEAD
  	return rc;
  }
  
@@@ -3230,6 -3548,7 +3963,10 @@@ int q6asm_set_lrgain(struct audio_clien
  
  	sz = sizeof(struct asm_volume_ctrl_lr_chan_gain);
  	q6asm_add_hdr_async(ac, &lrgain.hdr, sz, TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	lrgain.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
  	lrgain.param.data_payload_addr_lsw = 0;
  	lrgain.param.data_payload_addr_msw = 0;
@@@ -3278,6 -3597,7 +4015,10 @@@ int q6asm_set_mute(struct audio_client 
  
  	sz = sizeof(struct asm_volume_ctrl_mute_config);
  	q6asm_add_hdr_async(ac, &mute.hdr, sz, TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	mute.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
  	mute.param.data_payload_addr_lsw = 0;
  	mute.param.data_payload_addr_msw = 0;
@@@ -3325,11 -3645,10 +4066,18 @@@ int q6asm_set_volume(struct audio_clien
  
  	sz = sizeof(struct asm_volume_ctrl_master_gain);
  	q6asm_add_hdr_async(ac, &vol.hdr, sz, TRUE);
++<<<<<<< HEAD
 +	vol.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
 +	vol.param.data_payload_addr_lsw = 0;
 +	vol.param.data_payload_addr_msw = 0;
 +
 +
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	vol.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
+ 	vol.param.data_payload_addr_lsw = 0;
+ 	vol.param.data_payload_addr_msw = 0;
++>>>>>>> FETCH_HEAD
  	vol.param.mem_map_handle = 0;
  	vol.param.data_payload_size = sizeof(vol) -
  				sizeof(vol.hdr) - sizeof(vol.param);
@@@ -3359,6 -3678,7 +4107,10 @@@
  fail_cmd:
  	return rc;
  }
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> FETCH_HEAD
  int q6asm_set_softpause(struct audio_client *ac,
  			struct asm_softpause_params *pause_param)
  {
@@@ -3374,6 -3694,7 +4126,10 @@@
  
  	sz = sizeof(struct asm_soft_pause_params);
  	q6asm_add_hdr_async(ac, &softpause.hdr, sz, TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	softpause.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
  
  	softpause.param.data_payload_addr_lsw = 0;
@@@ -3427,6 -3748,7 +4183,10 @@@ int q6asm_set_softvolume(struct audio_c
  
  	sz = sizeof(struct asm_soft_step_volume_params);
  	q6asm_add_hdr_async(ac, &softvol.hdr, sz, TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	softvol.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
  	softvol.param.data_payload_addr_lsw = 0;
  	softvol.param.data_payload_addr_msw = 0;
@@@ -3735,6 -4057,7 +4495,10 @@@ int q6asm_equalizer(struct audio_clien
  	sz = sizeof(struct asm_eq_params);
  	eq_params = (struct msm_audio_eq_stream_config *) eq_p;
  	q6asm_add_hdr(ac, &eq.hdr, sz, TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	eq.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
  	eq.param.data_payload_addr_lsw = 0;
@@@ -3812,6 -4135,11 +4576,14 @@@ int q6asm_read(struct audio_client *ac
  		mutex_lock(&port->lock);
  
  		dsp_buf = port->dsp_buf;
++<<<<<<< HEAD
++=======
+ 		if (port->buf == NULL) {
+ 			pr_err("%s buf is NULL\n", __func__);
+ 			mutex_unlock(&port->lock);
+ 			return -EINVAL;
+ 		}
++>>>>>>> FETCH_HEAD
  		ab = &port->buf[dsp_buf];
  
  		pr_debug("%s:session[%d]dsp-buf[%d][%p]cpu_buf[%d][%p]\n",
@@@ -3928,14 -4256,15 +4700,23 @@@ int q6asm_async_write(struct audio_clie
  	u32 lbuf_addr_lsw;
  	u32 liomode;
  	u32 io_compressed;
++<<<<<<< HEAD
++=======
+ 	u32 io_compressed_stream;
++>>>>>>> FETCH_HEAD
  
  	if (!ac || ac->apr == NULL) {
  		pr_err("%s: APR handle NULL\n", __func__);
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	q6asm_add_hdr_async(ac, &write.hdr, sizeof(write), FALSE);
 +
++=======
+ 	q6asm_stream_add_hdr_async(
+ 			ac, &write.hdr, sizeof(write), FALSE, ac->stream_id);
++>>>>>>> FETCH_HEAD
  	port = &ac->port[IN];
  	ab = &port->buf[port->dsp_buf];
  
@@@ -3949,10 -4278,12 +4730,19 @@@
  	write.timestamp_lsw = param->lsw_ts;
  	liomode = (ASYNC_IO_MODE | NT_MODE);
  	io_compressed = (ASYNC_IO_MODE | COMPRESSED_IO);
++<<<<<<< HEAD
 +
 +	if (ac->io_mode == liomode)
 +		lbuf_addr_lsw = (write.buf_addr_lsw - 32);
 +	else if (ac->io_mode == io_compressed)
++=======
+ 	io_compressed_stream = (ASYNC_IO_MODE | COMPRESSED_STREAM_IO);
+ 
+ 	if (ac->io_mode == liomode)
+ 		lbuf_addr_lsw = (write.buf_addr_lsw - 32);
+ 	else if (ac->io_mode == io_compressed ||
+ 		ac->io_mode == io_compressed_stream)
++>>>>>>> FETCH_HEAD
  		lbuf_addr_lsw = (write.buf_addr_lsw - param->metadata_len);
  	else
  		lbuf_addr_lsw = write.buf_addr_lsw;
@@@ -4242,6 -4573,7 +5032,10 @@@ int q6asm_send_audio_effects_params(str
  	q6asm_add_hdr_async(ac, &hdr, (sizeof(struct apr_hdr) +
  			    sizeof(struct asm_stream_cmd_set_pp_params_v2) +
  			    params_length), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  	hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
  	payload_params.data_payload_addr_lsw = 0;
  	payload_params.data_payload_addr_msw = 0;
@@@ -4282,6 -4614,17 +5076,20 @@@ static int __q6asm_cmd(struct audio_cli
  		return -EINVAL;
  	}
  	q6asm_stream_add_hdr(ac, &hdr, sizeof(hdr), TRUE, stream_id);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	/*
+ 	 * Updated the token field with stream/session for compressed playback
+ 	 * Platform driver must know the the stream with which the command is
+ 	 * associated
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO)
+ 		hdr.token = ((ac->session << 8) & 0xFFFF00) |
+ 			    (stream_id & 0xFF);
+ 	pr_debug("%s: token = 0x%x, stream_id  %d, session 0x%x\n",
+ 		    __func__, hdr.token, stream_id, ac->session);
++>>>>>>> FETCH_HEAD
  	switch (cmd) {
  	case CMD_PAUSE:
  		pr_debug("%s:CMD_PAUSE\n", __func__);
@@@ -4380,6 -4723,18 +5188,21 @@@ static int __q6asm_cmd_nowait(struct au
  		return -EINVAL;
  	}
  	q6asm_stream_add_hdr_async(ac, &hdr, sizeof(hdr), TRUE, stream_id);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
+ 	/*
+ 	 * Updated the token field with stream/session for compressed playback
+ 	 * Platform driver must know the the stream with which the command is
+ 	 * associated
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO)
+ 		hdr.token = ((ac->session << 8) & 0xFFFF00) |
+ 			    (stream_id & 0xFF);
+ 
+ 	pr_debug("%s: token = 0x%x, stream_id  %d, session 0x%x\n",
+ 		      __func__, hdr.token, stream_id, ac->session);
++>>>>>>> FETCH_HEAD
  	switch (cmd) {
  	case CMD_PAUSE:
  		pr_debug("%s:CMD_PAUSE\n", __func__);
@@@ -4426,17 -4781,30 +5249,42 @@@ int q6asm_stream_cmd_nowait(struct audi
  	return __q6asm_cmd_nowait(ac, cmd, stream_id);
  }
  
++<<<<<<< HEAD
 +int q6asm_send_meta_data(struct audio_client *ac, uint32_t initial_samples,
 +		uint32_t trailing_samples)
 +{
 +	struct asm_data_cmd_remove_silence silence;
 +	int rc = 0;
++=======
+ int __q6asm_send_meta_data(struct audio_client *ac, uint32_t stream_id,
+ 			  uint32_t initial_samples, uint32_t trailing_samples)
+ {
+ 	struct asm_data_cmd_remove_silence silence;
+ 	int rc = 0;
+ 
++>>>>>>> FETCH_HEAD
  	if (!ac || ac->apr == NULL) {
  		pr_err("APR handle NULL\n");
  		return -EINVAL;
  	}
  	pr_debug("%s session[%d]", __func__, ac->session);
++<<<<<<< HEAD
 +	q6asm_add_hdr_async(ac, &silence.hdr, sizeof(silence), FALSE);
++=======
+ 	q6asm_stream_add_hdr_async(ac, &silence.hdr, sizeof(silence), FALSE,
+ 				  stream_id);
+ 
+ 	/*
+ 	 * Updated the token field with stream/session for compressed playback
+ 	 * Platform driver must know the the stream with which the command is
+ 	 * associated
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO)
+ 		silence.hdr.token = ((ac->session << 8) & 0xFFFF00) |
+ 				    (stream_id & 0xFF);
+ 	pr_debug("%s: token = 0x%x, stream_id  %d, session 0x%x\n",
+ 	      __func__, silence.hdr.token, stream_id, ac->session);
++>>>>>>> FETCH_HEAD
  
  	silence.hdr.opcode = ASM_DATA_CMD_REMOVE_INITIAL_SILENCE;
  	silence.num_samples_to_remove    = initial_samples;
@@@ -4461,13 -4829,29 +5309,38 @@@ fail_cmd
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ int q6asm_stream_send_meta_data(struct audio_client *ac, uint32_t stream_id,
+ 		uint32_t initial_samples, uint32_t trailing_samples)
+ {
+ 	return __q6asm_send_meta_data(ac, stream_id, initial_samples,
+ 				     trailing_samples);
+ }
+ 
+ int q6asm_send_meta_data(struct audio_client *ac, uint32_t initial_samples,
+ 		uint32_t trailing_samples)
+ {
+ 	return __q6asm_send_meta_data(ac, ac->stream_id, initial_samples,
+ 				     trailing_samples);
+ }
+ 
++>>>>>>> FETCH_HEAD
  static void q6asm_reset_buf_state(struct audio_client *ac)
  {
  	int cnt = 0;
  	int loopcnt = 0;
++<<<<<<< HEAD
++	struct audio_port_data *port = NULL;
++
++	if (ac->io_mode & SYNC_IO_MODE) {
++=======
+ 	int used;
  	struct audio_port_data *port = NULL;
  
  	if (ac->io_mode & SYNC_IO_MODE) {
+ 		used = (ac->io_mode & TUN_WRITE_IO_MODE ? 1 : 0);
++>>>>>>> FETCH_HEAD
  		mutex_lock(&ac->cmd_lock);
  		for (loopcnt = 0; loopcnt <= OUT; loopcnt++) {
  			port = &ac->port[loopcnt];
@@@ -4477,7 -4861,7 +5350,11 @@@
  			while (cnt >= 0) {
  				if (!port->buf)
  					continue;
++<<<<<<< HEAD
 +				port->buf[cnt].used = 1;
++=======
+ 				port->buf[cnt].used = used;
++>>>>>>> FETCH_HEAD
  				cnt--;
  			}
  		}
@@@ -4497,6 -4881,7 +5374,10 @@@ int q6asm_reg_tx_overflow(struct audio_
  	pr_debug("%s:session[%d]enable[%d]\n", __func__,
  						ac->session, enable);
  	q6asm_add_hdr(ac, &tx_overflow.hdr, sizeof(tx_overflow), TRUE);
++<<<<<<< HEAD
++=======
+ 	atomic_set(&ac->cmd_state, 1);
++>>>>>>> FETCH_HEAD
  
  	tx_overflow.hdr.opcode = \
  			ASM_SESSION_CMD_REGISTER_FORX_OVERFLOW_EVENTS;
@@@ -4562,6 -4947,34 +5443,37 @@@ int q6asm_get_apr_service_id(int sessio
  }
  
  
++<<<<<<< HEAD
++=======
+ static int q6asm_is_valid_session(struct apr_client_data *data, void *priv)
+ {
+ 
+ 	struct audio_client *ac = (struct audio_client *)priv;
+ 	uint32_t token = data->token;
+ 
+ 	/*
+ 	 * Some commands for compressed playback has token as session and
+ 	 * other commands has session|stream. Check for both conditions
+ 	 * before deciding if the callback was for a invalud session.
+ 	 */
+ 	if (ac->io_mode & COMPRESSED_STREAM_IO) {
+ 		if ((token & 0xFFFFFF00) != ((ac->session << 8) & 0xFFFFFF00)
+ 						 && (token != ac->session)) {
+ 			pr_err("%s:Invalid compr session[%d] rxed expected[%d]",
+ 				 __func__, token, ac->session);
+ 			return -EINVAL;
+ 		}
+ 	} else {
+ 		if (token != ac->session) {
+ 			pr_err("%s:Invalid session[%d] rxed expected[%d]",
+ 				__func__, token, ac->session);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int __init q6asm_init(void)
  {
  	int lcnt;
diff --cc sound/soc/msm/qdsp6v2/q6core.c
index e9352df,4947454..0000000
--- a/sound/soc/msm/qdsp6v2/q6core.c
+++ b/sound/soc/msm/qdsp6v2/q6core.c
@@@ -25,6 -25,13 +25,16 @@@
  
  #define TIMEOUT_MS 1000
  
++<<<<<<< HEAD
++=======
+ /*
+  * AVS bring up in the modem is optimitized for the new
+  * Sub System Restart design and 100 milliseconds timeout
+  * is sufficient to make sure the Q6 will be ready.
+  */
+ #define Q6_READY_TIMEOUT_MS 100
+ 
++>>>>>>> FETCH_HEAD
  struct q6core_str {
  	struct apr_svc *core_handle_q;
  	wait_queue_head_t bus_bw_req_wait;
@@@ -41,6 -48,11 +51,14 @@@ static int32_t aprv2_core_fn_q(struct a
  	uint32_t nseg;
  	int i, j;
  
++<<<<<<< HEAD
++=======
+ 	if (data == NULL) {
+ 		pr_err("%s: data argument is null\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	pr_debug("core msg: payload len = %u, apr resp opcode = 0x%X\n",
  		data->payload_size, data->opcode);
  
@@@ -232,7 -244,7 +250,11 @@@ bool q6core_is_adsp_ready(void
  
  	rc = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
  				(q6core_lcl.bus_bw_resp_received == 1),
++<<<<<<< HEAD
 +				msecs_to_jiffies(TIMEOUT_MS));
++=======
+ 				msecs_to_jiffies(Q6_READY_TIMEOUT_MS));
++>>>>>>> FETCH_HEAD
  	if (rc > 0 && q6core_lcl.bus_bw_resp_received) {
  		/* ensure to read updated param by callback thread */
  		rmb();
diff --cc sound/soc/msm/qdsp6v2/q6lsm.c
index 9227b23,9e8a0b8..0000000
--- a/sound/soc/msm/qdsp6v2/q6lsm.c
+++ b/sound/soc/msm/qdsp6v2/q6lsm.c
@@@ -20,7 -20,6 +20,10 @@@
  #include <linux/delay.h>
  #include <linux/spinlock.h>
  #include <linux/slab.h>
++<<<<<<< HEAD
 +#include <linux/memory_alloc.h>
++=======
++>>>>>>> FETCH_HEAD
  #include <linux/debugfs.h>
  #include <linux/time.h>
  #include <linux/atomic.h>
diff --cc sound/soc/msm/qdsp6v2/q6voice.c
index c9b28f2,a9493fd..0000000
--- a/sound/soc/msm/qdsp6v2/q6voice.c
+++ b/sound/soc/msm/qdsp6v2/q6voice.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/*  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /*  Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -29,7 -29,7 +33,11 @@@
  #include "q6voice.h"
  
  
++<<<<<<< HEAD
 +#define TIMEOUT_MS 200
++=======
+ #define TIMEOUT_MS 300
++>>>>>>> FETCH_HEAD
  
  
  #define CMD_STATUS_SUCCESS 0
@@@ -370,6 -370,11 +378,14 @@@ static struct voice_data *voice_get_ses
  				NULL : &common.voice[idx]);
  }
  
++<<<<<<< HEAD
++=======
+ static bool is_voice_session(u32 session_id)
+ {
+ 	return (session_id == common.voice[VOC_PATH_PASSIVE].session_id);
+ }
+ 
++>>>>>>> FETCH_HEAD
  static bool is_voip_session(u32 session_id)
  {
  	return (session_id == common.voice[VOC_PATH_FULL].session_id);
@@@ -963,6 -968,7 +979,10 @@@ static int voice_destroy_mvm_cvs_sessio
  
  	if (is_voip_session(v->session_id) ||
  	    is_qchat_session(v->session_id) ||
++<<<<<<< HEAD
++=======
+ 	    is_volte_session(v->session_id) ||
++>>>>>>> FETCH_HEAD
  	    v->voc_state == VOC_ERROR) {
  		/* Destroy CVS. */
  		pr_debug("%s: CVS destroy session\n", __func__);
@@@ -1513,6 -1519,77 +1533,80 @@@ done
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int voice_config_cvs_vocoder_amr_rate(struct voice_data *v)
+ {
+ 	int ret = 0;
+ 	void *apr_cvs;
+ 	u16 cvs_handle;
+ 	struct cvs_set_amr_enc_rate_cmd cvs_set_amr_rate;
+ 
+ 	if (v == NULL) {
+ 		pr_err("%s: v is NULL\n", __func__);
+ 
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+ 	apr_cvs = common.apr_q6_cvs;
+ 
+ 	if (!apr_cvs) {
+ 		pr_err("%s: apr_cvs is NULL.\n", __func__);
+ 
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+ 
+ 	cvs_handle = voice_get_cvs_handle(v);
+ 
+ 	pr_debug("%s: Setting AMR rate. Media Type: %d\n", __func__,
+ 		 common.mvs_info.media_type);
+ 
+ 	cvs_set_amr_rate.hdr.hdr_field =
+ 			APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+ 			APR_HDR_LEN(APR_HDR_SIZE),
+ 			APR_PKT_VER);
+ 	cvs_set_amr_rate.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
+ 			       sizeof(cvs_set_amr_rate) - APR_HDR_SIZE);
+ 	cvs_set_amr_rate.hdr.src_port =
+ 			voice_get_idx_for_session(v->session_id);
+ 	cvs_set_amr_rate.hdr.dest_port = cvs_handle;
+ 	cvs_set_amr_rate.hdr.token = 0;
+ 
+ 	if (common.mvs_info.media_type == VSS_MEDIA_ID_AMR_NB_MODEM)
+ 		cvs_set_amr_rate.hdr.opcode =
+ 				VSS_ISTREAM_CMD_VOC_AMR_SET_ENC_RATE;
+ 	else if (common.mvs_info.media_type == VSS_MEDIA_ID_AMR_WB_MODEM)
+ 		cvs_set_amr_rate.hdr.opcode =
+ 				VSS_ISTREAM_CMD_VOC_AMRWB_SET_ENC_RATE;
+ 
+ 	cvs_set_amr_rate.amr_rate.mode = common.mvs_info.rate;
+ 
+ 	v->cvs_state = CMD_STATUS_FAIL;
+ 
+ 	ret = apr_send_pkt(apr_cvs, (uint32_t *) &cvs_set_amr_rate);
+ 	if (ret < 0) {
+ 		pr_err("%s: Error %d sending SET_AMR_RATE\n",
+ 		       __func__, ret);
+ 
+ 		goto done;
+ 	}
+ 	ret = wait_event_timeout(v->cvs_wait,
+ 				 (v->cvs_state == CMD_STATUS_SUCCESS),
+ 				 msecs_to_jiffies(TIMEOUT_MS));
+ 	if (!ret) {
+ 		pr_err("%s: wait_event timeout\n", __func__);
+ 
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+ 
+ 	return 0;
+ done:
+ 	return ret;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int voice_config_cvs_vocoder(struct voice_data *v)
  {
  	int ret = 0;
@@@ -1617,80 -1694,13 +1711,90 @@@
  
  		break;
  	}
++<<<<<<< HEAD
 +	case VSS_MEDIA_ID_AMR_NB_MODEM: {
 +		struct cvs_set_amr_enc_rate_cmd cvs_set_amr_rate;
 +
 +		pr_debug("Setting AMR rate\n");
 +
 +		cvs_set_amr_rate.hdr.hdr_field =
 +				APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
 +				APR_HDR_LEN(APR_HDR_SIZE),
 +				APR_PKT_VER);
 +		cvs_set_amr_rate.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
 +				       sizeof(cvs_set_amr_rate) - APR_HDR_SIZE);
 +		cvs_set_amr_rate.hdr.src_port =
 +				voice_get_idx_for_session(v->session_id);
 +		cvs_set_amr_rate.hdr.dest_port = cvs_handle;
 +		cvs_set_amr_rate.hdr.token = 0;
 +		cvs_set_amr_rate.hdr.opcode =
 +					VSS_ISTREAM_CMD_VOC_AMR_SET_ENC_RATE;
 +		cvs_set_amr_rate.amr_rate.mode = common.mvs_info.rate;
 +
 +		v->cvs_state = CMD_STATUS_FAIL;
 +
 +		ret = apr_send_pkt(apr_cvs, (uint32_t *) &cvs_set_amr_rate);
 +		if (ret < 0) {
 +			pr_err("%s: Error %d sending SET_AMR_RATE\n",
 +			       __func__, ret);
 +			goto fail;
 +		}
 +		ret = wait_event_timeout(v->cvs_wait,
 +					 (v->cvs_state == CMD_STATUS_SUCCESS),
 +					 msecs_to_jiffies(TIMEOUT_MS));
 +		if (!ret) {
 +			pr_err("%s: wait_event timeout\n", __func__);
 +			goto fail;
 +		}
 +
 +		ret = voice_set_dtx(v);
 +		if (ret < 0)
 +			goto fail;
 +
 +		break;
 +	}
 +	case VSS_MEDIA_ID_AMR_WB_MODEM: {
 +		struct cvs_set_amrwb_enc_rate_cmd cvs_set_amrwb_rate;
 +
 +		pr_debug("Setting AMR WB rate\n");
 +
 +		cvs_set_amrwb_rate.hdr.hdr_field =
 +				APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
 +				APR_HDR_LEN(APR_HDR_SIZE),
 +				APR_PKT_VER);
 +		cvs_set_amrwb_rate.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
 +						sizeof(cvs_set_amrwb_rate) -
 +						APR_HDR_SIZE);
 +		cvs_set_amrwb_rate.hdr.src_port =
 +				voice_get_idx_for_session(v->session_id);
 +		cvs_set_amrwb_rate.hdr.dest_port = cvs_handle;
 +		cvs_set_amrwb_rate.hdr.token = 0;
 +		cvs_set_amrwb_rate.hdr.opcode =
 +					VSS_ISTREAM_CMD_VOC_AMRWB_SET_ENC_RATE;
 +		cvs_set_amrwb_rate.amrwb_rate.mode = common.mvs_info.rate;
 +
 +		v->cvs_state = CMD_STATUS_FAIL;
 +
 +		ret = apr_send_pkt(apr_cvs, (uint32_t *) &cvs_set_amrwb_rate);
 +		if (ret < 0) {
 +			pr_err("%s: Error %d sending SET_AMRWB_RATE\n",
 +			       __func__, ret);
 +			goto fail;
 +		}
 +		ret = wait_event_timeout(v->cvs_wait,
 +					 (v->cvs_state == CMD_STATUS_SUCCESS),
 +					 msecs_to_jiffies(TIMEOUT_MS));
 +		if (!ret) {
 +			pr_err("%s: wait_event timeout\n", __func__);
++=======
+ 	case VSS_MEDIA_ID_AMR_NB_MODEM:
+ 	case VSS_MEDIA_ID_AMR_WB_MODEM: {
+ 		ret = voice_config_cvs_vocoder_amr_rate(v);
+ 		if (ret) {
+ 			pr_err("%s: Failed to update vocoder rate. %d\n",
+ 			       __func__, ret);
+ 
++>>>>>>> FETCH_HEAD
  			goto fail;
  		}
  
@@@ -1717,6 -1727,31 +1821,34 @@@ fail
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ int voc_update_amr_vocoder_rate(uint32_t session_id)
+ {
+ 	int ret = 0;
+ 	struct voice_data *v;
+ 
+ 	pr_debug("%s: session_id:%d", __func__, session_id);
+ 
+ 	v = voice_get_session(session_id);
+ 
+ 	if (v == NULL) {
+ 		pr_err("%s: v is NULL, session_id:%d\n", __func__,
+ 		       session_id);
+ 
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+ 
+ 	mutex_lock(&v->lock);
+ 	ret = voice_config_cvs_vocoder_amr_rate(v);
+ 	mutex_unlock(&v->lock);
+ 
+ done:
+ 	return ret;
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int voice_send_start_voice_cmd(struct voice_data *v)
  {
  	struct apr_hdr mvm_start_voice_cmd;
@@@ -1886,10 -1921,18 +2018,25 @@@ static int voice_send_set_device_cmd(st
  
  	cvp_setdev_cmd.cvp_set_device_v2.tx_port_id = v->dev_tx.port_id;
  	cvp_setdev_cmd.cvp_set_device_v2.rx_port_id = v->dev_rx.port_id;
++<<<<<<< HEAD
 +	cvp_setdev_cmd.cvp_set_device_v2.vocproc_mode =
 +				    VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING;
 +	cvp_setdev_cmd.cvp_set_device_v2.ec_ref_port_id =
 +				    VSS_IVOCPROC_PORT_ID_NONE;
++=======
+ 
+ 	if (common.ec_ref_ext) {
+ 		cvp_setdev_cmd.cvp_set_device_v2.vocproc_mode =
+ 				VSS_IVOCPROC_VOCPROC_MODE_EC_EXT_MIXING;
+ 		cvp_setdev_cmd.cvp_set_device_v2.ec_ref_port_id =
+ 				common.ec_port_id;
+ 	} else {
+ 		cvp_setdev_cmd.cvp_set_device_v2.vocproc_mode =
+ 				    VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING;
+ 		cvp_setdev_cmd.cvp_set_device_v2.ec_ref_port_id =
+ 				    VSS_IVOCPROC_PORT_ID_NONE;
+ 	}
++>>>>>>> FETCH_HEAD
  	pr_debug("topology=%d , tx_port_id=%d, rx_port_id=%d\n",
  		cvp_setdev_cmd.cvp_set_device_v2.tx_topology_id,
  		cvp_setdev_cmd.cvp_set_device_v2.tx_port_id,
@@@ -3111,10 -3154,17 +3258,24 @@@ static int voice_setup_vocproc(struct v
  	cvp_session_cmd.cvp_session.rx_port_id = v->dev_rx.port_id;
  	cvp_session_cmd.cvp_session.profile_id =
  					 VSS_ICOMMON_CAL_NETWORK_ID_NONE;
++<<<<<<< HEAD
 +	cvp_session_cmd.cvp_session.vocproc_mode =
 +				 VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING;
 +	cvp_session_cmd.cvp_session.ec_ref_port_id =
 +						 VSS_IVOCPROC_PORT_ID_NONE;
++=======
+ 	if (common.ec_ref_ext) {
+ 		cvp_session_cmd.cvp_session.vocproc_mode =
+ 				VSS_IVOCPROC_VOCPROC_MODE_EC_EXT_MIXING;
+ 		cvp_session_cmd.cvp_session.ec_ref_port_id =
+ 					common.ec_port_id;
+ 	} else {
+ 		cvp_session_cmd.cvp_session.vocproc_mode =
+ 				 VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING;
+ 		cvp_session_cmd.cvp_session.ec_ref_port_id =
+ 						 VSS_IVOCPROC_PORT_ID_NONE;
+ 	}
++>>>>>>> FETCH_HEAD
  
  	pr_debug("tx_topology: %d tx_port_id=%d, rx_port_id=%d, mode: 0x%x\n",
  		cvp_session_cmd.cvp_session.tx_topology_id,
@@@ -3473,6 -3523,10 +3634,13 @@@ static int voice_destroy_vocproc(struc
  	mvm_handle = voice_get_mvm_handle(v);
  	cvp_handle = voice_get_cvp_handle(v);
  
++<<<<<<< HEAD
++=======
+ 	/* disable slowtalk if st_enable is set */
+ 	if (v->st_enable)
+ 		voice_send_set_pp_enable_cmd(v, MODULE_ID_VOICE_MODULE_ST, 0);
+ 
++>>>>>>> FETCH_HEAD
  	/* stop playback or recording */
  	v->music_info.force = 1;
  	voice_cvs_stop_playback(v);
@@@ -3949,8 -4003,15 +4117,20 @@@ static int voice_cvs_start_record(struc
  		cvs_start_record.hdr.token = 0;
  		cvs_start_record.hdr.opcode = VSS_IRECORD_CMD_START;
  
++<<<<<<< HEAD
 +		cvs_start_record.rec_mode.port_id =
 +					VSS_IRECORD_PORT_ID_DEFAULT;
++=======
+ 		// In order to enable stereo recording,
+ 		// i.e. TX on the left and RX on the right
+ 		// the respective ports need to be explicitly specified:
+ 		// INCALL_RECORD_TX => 0x8003
+ 		// INCALL_RECORD_RX => 0x8004
+ 		/*cvs_start_record.rec_mode.port_id =
+ 					VSS_IRECORD_PORT_ID_DEFAULT; */
+ 		cvs_start_record.rec_mode.port_id =
+ 					VSS_IRECORD_PORT_ID_TX_RX;
++>>>>>>> FETCH_HEAD
  		if (rec_mode == VOC_REC_UPLINK) {
  			cvs_start_record.rec_mode.rx_tap_point =
  					VSS_IRECORD_TAP_POINT_NONE;
@@@ -3974,6 -4035,9 +4154,12 @@@
  			goto fail;
  		}
  
++<<<<<<< HEAD
++=======
+ 		// request stereo recording
+ 		cvs_start_record.rec_mode.mode = VSS_IRECORD_MODE_TX_RX_STEREO;
+ 
++>>>>>>> FETCH_HEAD
  		v->cvs_state = CMD_STATUS_FAIL;
  
  		ret = apr_send_pkt(apr_cvs, (uint32_t *) &cvs_start_record);
@@@ -4342,8 -4406,10 +4528,15 @@@ int voc_start_playback(uint32_t set, ui
  		v = voice_get_session(voc_get_session_id(VOICE_SESSION_NAME));
  	else if (port_id == VOICE2_PLAYBACK_TX)
  		v = voice_get_session(voc_get_session_id(VOICE2_SESSION_NAME));
++<<<<<<< HEAD
 +
 +	if (v != NULL) {
++=======
+ 	else
+ 		pr_err("%s: Invalid port_id 0x%x", __func__, port_id);
+ 
+ 	while (v != NULL) {
++>>>>>>> FETCH_HEAD
  		mutex_lock(&v->lock);
  		v->music_info.port_id = port_id;
  		v->music_info.play_enable = set;
@@@ -4363,8 -4429,17 +4556,22 @@@
  		}
  
  		mutex_unlock(&v->lock);
++<<<<<<< HEAD
 +	} else {
 +		pr_err("%s: Invalid port_id 0x%x", __func__, port_id);
++=======
+ 
+ 		/* Voice and VoLTE call use the same pseudo port and hence
+ 		 * use the same mixer control. So enable incall delivery
+ 		 * for VoLTE as well with Voice.
+ 		 */
+ 		if (is_voice_session(v->session_id)) {
+ 			v = voice_get_session(voc_get_session_id(
+ 							VOLTE_SESSION_NAME));
+ 		} else {
+ 			break;
+ 		}
++>>>>>>> FETCH_HEAD
  	}
  
  	return ret;
@@@ -4398,7 -4473,8 +4605,12 @@@ int voc_disable_cvp(uint32_t session_id
  
  		v->voc_state = VOC_CHANGE;
  	}
++<<<<<<< HEAD
 +
++=======
+ 	if (common.ec_ref_ext)
+ 		voc_set_ext_ec_ref(AFE_PORT_INVALID, false);
++>>>>>>> FETCH_HEAD
  fail:	mutex_unlock(&v->lock);
  
  	return ret;
@@@ -4560,8 -4636,8 +4772,13 @@@ int voc_set_tx_mute(uint32_t session_id
  	return ret;
  }
  
++<<<<<<< HEAD
 +int voc_set_rx_device_mute(uint32_t session_id, uint32_t mute,
 +					uint32_t ramp_duration)
++=======
+ int voc_set_device_mute(uint32_t session_id, uint32_t dir, uint32_t mute,
+ 			uint32_t ramp_duration)
++>>>>>>> FETCH_HEAD
  {
  	struct voice_data *v = NULL;
  	int ret = 0;
@@@ -4571,16 -4647,23 +4788,35 @@@
  	while (voice_itr_get_next_session(&itr, &v)) {
  		if (v != NULL) {
  			mutex_lock(&v->lock);
++<<<<<<< HEAD
 +			v->dev_rx.dev_mute = mute;
 +			v->dev_rx.dev_mute_ramp_duration_ms =
 +							ramp_duration;
++=======
+ 			if (dir == VSS_IVOLUME_DIRECTION_TX) {
+ 				v->dev_tx.dev_mute = mute;
+ 				v->dev_tx.dev_mute_ramp_duration_ms =
+ 							ramp_duration;
+ 			} else {
+ 				v->dev_rx.dev_mute = mute;
+ 				v->dev_rx.dev_mute_ramp_duration_ms =
+ 							ramp_duration;
+ 			}
+ 
++>>>>>>> FETCH_HEAD
  			if (((v->voc_state == VOC_RUN) ||
  				(v->voc_state == VOC_STANDBY)) &&
  				(v->lch_mode == 0))
  				ret = voice_send_device_mute_cmd(v,
++<<<<<<< HEAD
 +						VSS_IVOLUME_DIRECTION_RX,
 +						v->dev_rx.dev_mute,
 +						ramp_duration);
++=======
+ 							dir,
+ 							mute,
+ 							ramp_duration);
++>>>>>>> FETCH_HEAD
  			mutex_unlock(&v->lock);
  		} else {
  			pr_err("%s: invalid session_id 0x%x\n", __func__,
@@@ -4850,6 -4933,8 +5086,11 @@@ int voc_end_voice_call(uint32_t session
  
  		ret = -EINVAL;
  	}
++<<<<<<< HEAD
++=======
+ 	if (common.ec_ref_ext)
+ 		voc_set_ext_ec_ref(AFE_PORT_INVALID, false);
++>>>>>>> FETCH_HEAD
  
  	mutex_unlock(&v->lock);
  	return ret;
@@@ -5077,6 -5162,28 +5318,31 @@@ fail
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ int voc_set_ext_ec_ref(uint16_t port_id, bool state)
+ {
+ 	int ret = 0;
+ 
+ 	mutex_lock(&common.common_lock);
+ 	if (state == true) {
+ 		if (port_id == AFE_PORT_INVALID) {
+ 			pr_err("%s: Invalid port id", __func__);
+ 			ret = -EINVAL;
+ 			goto exit;
+ 		}
+ 		common.ec_port_id = port_id;
+ 		common.ec_ref_ext = true;
+ 	} else {
+ 		common.ec_ref_ext = false;
+ 		common.ec_port_id = port_id;
+ 	}
+ exit:
+ 	mutex_unlock(&common.common_lock);
+ 	return ret;
+ }
+ 
++>>>>>>> FETCH_HEAD
  void voc_register_mvs_cb(ul_cb_fn ul_cb,
  			   dl_cb_fn dl_cb,
  			   void *private_data)
@@@ -6046,7 -6153,7 +6312,11 @@@ static int __init voice_init(void
  	common.default_vol_step_val = 0;
  	common.default_vol_ramp_duration_ms = DEFAULT_VOLUME_RAMP_DURATION;
  	common.default_mute_ramp_duration_ms = DEFAULT_MUTE_RAMP_DURATION;
++<<<<<<< HEAD
 +
++=======
+ 	common.ec_ref_ext = false;
++>>>>>>> FETCH_HEAD
  	/* Initialize MVS info. */
  	common.mvs_info.network_type = VSS_NETWORK_ID_DEFAULT;
  
diff --cc sound/soc/msm/qdsp6v2/q6voice.h
index c67581b,403d5c8..0000000
--- a/sound/soc/msm/qdsp6v2/q6voice.h
+++ b/sound/soc/msm/qdsp6v2/q6voice.h
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
++=======
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
++>>>>>>> FETCH_HEAD
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 and
@@@ -520,6 -520,9 +524,12 @@@ struct vss_imemory_cmd_unmap_t 
  #define VSS_IRECORD_PORT_ID_DEFAULT			0x0000FFFF
  /* Default AFE port ID. */
  
++<<<<<<< HEAD
++=======
+ #define VSS_IRECORD_PORT_ID_TX_RX			0x00008003
+ /* Port explicitly identifying TX and RX streams */
+ 
++>>>>>>> FETCH_HEAD
  #define VSS_IRECORD_TAP_POINT_NONE			0x00010F78
  /* Indicates no tapping for specified path. */
  
@@@ -1394,6 -1397,8 +1404,11 @@@ struct common_data 
  	uint32_t default_vol_step_val;
  	uint32_t default_vol_ramp_duration_ms;
  	uint32_t default_mute_ramp_duration_ms;
++<<<<<<< HEAD
++=======
+ 	bool ec_ref_ext;
+ 	uint16_t ec_port_id;
++>>>>>>> FETCH_HEAD
  
  	/* APR to MVM in the Q6 */
  	void *apr_q6_mvm;
@@@ -1510,8 -1515,8 +1525,13 @@@ int voc_set_rx_vol_step(uint32_t sessio
  			uint32_t ramp_duration);
  int voc_set_tx_mute(uint32_t session_id, uint32_t dir, uint32_t mute,
  		    uint32_t ramp_duration);
++<<<<<<< HEAD
 +int voc_set_rx_device_mute(uint32_t session_id, uint32_t mute,
 +			   uint32_t ramp_duration);
++=======
+ int voc_set_device_mute(uint32_t session_id, uint32_t dir, uint32_t mute,
+ 			uint32_t ramp_duration);
++>>>>>>> FETCH_HEAD
  int voc_get_rx_device_mute(uint32_t session_id);
  int voc_disable_cvp(uint32_t session_id);
  int voc_enable_cvp(uint32_t session_id);
@@@ -1536,4 -1541,7 +1556,10 @@@ int voc_start_record(uint32_t port_id, 
  int voice_get_idx_for_session(u32 session_id);
  int voc_get_loopback_enable(void);
  void voc_set_loopback_enable(int loopback_enable);
++<<<<<<< HEAD
++=======
+ int voc_set_ext_ec_ref(uint16_t port_id, bool state);
+ int voc_update_amr_vocoder_rate(uint32_t session_id);
+ 
++>>>>>>> FETCH_HEAD
  #endif
diff --cc sound/soc/msm/qdsp6v2/rtac.c
index ecc0145,8d2e1d4..0000000
mode 100755,100644..100755
--- a/sound/soc/msm/qdsp6v2/rtac.c
+++ b/sound/soc/msm/qdsp6v2/rtac.c
@@@ -100,6 -100,28 +100,31 @@@ struct rtac_adm 
  	struct rtac_adm_data	device[RTAC_MAX_ACTIVE_DEVICES];
  };
  static struct rtac_adm		rtac_adm_data;
++<<<<<<< HEAD
++=======
+ 
+ 
+ /* ADM V2 data */
+ struct rtac_popp_data {
+ 	uint32_t	popp;
+ 	uint32_t	popp_topology;
+ };
+ 
+ struct rtac_adm_data_v2 {
+ 	uint32_t		topology_id;
+ 	uint32_t		afe_port;
+ 	uint32_t		copp;
+ 	uint32_t		num_of_popp;
+ 	struct rtac_popp_data	popp[RTAC_MAX_ACTIVE_POPP];
+ };
+ 
+ struct rtac_adm_v2 {
+ 	uint32_t			num_of_dev;
+ 	struct rtac_adm_data_v2		device[RTAC_MAX_ACTIVE_DEVICES];
+ };
+ 
+ static struct rtac_adm_v2	rtac_adm_data_v2;
++>>>>>>> FETCH_HEAD
  static u32			*rtac_adm_buffer;
  
  
@@@ -356,6 -378,147 +381,150 @@@ done
  	return result;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* ADM Info V2 */
+ static void add_popp_v2(u32 dev_idx, u32 port_id, u32 popp_id)
+ {
+ 	u32 i = 0;
+ 
+ 	for (; i < rtac_adm_data_v2.device[dev_idx].num_of_popp; i++)
+ 		if (rtac_adm_data_v2.device[dev_idx].popp[i].popp == popp_id)
+ 			goto done;
+ 
+ 	if (rtac_adm_data_v2.device[dev_idx].num_of_popp ==
+ 			RTAC_MAX_ACTIVE_POPP) {
+ 		pr_err("%s, Max POPP!\n", __func__);
+ 		goto done;
+ 	}
+ 	rtac_adm_data_v2.device[dev_idx].popp[
+ 		rtac_adm_data_v2.device[dev_idx].num_of_popp].popp = popp_id;
+ 	rtac_adm_data_v2.device[dev_idx].popp[
+ 		rtac_adm_data_v2.device[dev_idx].num_of_popp++].popp_topology =
+ 		get_asm_topology();
+ done:
+ 	return;
+ }
+ 
+ static void rtac_add_adm_device_v2(u32 port_id, u32 copp_id, u32 path_id,
+ 								u32 popp_id)
+ {
+ 	u32 i = 0;
+ 	pr_debug("%s: port_id = %d, popp_id = %d\n", __func__, port_id,
+ 		popp_id);
+ 
+ 	if (rtac_adm_data_v2.num_of_dev == RTAC_MAX_ACTIVE_DEVICES) {
+ 		pr_err("%s, Can't add anymore RTAC devices!\n", __func__);
+ 		goto done;
+ 	}
+ 
+ 	/* Check if device already added */
+ 	if (rtac_adm_data_v2.num_of_dev != 0) {
+ 		for (; i < rtac_adm_data_v2.num_of_dev; i++) {
+ 			if (rtac_adm_data_v2.device[i].afe_port == port_id) {
+ 				add_popp_v2(i, port_id, popp_id);
+ 				goto done;
+ 			}
+ 			if (rtac_adm_data_v2.device[i].num_of_popp ==
+ 						RTAC_MAX_ACTIVE_POPP) {
+ 				pr_err("%s, Max POPP!\n", __func__);
+ 				goto done;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Add device */
+ 	rtac_adm_data_v2.num_of_dev++;
+ 
+ 	if (path_id == ADM_PATH_PLAYBACK)
+ 		rtac_adm_data_v2.device[i].topology_id =
+ 						get_adm_rx_topology();
+ 	else
+ 		rtac_adm_data_v2.device[i].topology_id =
+ 						get_adm_tx_topology();
+ 	rtac_adm_data_v2.device[i].afe_port = port_id;
+ 	rtac_adm_data_v2.device[i].copp = copp_id;
+ 	rtac_adm_data_v2.device[i].popp[
+ 		rtac_adm_data_v2.device[i].num_of_popp].popp = popp_id;
+ 	rtac_adm_data_v2.device[i].popp[
+ 		rtac_adm_data_v2.device[i].num_of_popp++].popp_topology =
+ 		get_asm_topology();
+ done:
+ 	return;
+ }
+ 
+ static void shift_adm_devices_v2(u32 dev_idx)
+ {
+ 	for (; dev_idx < rtac_adm_data_v2.num_of_dev; dev_idx++) {
+ 		memcpy(&rtac_adm_data_v2.device[dev_idx],
+ 			&rtac_adm_data_v2.device[dev_idx + 1],
+ 			sizeof(rtac_adm_data_v2.device[dev_idx]));
+ 		memset(&rtac_adm_data_v2.device[dev_idx + 1], 0,
+ 			   sizeof(rtac_adm_data_v2.device[dev_idx]));
+ 	}
+ }
+ 
+ static void shift_popp_v2(u32 copp_idx, u32 popp_idx)
+ {
+ 	for (; popp_idx < rtac_adm_data_v2.device[copp_idx].num_of_popp;
+ 							popp_idx++) {
+ 		memcpy(&rtac_adm_data_v2.device[copp_idx].popp[popp_idx].popp,
+ 			&rtac_adm_data_v2.device[copp_idx].popp[popp_idx + 1].
+ 			popp, sizeof(uint32_t));
+ 		memcpy(&rtac_adm_data_v2.device[copp_idx].popp[popp_idx].
+ 			popp_topology,
+ 			&rtac_adm_data_v2.device[copp_idx].popp[popp_idx + 1].
+ 			popp_topology,
+ 			sizeof(uint32_t));
+ 		memset(&rtac_adm_data_v2.device[copp_idx].popp[popp_idx + 1].
+ 			popp, 0, sizeof(uint32_t));
+ 		memset(&rtac_adm_data_v2.device[copp_idx].popp[popp_idx + 1].
+ 			popp_topology, 0, sizeof(uint32_t));
+ 	}
+ }
+ 
+ static void rtac_remove_adm_device_v2(u32 port_id)
+ {
+ 	s32 i;
+ 	pr_debug("%s: port_id = %d\n", __func__, port_id);
+ 
+ 	/* look for device */
+ 	for (i = 0; i < rtac_adm_data_v2.num_of_dev; i++) {
+ 		if (rtac_adm_data_v2.device[i].afe_port == port_id) {
+ 			memset(&rtac_adm_data_v2.device[i], 0,
+ 				   sizeof(rtac_adm_data_v2.device[i]));
+ 			rtac_adm_data_v2.num_of_dev--;
+ 
+ 			if (rtac_adm_data_v2.num_of_dev >= 1) {
+ 				shift_adm_devices_v2(i);
+ 				break;
+ 			}
+ 		}
+ 	}
+ 	return;
+ }
+ 
+ static void rtac_remove_popp_from_adm_devices_v2(u32 popp_id)
+ {
+ 	s32 i, j;
+ 	pr_debug("%s: popp_id = %d\n", __func__, popp_id);
+ 
+ 	for (i = 0; i < rtac_adm_data_v2.num_of_dev; i++) {
+ 		for (j = 0; j < rtac_adm_data_v2.device[i].num_of_popp; j++) {
+ 			if (rtac_adm_data_v2.device[i].popp[j].popp ==
+ 								popp_id) {
+ 				rtac_adm_data_v2.device[i].popp[j].popp = 0;
+ 				rtac_adm_data_v2.device[i].popp[j].
+ 					popp_topology = 0;
+ 				rtac_adm_data_v2.device[i].num_of_popp--;
+ 				shift_popp_v2(i, j);
+ 			}
+ 		}
+ 	}
+ }
+ 
++>>>>>>> FETCH_HEAD
  /* ADM Info */
  void add_popp(u32 dev_idx, u32 port_id, u32 popp_id)
  {
@@@ -383,6 -546,8 +552,11 @@@ void rtac_add_adm_device(u32 port_id, u
  		popp_id);
  
  	mutex_lock(&rtac_adm_mutex);
++<<<<<<< HEAD
++=======
+ 	rtac_add_adm_device_v2(port_id, copp_id, path_id, popp_id);
+ 
++>>>>>>> FETCH_HEAD
  	if (rtac_adm_data.num_of_dev == RTAC_MAX_ACTIVE_DEVICES) {
  		pr_err("%s, Can't add anymore RTAC devices!\n", __func__);
  		goto done;
@@@ -391,7 -556,8 +565,12 @@@
  	/* Check if device already added */
  	if (rtac_adm_data.num_of_dev != 0) {
  		for (; i < rtac_adm_data.num_of_dev; i++) {
++<<<<<<< HEAD
 +			if (rtac_adm_data.device[i].afe_port == port_id) {
++=======
+ 			if (rtac_adm_data.device[i].afe_port == port_id &&
+ 			    rtac_adm_data.device[i].copp == copp_id) {
++>>>>>>> FETCH_HEAD
  				add_popp(i, port_id, popp_id);
  				goto done;
  			}
@@@ -440,19 -606,22 +619,36 @@@ static void shift_popp(u32 copp_idx, u3
  			&rtac_adm_data.device[copp_idx].popp[popp_idx + 1],
  			sizeof(uint32_t));
  		memset(&rtac_adm_data.device[copp_idx].popp[popp_idx + 1], 0,
++<<<<<<< HEAD
 +			   sizeof(uint32_t));
 +	}
 +}
 +
 +void rtac_remove_adm_device(u32 port_id)
++=======
+ 			sizeof(uint32_t));
+ 	}
+ }
+ 
+ void rtac_remove_adm_device(u32 port_id, u32 copp_id)
++>>>>>>> FETCH_HEAD
  {
  	s32 i;
  	pr_debug("%s: port_id = %d\n", __func__, port_id);
  
  	mutex_lock(&rtac_adm_mutex);
++<<<<<<< HEAD
 +	/* look for device */
 +	for (i = 0; i < rtac_adm_data.num_of_dev; i++) {
 +		if (rtac_adm_data.device[i].afe_port == port_id) {
++=======
+ 	rtac_remove_adm_device_v2(port_id);
+ 
+ 	/* look for device */
+ 	for (i = 0; i < rtac_adm_data.num_of_dev; i++) {
+ 		if (rtac_adm_data.device[i].afe_port == port_id &&
+ 		    rtac_adm_data.device[i].copp == copp_id) {
++>>>>>>> FETCH_HEAD
  			memset(&rtac_adm_data.device[i], 0,
  				   sizeof(rtac_adm_data.device[i]));
  			rtac_adm_data.num_of_dev--;
@@@ -474,6 -643,7 +670,10 @@@ void rtac_remove_popp_from_adm_devices(
  	pr_debug("%s: popp_id = %d\n", __func__, popp_id);
  
  	mutex_lock(&rtac_adm_mutex);
++<<<<<<< HEAD
++=======
+ 	rtac_remove_popp_from_adm_devices_v2(popp_id);
++>>>>>>> FETCH_HEAD
  
  	for (i = 0; i < rtac_adm_data.num_of_dev; i++) {
  		for (j = 0; j < rtac_adm_data.device[i].num_of_popp; j++) {
@@@ -702,6 -872,8 +902,11 @@@ u32 send_adm_apr(void *buf, u32 opcode
  	for (port_index = 0; port_index < AFE_MAX_PORTS; port_index++) {
  		if (adm_get_copp_id(port_index) == copp_id)
  			break;
++<<<<<<< HEAD
++=======
+ 		if (adm_get_lowlatency_copp_id(port_index) == copp_id)
+ 			break;
++>>>>>>> FETCH_HEAD
  	}
  	if (port_index >= AFE_MAX_PORTS) {
  		pr_err("%s: Could not find port index for copp = %d\n",
@@@ -1269,6 -1441,13 +1474,16 @@@ static long rtac_ioctl(struct file *f
  		else
  			result = sizeof(rtac_adm_data);
  		break;
++<<<<<<< HEAD
++=======
+ 	case AUDIO_GET_RTAC_ADM_INFO_V2:
+ 		if (copy_to_user((void *)arg, &rtac_adm_data_v2,
+ 						sizeof(rtac_adm_data_v2)))
+ 			pr_err("%s: Could not copy to userspace!\n", __func__);
+ 		else
+ 			result = sizeof(rtac_adm_data_v2);
+ 		break;
++>>>>>>> FETCH_HEAD
  	case AUDIO_GET_RTAC_VOICE_INFO:
  		if (copy_to_user((void *)arg, &rtac_voice_data,
  						sizeof(rtac_voice_data)))
@@@ -1339,6 -1518,7 +1554,10 @@@ static int __init rtac_init(void
  
  	/* ADM */
  	memset(&rtac_adm_data, 0, sizeof(rtac_adm_data));
++<<<<<<< HEAD
++=======
+ 	memset(&rtac_adm_data_v2, 0, sizeof(rtac_adm_data_v2));
++>>>>>>> FETCH_HEAD
  	rtac_adm_apr_data.apr_handle = NULL;
  	atomic_set(&rtac_adm_apr_data.cmd_state, 0);
  	init_waitqueue_head(&rtac_adm_apr_data.cmd_wait);
diff --cc sound/soc/soc-compress.c
index 0970a83,781d45a..0000000
--- a/sound/soc/soc-compress.c
+++ b/sound/soc/soc-compress.c
@@@ -469,55 -469,139 +469,185 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void dpcm_be_hw_params_prepare(void *data)
+ {
+ 	struct snd_compr_stream *cstream = data;
+ 	struct snd_soc_pcm_runtime *fe = cstream->private_data;
+ 	struct snd_soc_pcm_runtime *be = cstream->be;
+ 	int stream, ret;
+ 
+ 	if (cstream->direction == SND_COMPRESS_PLAYBACK)
+ 		stream = SNDRV_PCM_STREAM_PLAYBACK;
+ 	else
+ 		stream = SNDRV_PCM_STREAM_CAPTURE;
+ 
+ 	ret = dpcm_fe_dai_hw_params_be(fe, be,
+ 		    &fe->dpcm[stream].hw_params, stream);
+ 	if (ret < 0) {
+ 		fe->err_ops = ret;
+ 		return;
+ 	}
+ 
+ 	ret = dpcm_fe_dai_prepare_be(fe, be, stream);
+ 	if (ret < 0) {
+ 		fe->err_ops = ret;
+ 		return;
+ 	}
+ }
+ 
+ static void dpcm_be_hw_params_prepare_async(void *data, async_cookie_t cookie)
+ {
+ 	dpcm_be_hw_params_prepare(data);
+ }
+ 
++>>>>>>> FETCH_HEAD
  static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,
  					struct snd_compr_params *params)
  {
  	struct snd_soc_pcm_runtime *fe = cstream->private_data;
  	struct snd_pcm_substream *fe_substream = fe->pcm->streams[0].substream;
  	struct snd_soc_platform *platform = fe->platform;
++<<<<<<< HEAD
 +	struct snd_pcm_hw_params *hw_params;
 +	int ret = 0, stream;
++=======
+ 	struct snd_soc_pcm_runtime *be_list[DPCM_MAX_BE_USERS];
+ 	struct snd_soc_dpcm_params *dpcm;
+ 	int ret = 0, stream, i, j = 0;
+ 	ASYNC_DOMAIN_EXCLUSIVE(async_domain);
++>>>>>>> FETCH_HEAD
  
  	if (cstream->direction == SND_COMPRESS_PLAYBACK)
  		stream = SNDRV_PCM_STREAM_PLAYBACK;
  	else
  		stream = SNDRV_PCM_STREAM_CAPTURE;
  
++<<<<<<< HEAD
 +	hw_params = kzalloc(sizeof(*hw_params), GFP_KERNEL);
 +	if (hw_params == NULL)
 +		return -ENOMEM;
 +
 +	mutex_lock(&fe->card->dpcm_mutex);
 +	/* first we call set_params for the platform driver
 +	 * this should configure the soc side
 +	 * if the machine has compressed ops then we call that as well
 +	 * expectation is that platform and machine will configure everything
 +	 * for this compress path, like configuring pcm port for codec
 +	 */
 +	if (platform->driver->compr_ops && platform->driver->compr_ops->set_params) {
 +		ret = platform->driver->compr_ops->set_params(cstream, params);
 +		if (ret < 0)
 +			goto out;
 +	}
 +
 +	if (fe->dai_link->compr_ops && fe->dai_link->compr_ops->set_params) {
 +		ret = fe->dai_link->compr_ops->set_params(cstream);
 +		if (ret < 0)
 +			goto out;
 +	}
 +
 +	memcpy(&fe->dpcm[fe_substream->stream].hw_params, params,
 +			sizeof(struct snd_pcm_hw_params));
 +
 +	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 +
 +	ret = dpcm_be_dai_hw_params(fe, stream);
 +	if (ret < 0)
 +		goto out;
 +
 +	ret = dpcm_be_dai_prepare(fe, stream);
 +	if (ret < 0)
 +		goto out;
++=======
+ 	mutex_lock(&fe->card->dpcm_mutex);
+ 
+ 	if (!(fe->dai_link->async_ops & ASYNC_DPCM_SND_SOC_HW_PARAMS)) {
+ 		/* first we call set_params for the platform driver
+ 		 * this should configure the soc side
+ 		 * if the machine has compressed ops then we call that as well
+ 		 * expectation is that platform and machine will configure
+ 		 * everything for this compress path, like configuring pcm
+ 		 * port for codec
+ 		 */
+ 		if (platform->driver->compr_ops &&
+ 				platform->driver->compr_ops->set_params) {
+ 			ret = platform->driver->compr_ops->set_params(cstream,
+ 								params);
+ 			if (ret < 0)
+ 				goto out;
+ 		}
+ 
+ 		if (fe->dai_link->compr_ops &&
+ 					fe->dai_link->compr_ops->set_params) {
+ 			ret = fe->dai_link->compr_ops->set_params(cstream);
+ 			if (ret < 0)
+ 				goto out;
+ 		}
+ 
+ 		memcpy(&fe->dpcm[fe_substream->stream].hw_params, params,
+ 				sizeof(struct snd_pcm_hw_params));
+ 
+ 		fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
+ 
+ 		ret = dpcm_be_dai_hw_params(fe, stream);
+ 		if (ret < 0)
+ 			goto out;
+ 
+ 		ret = dpcm_be_dai_prepare(fe, stream);
+ 		if (ret < 0)
+ 			goto out;
+ 	} else {
+ 		memcpy(&fe->dpcm[fe_substream->stream].hw_params, params,
+ 				sizeof(struct snd_pcm_hw_params));
+ 
+ 		fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
+ 
+ 		list_for_each_entry(dpcm,
+ 				&fe->dpcm[stream].be_clients, list_be) {
+ 			struct snd_soc_pcm_runtime *be = dpcm->be;
+ 			if (be->dai_link->async_ops &
+ 				ASYNC_DPCM_SND_SOC_HW_PARAMS) {
+ 				cstream->be = be;
+ 				async_schedule_domain(
+ 				dpcm_be_hw_params_prepare_async,
+ 				cstream, &async_domain);
+ 			} else {
+ 				be_list[j++] = be;
+ 			}
+ 		}
+ 		for (i = 0; i < j; i++) {
+ 			cstream->be = be_list[i];
+ 			dpcm_be_hw_params_prepare(cstream);
+ 		}
+ 		/* first we call set_params for the platform driver
+ 		 * this should configure the soc side
+ 		 * if the machine has compressed ops then we call that as well
+ 		 * expectation is that platform and machine will configure
+ 		 * everything this compress path, like configuring pcm port
+ 		 * for codec
+ 		 */
+ 		if (platform->driver->compr_ops &&
+ 				platform->driver->compr_ops->set_params) {
+ 			ret = platform->driver->compr_ops->set_params(cstream,
+ 								    params);
+ 			if (ret < 0)
+ 				goto exit;
+ 		}
+ 
+ 		if (fe->dai_link->compr_ops &&
+ 				fe->dai_link->compr_ops->set_params) {
+ 			ret = fe->dai_link->compr_ops->set_params(cstream);
+ 			if (ret < 0)
+ 				goto exit;
+ 		}
+ exit:
+ 		async_synchronize_full_domain(&async_domain);
+ 		if (fe->err_ops < 0 || ret < 0)
+ 			goto out;
+ 	}
++>>>>>>> FETCH_HEAD
  
  	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
  		dpcm_dapm_stream_event(fe, stream,
@@@ -604,14 -688,15 +734,25 @@@ static int soc_compr_pointer(struct snd
  {
  	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
  	struct snd_soc_platform *platform = rtd->platform;
++<<<<<<< HEAD
++=======
+ 	int ret = 0;
++>>>>>>> FETCH_HEAD
  
  	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
  
  	if (platform->driver->compr_ops && platform->driver->compr_ops->pointer)
++<<<<<<< HEAD
 +		 platform->driver->compr_ops->pointer(cstream, tstamp);
 +
 +	mutex_unlock(&rtd->pcm_mutex);
 +	return 0;
++=======
+ 		ret = platform->driver->compr_ops->pointer(cstream, tstamp);
+ 
+ 	mutex_unlock(&rtd->pcm_mutex);
+ 	return ret;
++>>>>>>> FETCH_HEAD
  }
  
  static int soc_compr_copy(struct snd_compr_stream *cstream,
diff --cc sound/soc/soc-dapm.c
index ca6f0b7,39bc67b..0000000
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@@ -1562,7 -1562,7 +1562,11 @@@ static int dapm_power_widgets(struct sn
  	struct snd_soc_dapm_context *d;
  	LIST_HEAD(up_list);
  	LIST_HEAD(down_list);
++<<<<<<< HEAD
 +	LIST_HEAD(async_domain);
++=======
+ 	ASYNC_DOMAIN_EXCLUSIVE(async_domain);
++>>>>>>> FETCH_HEAD
  	enum snd_soc_bias_level bias;
  
  	trace_snd_soc_dapm_start(card);
@@@ -1904,10 -1904,10 +1908,17 @@@ static int soc_dapm_mux_update_power(st
  	}
  
  	if (found) {
++<<<<<<< HEAD
 +	  		dapm_mark_dirty(widget, "mux change");
 +			dapm_power_widgets(widget->dapm,
 +					   SND_SOC_DAPM_STREAM_NOP);
 +		}
++=======
+ 		dapm_mark_dirty(widget, "mux change");
+ 		dapm_power_widgets(widget->dapm,
+ 			   SND_SOC_DAPM_STREAM_NOP);
+ 	}
++>>>>>>> FETCH_HEAD
  
  	return found;
  }
@@@ -1953,7 -1953,7 +1964,11 @@@ static int soc_dapm_mixer_update_power(
  	if (found) {
  		dapm_mark_dirty(widget, "mixer update");
  		dapm_power_widgets(widget->dapm, SND_SOC_DAPM_STREAM_NOP);
++<<<<<<< HEAD
 +	  }
++=======
+ 	}
++>>>>>>> FETCH_HEAD
  
  	return found;
  }
@@@ -2308,6 -2308,7 +2323,10 @@@ int snd_soc_dapm_add_routes(struct snd_
  		if (ret < 0) {
  			dev_err(dapm->dev, "Failed to add route %s->%s\n",
  				route->source, route->sink);
++<<<<<<< HEAD
++=======
+ 			mutex_unlock(&dapm->card->dapm_mutex);
++>>>>>>> FETCH_HEAD
  			return ret;
  		}
  		route++;
@@@ -3017,6 -3018,7 +3036,10 @@@ int snd_soc_dapm_new_controls(struct sn
  			dev_err(dapm->dev,
  				"ASoC: Failed to create DAPM control %s: %d\n",
  				widget->name, ret);
++<<<<<<< HEAD
++=======
+ 			mutex_unlock(&dapm->card->dapm_mutex);
++>>>>>>> FETCH_HEAD
  			return ret;
  		}
  		widget++;
@@@ -3136,7 -3138,6 +3159,10 @@@ int snd_soc_dapm_stream_event(struct sn
  
  	if (stream == NULL)
  		return 0;
++<<<<<<< HEAD
 +
++=======
++>>>>>>> FETCH_HEAD
  	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_PCM);
  	soc_dapm_stream_event(&codec->dapm, stream, event);
  	mutex_unlock(&card->dapm_mutex);
diff --cc sound/soc/soc-pcm.c
index 7aa319e,79946a3..0000000
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@@ -32,8 -32,6 +32,11 @@@
  #include <sound/soc-dpcm.h>
  #include <sound/initval.h>
  
++<<<<<<< HEAD
 +#define MAX_BE_USERS	8	/* adjust if too low for everday use */
 +
++=======
++>>>>>>> FETCH_HEAD
  /* ASoC no host IO hardware.
   * TODO: fine tune these values for all host less transfers.
   */
@@@ -1157,7 -1155,7 +1160,11 @@@ int dpcm_be_dai_startup(struct snd_soc_
  			continue;
  
  		/* first time the dpcm_params is open ? */
++<<<<<<< HEAD
 +		if (be->dpcm[stream].users == MAX_BE_USERS)
++=======
+ 		if (be->dpcm[stream].users == DPCM_MAX_BE_USERS)
++>>>>>>> FETCH_HEAD
  			dev_err(be->dev, "too many users %s at open - state %d\n",
  				stream ? "capture" : "playback", be->dpcm[stream].state);
  
@@@ -1350,6 -1348,81 +1357,84 @@@ static int soc_dpcm_fe_dai_shutdown(str
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int dpcm_fe_dai_hw_params_be(struct snd_soc_pcm_runtime *fe,
+ 	struct snd_soc_pcm_runtime *be,
+ 	struct snd_pcm_hw_params *params, int stream)
+ {
+ 	int ret;
+ 	struct snd_soc_dpcm_params *dpcm;
+ 	struct snd_pcm_substream *be_substream =
+ 		snd_soc_dpcm_get_substream(be, stream);
+ 
+ 	/* is this op for this BE ? */
+ 	if (!snd_soc_dpcm_be_can_update(fe, be, stream))
+ 		return 0;
+ 
+ 	/* only allow hw_params() if no connected FEs are running */
+ 	if (!snd_soc_dpcm_can_be_params(fe, be, stream))
+ 		return 0;
+ 
+ 	if ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&
+ 			(be->dpcm[stream].state !=
+ 				SND_SOC_DPCM_STATE_HW_PARAMS) &&
+ 			(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE))
+ 		return 0;
+ 
+ 	dev_dbg(be->dev, "ASoC: hw_params BE %s\n",
+ 			fe->dai_link->name);
+ 
+ 	/* perform any hw_params fixups */
+ 	if (be->dai_link->be_hw_params_fixup) {
+ 		ret = be->dai_link->be_hw_params_fixup(be,
+ 				params);
+ 		if (ret < 0) {
+ 			dev_err(be->dev,
+ 					"ASoC: hw_params BE fixup failed %d\n",
+ 					ret);
+ 			goto unwind;
+ 		}
+ 	}
+ 
+ 	ret = soc_pcm_hw_params(be_substream, params);
+ 	if (ret < 0) {
+ 		dev_err(be->dev, "ASoC: hw_params BE failed %d\n", ret);
+ 		goto unwind;
+ 	}
+ 
+ 	be->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;
+ 	return 0;
+ 
+ unwind:
+ 	/* disable any enabled and non active backends */
+ 	list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {
+ 		struct snd_soc_pcm_runtime *be = dpcm->be;
+ 		struct snd_pcm_substream *be_substream =
+ 			snd_soc_dpcm_get_substream(be, stream);
+ 
+ 		if (!snd_soc_dpcm_be_can_update(fe, be, stream))
+ 			continue;
+ 
+ 		/* only allow hw_free() if no connected FEs are running */
+ 		if (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))
+ 			continue;
+ 
+ 		if ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&
+ 			(be->dpcm[stream].state
+ 				!= SND_SOC_DPCM_STATE_HW_PARAMS) &&
+ 			(be->dpcm[stream].state
+ 				!= SND_SOC_DPCM_STATE_HW_FREE) &&
+ 			(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))
+ 			continue;
+ 
+ 		soc_pcm_hw_free(be_substream);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> FETCH_HEAD
  int dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int stream)
  {
  	struct snd_soc_dpcm_params *dpcm_params;
@@@ -1649,6 -1722,35 +1734,38 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ int dpcm_fe_dai_prepare_be(struct snd_soc_pcm_runtime *fe,
+ 		struct snd_soc_pcm_runtime *be, int stream)
+ {
+ 	struct snd_pcm_substream *be_substream =
+ 		snd_soc_dpcm_get_substream(be, stream);
+ 	int ret = 0;
+ 
+ 	/* is this op for this BE ? */
+ 	if (!snd_soc_dpcm_be_can_update(fe, be, stream))
+ 		return 0;
+ 
+ 	if ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&
+ 			(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))
+ 		return 0;
+ 
+ 	dev_dbg(be->dev, "ASoC: prepare BE %s\n",
+ 			fe->dai_link->name);
+ 
+ 	ret = soc_pcm_prepare(be_substream);
+ 	if (ret < 0) {
+ 		dev_err(be->dev, "ASoC: backend prepare failed %d\n",
+ 				ret);
+ 		return ret;
+ 	}
+ 
+ 	be->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
+ 	return ret;
+ }
+ 
++>>>>>>> FETCH_HEAD
  int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)
  {
  	struct snd_soc_dpcm_params *dpcm_params;
@@@ -1683,14 -1785,91 +1800,102 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +int soc_dpcm_fe_dai_prepare(struct snd_pcm_substream *substream)
 +{
 +	struct snd_soc_pcm_runtime *fe = substream->private_data;
 +	int stream = substream->stream, ret = 0;
 +
 +	mutex_lock(&fe->card->dpcm_mutex);
 +
 +	dev_dbg(fe->dev, "dpcm: prepare FE %s\n", fe->dai_link->name);
++=======
+ static void dpcm_be_async_prepare(void *data, async_cookie_t cookie)
+ {
+ 	struct snd_soc_dpcm_params *dpcm = data;
+ 	struct snd_soc_pcm_runtime *be = dpcm->be;
+ 	int stream = dpcm->stream;
+ 	struct snd_pcm_substream *be_substream =
+ 		snd_soc_dpcm_get_substream(be, stream);
+ 	int ret;
+ 
+ 	dev_dbg(be->dev, "%s ASoC: prepare BE %s\n", __func__,
+ 					dpcm->fe->dai_link->name);
+ 	ret = soc_pcm_prepare(be_substream);
+ 	if (ret < 0) {
+ 		be->err_ops = ret;
+ 		dev_err(be->dev, "ASoC: backend prepare failed %d\n",
+ 				ret);
+ 		return;
+ 	}
+ 	be->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
+ }
+ 
+ void dpcm_be_dai_prepare_async(struct snd_soc_pcm_runtime *fe, int stream,
+ 					    struct async_domain *domain)
+ {
+ 	struct snd_soc_dpcm_params *dpcm;
+ 	struct snd_soc_dpcm_params *dpcm_async[DPCM_MAX_BE_USERS];
+ 	int i = 0, j;
+ 
+ 	list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {
+ 		struct snd_soc_pcm_runtime *be = dpcm->be;
+ 
+ 		be->err_ops = 0;
+ 		/* is this op for this BE ? */
+ 		if (!snd_soc_dpcm_be_can_update(fe, be, stream))
+ 			continue;
+ 
+ 		if ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&
+ 			(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))
+ 			continue;
+ 
+ 		/* does this BE support async op ?*/
+ 		if ((fe->dai_link->async_ops & ASYNC_DPCM_SND_SOC_PREPARE) &&
+ 		    (be->dai_link->async_ops & ASYNC_DPCM_SND_SOC_PREPARE)) {
+ 			dpcm->stream = stream;
+ 			async_schedule_domain(dpcm_be_async_prepare,
+ 							    dpcm, domain);
+ 		} else {
+ 			dpcm_async[i++] = dpcm;
+ 		}
+ 	}
+ 
+ 	for (j = 0; j < i; j++) {
+ 		struct snd_soc_dpcm_params *dpcm = dpcm_async[j];
+ 		struct snd_soc_pcm_runtime *be = dpcm->be;
+ 		struct snd_pcm_substream *be_substream =
+ 			snd_soc_dpcm_get_substream(be, stream);
+ 		int ret;
+ 
+ 		dev_dbg(be->dev, "ASoC: prepare BE %s\n",
+ 				dpcm->fe->dai_link->name);
+ 
+ 		ret = soc_pcm_prepare(be_substream);
+ 		if (ret < 0) {
+ 			dev_err(be->dev, "ASoC: backend prepare failed %d\n",
+ 					ret);
+ 			be->err_ops = ret;
+ 			return;
+ 		}
+ 
+ 		be->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
+ 	}
+ }
+ 
+ int soc_dpcm_fe_dai_prepare(struct snd_pcm_substream *substream)
+ {
+ 	struct snd_soc_pcm_runtime *fe = substream->private_data;
+ 	struct snd_soc_dpcm_params *dpcm;
+ 	int stream = substream->stream, ret = 0;
+ 	ASYNC_DOMAIN_EXCLUSIVE(async_domain);
+ 
+ 	mutex_lock(&fe->card->dpcm_mutex);
+ 
+ 	fe->err_ops = 0;
+ 
+ 	dev_dbg(fe->dev, "ASoC: prepare FE %s\n", fe->dai_link->name);
++>>>>>>> FETCH_HEAD
  
  	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
  
@@@ -1703,23 -1882,52 +1908,72 @@@
  	}
  
  	ret = dpcm_be_dai_prepare(fe, substream->stream);
++<<<<<<< HEAD
 +	if (ret < 0)
 +		goto out;
 +
 +	/* call prepare on the frontend */
 +	if (!fe->fe_compr) {
 +		ret = soc_pcm_prepare(substream);
 +		if (ret < 0) {
 +			dev_err(fe->dev,"ASoC: prepare FE %s failed\n",
 +							fe->dai_link->name);
 +			goto out;
 +		}
 +	}
 +
 +	ret = soc_pcm_prepare(substream);
 +	if (ret < 0) {
 +		dev_err(fe->dev,"dpcm: prepare FE %s failed\n", fe->dai_link->name);
 +		goto out;
++=======
+ 	if (ret < 0) {
+ 		dev_err(fe->dev, "ASoC: prepare FE %s failed\n",
+ 						fe->dai_link->name);
+ 		goto out;
+ 	}
+ 
+ 	if (!(fe->dai_link->async_ops & ASYNC_DPCM_SND_SOC_PREPARE)) {
+ 		ret = dpcm_be_dai_prepare(fe, substream->stream);
+ 		if (ret < 0)
+ 			goto out;
+ 		/* call prepare on the frontend */
+ 		ret = soc_pcm_prepare(substream);
+ 		if (ret < 0) {
+ 			dev_err(fe->dev, "ASoC: prepare FE %s failed\n",
+ 					fe->dai_link->name);
+ 			goto out;
+ 		}
+ 	} else {
+ 		dpcm_be_dai_prepare_async(fe, substream->stream,
+ 							&async_domain);
+ 
+ 		/* call prepare on the frontend */
+ 		ret = soc_pcm_prepare(substream);
+ 		if (ret < 0) {
+ 			fe->err_ops = ret;
+ 			dev_err(fe->dev, "ASoC: prepare FE %s failed\n",
+ 					fe->dai_link->name);
+ 		}
+ 
+ 		async_synchronize_full_domain(&async_domain);
+ 
+ 		/* check if any BE failed */
+ 		list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients,
+ 							    list_be) {
+ 			struct snd_soc_pcm_runtime *be = dpcm->be;
+ 			if (be->err_ops < 0) {
+ 				ret = be->err_ops;
+ 				goto out;
+ 			}
+ 		}
+ 
+ 		/* check if FE failed */
+ 		if (fe->err_ops < 0) {
+ 			ret = fe->err_ops;
+ 			goto out;
+ 		}
++>>>>>>> FETCH_HEAD
  	}
  
  	/* run the stream event for each BE */
diff --cc sound/usb/card.c
index b38536b,a000cd6..0000000
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@@ -87,9 -87,7 +87,13 @@@ static int nrpacks = 8;		/* max. numbe
  static bool async_unlink = 1;
  static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
  static bool ignore_ctl_error;
++<<<<<<< HEAD
 +#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
  struct switch_dev *usbaudiosdev;
 +#endif
++=======
++struct switch_dev *usbaudiosdev;
++>>>>>>> FETCH_HEAD
  
  module_param_array(index, int, NULL, 0444);
  MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
@@@ -207,11 -205,24 +211,32 @@@ static int snd_usb_create_streams(struc
  	struct usb_device *dev = chip->dev;
  	struct usb_host_interface *host_iface;
  	struct usb_interface_descriptor *altsd;
++<<<<<<< HEAD
 +	void *control_header;
 +	int i, protocol;
 +
 +	/* find audiocontrol interface */
 +	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];
++=======
+ 	struct usb_interface *usb_iface;
+ 	void *control_header;
+ 	int i, protocol;
+ 
+ 	usb_iface = usb_ifnum_to_if(dev, ctrlif);
+ 	if (!usb_iface) {
+ 		snd_printk(KERN_ERR "%d:%u : does not exist\n",
+ 					dev->devnum, ctrlif);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* find audiocontrol interface */
+ 	host_iface = &usb_iface->altsetting[0];
+ 	if (!host_iface) {
+ 		snd_printk(KERN_ERR "Audio Control interface is not available.");
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	control_header = snd_usb_find_csint_desc(host_iface->extra,
  						 host_iface->extralen,
  						 NULL, UAC_HEADER);
@@@ -250,8 -261,7 +275,12 @@@
  
  	case UAC_VERSION_2: {
  		struct usb_interface_assoc_descriptor *assoc =
++<<<<<<< HEAD
 +			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;
 +
++=======
+ 						usb_iface->intf_assoc;
++>>>>>>> FETCH_HEAD
  		if (!assoc) {
  			snd_printk(KERN_ERR "Audio class v2 interfaces need an interface association\n");
  			return -EINVAL;
@@@ -267,9 -277,7 +296,13 @@@
  		break;
  	}
  	}
++<<<<<<< HEAD
 +#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 +	switch_set_state(usbaudiosdev, 1);
 +#endif
++=======
+ 	switch_set_state(usbaudiosdev, 2);
++>>>>>>> FETCH_HEAD
  	return 0;
  }
  
@@@ -587,9 -595,7 +620,13 @@@ static void snd_usb_audio_disconnect(st
  		mutex_unlock(&chip->shutdown_mutex);
  		mutex_unlock(&register_mutex);
  	}
++<<<<<<< HEAD
 +#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 +	switch_set_state(usbaudiosdev, 0);
 +#endif
++=======
+ 	switch_set_state(usbaudiosdev, 0);
++>>>>>>> FETCH_HEAD
  }
  
  /*
@@@ -722,15 -728,17 +759,28 @@@ static struct usb_driver usb_audio_driv
  
  static int __init snd_usb_audio_init(void)
  {
++<<<<<<< HEAD
 +#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 +	int err;
 +#endif
++=======
+ 	int err;
++>>>>>>> FETCH_HEAD
  	if (nrpacks < 1 || nrpacks > MAX_PACKS) {
  		printk(KERN_WARNING "invalid nrpacks value.\n");
  		return -EINVAL;
  	}
++<<<<<<< HEAD
 +#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 +	usbaudiosdev = kzalloc(sizeof(*usbaudiosdev), GFP_KERNEL);
++=======
+ 	usbaudiosdev = kzalloc(sizeof(*usbaudiosdev), GFP_KERNEL);
+ 	if (!usbaudiosdev) {
+ 		pr_err("Usb audio device memory allocation failed.\n");
+ 		return -ENOMEM;
+ 	}
+ 
++>>>>>>> FETCH_HEAD
  	usbaudiosdev->name = "usb_audio";
  
  	err = switch_dev_register(usbaudiosdev);
@@@ -738,16 -746,13 +788,23 @@@
  		pr_err("Usb-audio switch registration failed\n");
  	else
  		pr_debug("usb hs_detected\n");
++<<<<<<< HEAD
 +#endif
++=======
++>>>>>>> FETCH_HEAD
  	return usb_register(&usb_audio_driver);
  }
  
  static void __exit snd_usb_audio_cleanup(void)
  {
  	usb_deregister(&usb_audio_driver);
++<<<<<<< HEAD
 +#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
 +	kfree(usbaudiosdev);
 +#endif
++=======
+ 	kfree(usbaudiosdev);
++>>>>>>> FETCH_HEAD
  }
  
  module_init(snd_usb_audio_init);
